<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>오늘도 끄적끄적</title>
  
  <subtitle>느리더라도 꾸준하게</subtitle>
  <link href="https://perfectacle.github.io/atom.xml" rel="self"/>
  
  <link href="https://perfectacle.github.io/"/>
  <updated>2021-06-12T20:04:19.918Z</updated>
  <id>https://perfectacle.github.io/</id>
  
  <author>
    <name>양권성</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(JPA) persist vs merge</title>
    <link href="https://perfectacle.github.io/2021/06/13/entity-manager-persist-vs-merge/"/>
    <id>https://perfectacle.github.io/2021/06/13/entity-manager-persist-vs-merge/</id>
    <published>2021-06-12T19:02:52.000Z</published>
    <updated>2021-06-12T20:04:19.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>글을 정리하다 보니 너무 깊게 파고 정리한 거 같아 글이 너무 길어져서 아무도 읽지 않을 것 같아 정리부터 해보겠습니다.</p><ol><li>엔티티 매니저의 persist 메서드는 리턴값이 없기 때문에 원본 객체를 수정하고, merge 메서드는 리턴값이 있기 때문에 새로운 객체를 반환합니다.</li><li>JpaRepository.save 호출 시 엔티티의 식별자(@Id, @EmbeddedId 어노테이션이 붙은 컬럼 등등)가 붙은 필드의 타입이 primitive type이 아닐 때는 null이거나 숫자형일 때는 0이면 새로운 엔티티라고 판단하면서 persist 메서드가 호출되고, 그게 아니면 merge 메서드가 호출됩니다. </li><li>JPQL 호출 시 FlushMode가 AUTO(하이버네이트 기본 FlushMode)라 하더라도 쿼리 지연 저장소에 JPQL에서 사용하는 테이블과 관련있는 쿼리가 저장돼있지 않다면 flush를 호출하지 않습니다.</li><li>JPQL 호출 시 AutoFlushEvent가 발생하면서 flush 이전에 cascade가 먼저 이뤄지는데 이 때는 PersistEvent가 발생하면서 원본 엔티티를 변경합니다.</li><li>JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하고, cascade가 발생하는데 이 때 해당 엔티티에 대해 MergeEvent가 또 발생하면서 Transient 상태인 경우에는 원본 엔티티를 카피하고 카피한 객체의 값을 수정하고 연관관계가 맺어진 엔티티에서는 레퍼런스도 카피 객체로 바꿔치기 하고 있습니다.</li><li>JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하는데 cascade 이후에 DirtyChecking이나 Flush가 호출되지 않습니다.</li><li>모든 트랜잭션이 끝난 이후에 커밋 이전에 FlushMode가 MANUAL이 아니고, Managed Entity가 존재하면 FlushEvent를 발생시켜서 DirtyChecking 및 Flush를 하게 됩니다.</li></ol><p>제목은 엔티티 매니저의 persist와 merge에 대해 개념을 설명할 것처럼 적어놨지만 이해를 돕기 위해, 흥미 유발을 위해 사내에서 겪었던 문제 과정을 서술하겠습니다.</p><h2 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">&quot;mother&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">&quot;mother&quot;</span>, cascade = [CascadeType.ALL])</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children: MutableSet&lt;Child&gt; = mutableSetOf()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 산모 보호 차원에서 최근 출산일을 기록합니다.</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">&quot;recent_childbirth&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> recentChildbirth: ZonedDateTime? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">born</span><span class="params">(child: <span class="type">Child</span>)</span></span> &#123;</span><br><span class="line">        children.add(child)</span><br><span class="line">        child.bornFrom(<span class="keyword">this</span>)</span><br><span class="line">        recentChildbirth = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Seoul&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">&quot;child&quot;</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mother: Mother? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> birthday: LocalDate = LocalDate.now()</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bornFrom</span><span class="params">(mother: <span class="type">Mother</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mother = mother</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 엄마 아빠 유전자의 조합으로 인해 아이를 생성합니다.</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(father: <span class="type">Father</span>, mother: <span class="type">Mother</span>)</span></span>: Child &#123;</span><br><span class="line">            <span class="keyword">return</span> Child(...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자식을 낳는 Mother 엔티티와 Child 엔티티가 1:N 양방향 관계 매핑이 돼있는 상황입니다.<br>그리고 Mother의 모든 Cascade(영속성 전이) Action에 대해 children에게 전파가 되도록 하였습니다.</p><p>이제 산모는 출산 예정일이 다가와 산부인과에서 출산을 시작합니다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 산부인과 표현이 이게 맞는지 모르겠네용~</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObGyn</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> motherRepository: MotherRepository,</span><br><span class="line">    <span class="comment">// 산부인과에서 영재 양성 기관과 호적 저장소를 알고 있는 기이한 현상이지만 예제를 위해서 참아주세요!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> talentedPersonTrainingSchool: TalentedPersonTrainingSchool,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> familyRegisterRepository: FamilyRegisterRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// @Transactional 어노테이션을 붙인 이유는 예제를 위해 영속성 컨텍스트를 강제로 넓히기 위함이지 다른 이유는 없습니다.</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">naturalDeliveryWith</span><span class="params">(father: <span class="type">Father</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mother =</span><br><span class="line">            motherRepository.findByIdOrNull(father.wifeId) ?: <span class="keyword">throw</span> MotherNotFoundException(<span class="string">&quot;병원에 산모가 없습니다.&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> child = Child.create(father, mother)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 엄마가 아이를 낳습니다.</span></span><br><span class="line">        mother.born(child)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 아이의 부모는 아이가 태어나자마자 영재라는 삘이 와서 바로 영재 양성 기관에 등록합니다.</span></span><br><span class="line">        talentedPersonTrainingSchool.register(child)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 아이가 너무 마음에 들어 바로 호적에 올려버립니다.</span></span><br><span class="line">        <span class="keyword">val</span> familyRegister = familyRegisterRepository.findByFatherId(father.id)</span><br><span class="line">        familyRegister?.add(child)</span><br><span class="line">        <span class="keyword">if</span> (familyRegister != <span class="literal">null</span>) &#123;</span><br><span class="line">            familyRegisterRepository.save(familyRegister)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 산모의 최근 출산일도 변경되었고, 자식도 새롭게 생성되어서 child도 같이 저장해야할 것 같지만</span></span><br><span class="line">        <span class="comment">// 산모 객체의 children 필드는 CascadeType이 ALL이기 때문에 따로 child 객체는 저장하지 않아도 됩니다.</span></span><br><span class="line">        motherRepository.save(mother)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalentedPersonTrainingSchool</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> talentedPersonRepository: TalentedPersonRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(child: <span class="type">Child</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> talentedPerson = TalentedPerson(child.id)</span><br><span class="line">        talentedPersonRepository.save(talentedPerson)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드가 더럽긴 하지만, 일단 코드는 잘 돌아갈 것 같습니다만…<br>TalentedPersonTrainingSchool의 register 메서드를 호출할 때 TalentedPerson 객체에 child.id 필드에 접근합니다. </p><p><img src="/images/entity-manager-persist-vs-merge/child-has-not-id.png" alt="하지만 child 객체는 생성 당시 id 값을 지정하지 않았고, 아직 Transient(엔티티 매니저의 영속성 컨텍스트에 저장된 적도, DB에 저장된 적도 없는) 상태라 id는 null입니다."><br><img src="/images/entity-manager-persist-vs-merge/child-has-id-after-save.png" alt="save 이후에 브레이크 포인트를 찍어서 보면 child에 id가 할당돼있는 걸 볼 수 있습니다."></p><p>save를 하기 전에 엔티티의 ID를 사용하려고 해서 문제가 발생했으니 이제 save를 먼저 호출하면 될 것 같습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">naturalDeliveryWith</span><span class="params">(father: <span class="type">Father</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// child 엔티티의 id를 사용하기 전에 먼저 save를 때려줍니다. </span></span><br><span class="line">    motherRepository.save(mother)</span><br><span class="line"></span><br><span class="line">    talentedPersonTrainingSchool.register(child)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/entity-manager-persist-vs-merge/child-has-not-id-after-save.png"><br>save를 먼저 호출했음에도 불구하고, child의 id가 null입니다.<br>하지만 mother.children[0]에 있는 child에는 id가 박혀있습니다!!<br>또한 child와 mother.children[0]의 레퍼런스가 다른 걸 보아 다른 객체로 보이는군요!!</p><p>JPA 알못인 저에게는 정말 이해할 수 없는 미스테리였습니다.</p><h2 id="원인-분석"><a href="#원인-분석" class="headerlink" title="원인 분석"></a>원인 분석</h2><p>먼저 쿼리 로그를 한 번 봐봅시다.<br>save를 가장 나중에 호출한 케이스입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// motherRepository.findByIdOrNull(father.wifeId)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        mother0_.id <span class="keyword">as</span> id1_4_0_,</span><br><span class="line">        mother0_.recent_childbirth <span class="keyword">as</span> recent_c2_4_0_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        mother mother0_ </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        mother0_.id=?</span><br><span class="line">// mother.children의 FetchType이 eager가 아니기 때문에 실제 children을 사용할 때(mother.born(<span class="keyword">child</span>) 메서드 안에서) lazy하게 쿼리를 날립니다.</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        children0_.mother_id <span class="keyword">as</span> mother_i3_2_0_,</span><br><span class="line">        children0_.id <span class="keyword">as</span> id1_2_0_,</span><br><span class="line">        children0_.id <span class="keyword">as</span> id1_2_1_,</span><br><span class="line">        children0_.birthday <span class="keyword">as</span> birthday2_2_1_,</span><br><span class="line">        children0_.mother_id <span class="keyword">as</span> mother_i3_2_1_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        <span class="keyword">child</span> children0_ </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        children0_.mother_id=?</span><br><span class="line">// familyRegisterRepository.findByFatherId(father.id)는 JPQL이기 때문에 쿼리 실행 이전에 <span class="keyword">flush</span>를 호출(hibernate의 기본 FlushMode가 <span class="keyword">AUTO</span>이상이고 기타 등등의 사유로 인해) 해야하는지 판단하는데</span><br><span class="line">// mother.born(<span class="keyword">child</span>)에 의해 mother(<span class="keyword">Managed</span> Entity)의 children의 <span class="keyword">child</span>(Transient Entity)에 대해서는 <span class="keyword">insert</span> 쿼리가 날아갔습니다.</span><br><span class="line">// 신기한 건 mother(<span class="keyword">Managed</span> Entity)는 변경사항(recentChildbirth 필드)이 있는데도 <span class="keyword">update</span> 쿼리가 실행되지 않았습니다.</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        <span class="keyword">child</span></span><br><span class="line">        (<span class="keyword">id</span>, birthday, mother_id) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (<span class="literal">null</span>, ?, ?)</span><br><span class="line">// familyRegisterRepository.findByFatherId(father.id)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        familyregi0_.id <span class="keyword">as</span> id1_3_,</span><br><span class="line">        familyregi0_.fatherId <span class="keyword">as</span> fatherid2_3_,</span><br><span class="line">        familyregi0_.motherId <span class="keyword">as</span> motherid3_3_ </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        family_register familyregi0_ </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        familyregi0_.fatherId=?</span><br><span class="line">// motherRepository.save(mother) 이후에 바로 호출된 게 아니라 naturalDeliveryWith 메서드를 마치고 TransactionInterceptor에서 커밋하기 전에 <span class="keyword">flush</span>를 호출했습니다.</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        mother </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        recent_childbirth=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">id</span>=?</span><br></pre></td></tr></table></figure><h3 id="Child는-왜-insert-됐는가"><a href="#Child는-왜-insert-됐는가" class="headerlink" title="Child는 왜 insert 됐는가??"></a>Child는 왜 insert 됐는가??</h3><p>너무 내용이 길어서 3 줄로 요약해보면 </p><ol><li>JPQL 호출 이전에 AutoFlushEvent를 발생시키고 이벤트 핸들러인 DefaultAutoFlushEventListener 안에서 flushMightBeNeeded 메서드를 호출하는데 하이버네이트의 기본 FlushMode가 AUTO이기 때문에 true를 반환합니다.</li><li>본격적으로 flush 호출 이전에 전처리 작업(AbstractFlushingEventListener 클래스의 prepareEntityFlushes 메서드 등등)에서 영속성 컨텍스트에 있는 엔티티들에 대해 cascade를 수행합니다.</li><li>이 때 영속성 컨텍스트에 있는 Mother 엔티티의 children 프로퍼티에 대해 cascade 되면서 insert 쿼리가 호출됐습니다.</li></ol><p><code>child가 insert 된 이유는 flush를 호출했기 때문이 아니라 flush 이전에 cascade를 했기 때문입니다.</code></p><p>우선 JPQL을 호출하기 전에 child의 insert는 호출됐는데 왜 mother의 update는 호출이 되지 않은 건지 너무나 궁금했습니다.<br><img src="/images/entity-manager-persist-vs-merge/session-impl-auto-flush-if-required.png" alt="familyRegisterRepository.findByFatherId()를 쭉쭉 타고 들어가다보면 autoFlushIfRequired() 메서드를 호출하는 걸 볼 수 있습니다."></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * detect in-memory changes, determine if the changes are to tables</span></span><br><span class="line"><span class="comment"> * named in the query and, if so, complete execution the flush</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">autoFlushIfRequired</span><span class="params">(Set querySpaces)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">    checkOpen();</span><br><span class="line">    <span class="keyword">if</span> ( !isTransactionInProgress() ) &#123;</span><br><span class="line">        <span class="comment">// do not auto-flush while outside a transaction</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AutoFlushEvent event = <span class="keyword">new</span> AutoFlushEvent( querySpaces, <span class="keyword">this</span> );</span><br><span class="line">    fastSessionServices.eventListenerGroup_AUTO_FLUSH.fireEventOnEachListener( event, AutoFlushEventListener::onAutoFlush );</span><br><span class="line">    <span class="keyword">return</span> event.isFlushRequired();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 그 안에는 AutoFlushEvent를 발생시키고 있습니다.<br>DefaultAutoFlushEventListener의 onAutoFlush 메서드를 이벤트 리스너로 등록하고 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAutoFlush</span><span class="params">(AutoFlushEvent event)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> EventSource source = event.getSession();</span><br><span class="line">    <span class="keyword">final</span> SessionEventListenerManager eventListenerManager = source.getEventListenerManager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventListenerManager.partialFlushStart();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( flushMightBeNeeded( source ) ) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onAutoFlush 메서드에서는 flush가 필요한지 확인하고 있는데<br><img src="/images/entity-manager-persist-vs-merge/flush-might-be-needed.png" alt="Hibernate의 기본 FlushMode는 AUTO이고, ManagedEntity가 1개 이상이기 때문에 true를 반환합니다"><br><img src="/images/entity-manager-persist-vs-merge/in-flush-might-be-needed.png" alt="쿼리 지연 저장소(ActionQueue)에는 현재 하나도 쿼리가 없는 상태입니다."></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flushEverythingToExecutions</span><span class="params">(FlushEvent event)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG.trace( <span class="string">&quot;Flushing session&quot;</span> );</span><br><span class="line"></span><br><span class="line">    EventSource session = event.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PersistenceContext persistenceContext = session.getPersistenceContextInternal();</span><br><span class="line">    session.getInterceptor().preFlush( persistenceContext.managedEntitiesIterator() );</span><br><span class="line"></span><br><span class="line">    prepareEntityFlushes( session, persistenceContext );</span><br><span class="line">    <span class="comment">// we could move this inside if we wanted to</span></span><br><span class="line">    <span class="comment">// tolerate collection initializations during</span></span><br><span class="line">    <span class="comment">// collection dirty checking:</span></span><br><span class="line">    prepareCollectionFlushes( persistenceContext );</span><br><span class="line">    <span class="comment">// now, any collections that are initialized</span></span><br><span class="line">    <span class="comment">// inside this block do not get updated - they</span></span><br><span class="line">    <span class="comment">// are ignored until the next flush</span></span><br><span class="line"></span><br><span class="line">    persistenceContext.setFlushing( <span class="keyword">true</span> );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> entityCount = flushEntities( event, persistenceContext );</span><br><span class="line">        <span class="keyword">int</span> collectionCount = flushCollections( session, persistenceContext );</span><br></pre></td></tr></table></figure><p>flushEverythingToExecutions를 보면 prepareEntityFlushes, prepareCollectionFlushes를 통해 플러시 전처리를 하고,<br>flushEntities, flushCollections 메서드를 통해 실제로 플러시를 하는 것 같습니다.</p><p>이제 prepareEntityFlushes 메서드를 딥다이브 해봅시다.<br><img src="/images/entity-manager-persist-vs-merge/cascade-on-flush-for-managed-entity.png" alt="영속성 컨텍스트에 있는 놈 중 일부(reentrantSafeEntityEntries() 메서드 호출을 통해) 엔티티에 대해 영속성 전이(cascade)를 하고 있습니다."><br>현재 영속성 컨텍스트에 엔티티는 Mother(#1) 엔티티 하나 뿐이고, flush 하기 전에 엔티티에 대해서 영속성 전이시키는 걸 볼 수 있습니다.</p><p><img src="/images/entity-manager-persist-vs-merge/cascade-on-flush-before-flush.png" alt="flush 하기 이전에 cascade를 한다고 CascadePoint.BEFORE_FLUSH를 인자로 넘겨주고 있습니다."><br>참고로 getCascadingAction()의 결과는 ACTION_PERSIST_ON_FLUSH입니다.</p><p><img src="/images/entity-manager-persist-vs-merge/cascade-for-property-for-loop-01.png" alt="그리고 Mother 엔티티의 프로퍼티들의 타입과 이름을 구해와서 반복문을 돌리고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-for-property-for-loop-02.png" alt="프로퍼티마다 cascade를 하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-property-for-children.png" alt="children은 @OneToMany로 AssociationType이라서 cascadeAssociation 메서드가 호출됩니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-association-for-children.png" alt="children은 MutableSet&lt;Child&gt; 타입이라 collectionType이기 때문에 cascadeCollection 메서드가 호출됩니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-collection-for-children.png" alt="elemType(Child)의 isEntityType() 메서드가 true이기 때문에 cascadeCollectionElements 메서드가 호출됩니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-collection-elements-for-children.png" alt="children의 이터레이터를 가져와서 모든 요소에 대해 cascadeProperty 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-property-for-child.png" alt="child가 parent와 @ManyToOne으로 관계를 맺고 있기 때문에 associationType이라 cascadeAssociation 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-assocation-for-child.png" alt="child는 entityType이기 때문에 cascadeToOne 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-to-one-for-child.png" alt="ACTION_PERSIST_ON_FLUSH action의 cascade 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/session-impl-persist-on-flush.png" alt="SessionImpl(하이버네이트에서 EntityManager 인터페이스의 구현체)의 persistOnFlush에서 PersistEvent를 만들고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/default-persist-event-listener-on-persist.png" alt="DefaultPersistEventListener의 onPersist 메서드가 호출되는데 entity의 상태가 Transient이기 때문에 entityIsTransient 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/abstract-save-event-listener-add-insert-action.png" alt="AbstractSaveEventListener의 addInsertAction 메서드가 호출되는데 isDelayed가 false인 insert action을 넘겨주고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/action-queue-add-insert-action-01.png" alt="ActionQueue의 addInsertAction 메서드를 호출하는데 isDelayed가 false이기 때문에 insert.isEarlyInsert()가 true라서 큐에 인서트 액션을 넣지 않고, 바로 executeInserts 메서드를 호출해서 쿼리를 실행하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/action-queue-execute-inserts.png" alt="큐에 있는 인서트 쿼리를 호출하려고 보니 큐가 비어있어서 사실상 호출하지는 않습니다."><br><img src="/images/entity-manager-persist-vs-merge/action-queue-add-insert-action-02.png" alt="ActionQueue의 addInsertAction 메서드로 다시 돌아와서 nonNullableTransientDependencies는 null이기 때문에 addResolvedEntityInsertAction 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/action-queue-add-resolved-entity-insert-action.png" alt="ActionQueue의 addResolvedEntityInsertAction 메서드에서는 executeInserts 메서드를 다시 호출하는데 insert 큐에 쿼리가 없어서 아무것도 실행되지 않고 execute 메서드에서 해당 insert 쿼리를 실행합니다."><br><img src="/images/entity-manager-persist-vs-merge/abstract-returning-delegate-perform-insert.png" alt="AbstractReturningDelegate의 performInsert 메서드에서는 JDBC의 PreparedStatement도 보이고, 실제로 insert 쿼리를 실행하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/entity-identity-insert-action-execute.png" alt="insert 쿼리 실행 이후 id 값을 받아온 후 EntityIdentityInsertAction의 execute 메서드 안에서 AbstractEntityPersister의 setIdentifier 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/set-id-non-final.png" alt="안을 까고 들어가보면 리플렉션을 사용하고 있고, id 필드가 final이 아닌 경우(var)에는 UnsafeObjectFieldAccessorImpl의 set 메서드를 호출합니다."><br><img src="/images/entity-manager-persist-vs-merge/set-id-final.png" alt="id 필드가 final인 경우(val)에는 UnsafeQualifiedObjectFieldAccessorImple의 set 메서드를 호출합니다."><br><img src="/images/entity-manager-persist-vs-merge/set-id-final-primitive.png" alt="id 필드가 final이면서(val) primitive long 타입인 경우에는 UnsafeQualifiedLongFieldAccessorImple의 set 메서드를 호출합니다."></p><h3 id="Mother는-왜-update-되지-않았는가"><a href="#Mother는-왜-update-되지-않았는가" class="headerlink" title="Mother는 왜 update 되지 않았는가?"></a>Mother는 왜 update 되지 않았는가?</h3><p>이것도 내용이 길어서 3줄 요악 해보겠습니다.</p><ol><li>AbstractFlushingEventListener 클래스의 flushEntities 메서드에서는 flush 호출 이전에 영속성 컨텍스트에 있는 엔티티에 대해 Dirty Checking이 발생하고, 쿼리 지연 저장소(ActionQueue)에 EntityUpdateAction을 추가합니다.</li><li>DefaultAutoFlushEventListener 클래스의 flushIsReallyNeeded 메서드에서는 하이버네이트의 기본 FlushMode가 ALWAYS가 아니고(하이버네이트 기본은 FlushMode.AUTO임), AutoFlushEvent의 querySpaces([family_register])가 쿼리 지연 저장소(ActionQueue)에 있는 액션(EntityUpdateAction)과 관련 없는 테이블(mother)이기 때문에 false를 반환합니다.</li><li>힘겹게 쿼리 지연 저장소에 다 밀어넣었건만 flushIsReallyNeeded가 false이면 결국 flush는 호출되지 않습니다.</li></ol><p><code>결국 Mother의 변경내역은 쿼리 지연 저장소에 저장됐지만 현재 JPQL에서 사용하는 family_register와 상관 없는 테이블인 mother이므로 flush가 호출되지 않습니다.</code> </p><p>이제 엔티티를 flush할 준비(prepareEntityFlushes 메서드)가 끝났으니 다음 부분(flushEntities 메서드)을 딥다이브 해봅시다.</p><p><img src="/images/entity-manager-persist-vs-merge/after-prepare-entity-flushes.png" alt="엔티티를 플러시할 준비(prepareEntityFlushes 메서드) 단계에서는 cascade를 수행하고, 아직 쿼리 지연 저장소는 비어있습니다."><br><img src="/images/entity-manager-persist-vs-merge/flush-entites.png" alt="flushEntites 안에서는 FlushEntityEvent를 발생시키고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/find-dirty.png" alt="FlushEntityEvent의 핸들러에서는 업데이트 쿼리를 날려야하는 건지 판단하기 위해 엔티티의 dirty checking(findDirty 메서드)을 하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/dirty-checking.png" alt="recentChildbirth 프로퍼티 하나가 달라졌기 때문에 dirtyProperties가 하나 존재하고 FlushEntityEvent에 할당하고 있습니다."></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isUpdateNecessary</span><span class="params">(FlushEntityEvent event)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line"></span><br><span class="line">    EntityPersister persister = event.getEntityEntry().getPersister();</span><br><span class="line">    Status status = event.getEntityEntry().getStatus();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !event.isDirtyCheckPossible() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dirtyProperties = event.getDirtyProperties();</span><br><span class="line">        <span class="keyword">if</span> ( dirtyProperties != <span class="keyword">null</span> &amp;&amp; dirtyProperties.length != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//<span class="doctag">TODO:</span> suck into event class</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hasDirtyCollections( event, persister, status );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultFlushEntityEventListener의 isUpdateNecessary 메서드에서 dirtyProperties 유무에 따라 업데이트가 필요한지 판단하고 있는데 하나가 있기 때문에 true를 반환합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFlushEntity</span><span class="params">(FlushEntityEvent event)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object entity = event.getEntity();</span><br><span class="line">    <span class="keyword">final</span> EntityEntry entry = event.getEntityEntry();</span><br><span class="line">    <span class="keyword">final</span> EventSource session = event.getSession();</span><br><span class="line">    <span class="keyword">final</span> EntityPersister persister = entry.getPersister();</span><br><span class="line">    <span class="keyword">final</span> Status status = entry.getStatus();</span><br><span class="line">    <span class="keyword">final</span> Type[] types = persister.getPropertyTypes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mightBeDirty = entry.requiresDirtyCheck( entity );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] values = getValues( entity, entry, mightBeDirty, session );</span><br><span class="line"></span><br><span class="line">    event.setPropertyValues( values );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> avoid this for non-new instances where mightBeDirty==false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> substitute = wrapCollections( session, persister, entity, entry.getId(), types, values );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( isUpdateNecessary( event, mightBeDirty ) ) &#123;</span><br><span class="line">        substitute = scheduleUpdate( event ) || substitute;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>isUpdateNecessary가 true이기 때문에 scheduleUpdate 메서드가 호출되는데 이름만 봐도 바로 지연 저장소에 저장할 거 같은 메서드네요.</p><p><img src="/images/entity-manager-persist-vs-merge/schedule-update.png" alt="scheduleUpdate 메서드 안에서 큐(쿼리 지연 저장소)에다가 EntityUpdateAction을 추가하고 있네요."><br>하지만 여기까지 왔다고 해서 flush가 정말로 되는 건 아닙니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAutoFlush</span><span class="params">(AutoFlushEvent event)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> EventSource source = event.getSession();</span><br><span class="line">    <span class="keyword">final</span> SessionEventListenerManager eventListenerManager = source.getEventListenerManager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventListenerManager.partialFlushStart();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( flushMightBeNeeded( source ) ) &#123;</span><br><span class="line">            <span class="comment">// Need to get the number of collection removals before flushing to executions</span></span><br><span class="line">            <span class="comment">// (because flushing to executions can add collection removal actions to the action queue).</span></span><br><span class="line">            <span class="keyword">final</span> ActionQueue actionQueue = source.getActionQueue();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> oldSize = actionQueue.numberOfCollectionRemovals();</span><br><span class="line">            flushEverythingToExecutions( event );</span><br><span class="line">            <span class="keyword">if</span> ( flushIsReallyNeeded( event, source ) ) &#123;</span><br></pre></td></tr></table></figure><p>flushMightBeNeeded에서 ‘flush가 필요할지도 몰라’ 정도까지만 판단을 하고, flushIsReallyNeeded에서 ‘정말로 flush가 필요한가?’에 대한 검토를 또 하고 있네요.<br>(지금까지 우리는 flushEverythingToExecutions에 대해 딥다이브를 마쳤습니다.)</p><p><img src="/images/entity-manager-persist-vs-merge/flush-is-really-needed.png" alt="하이버네이트의 기본 FlushMode는 AUTO라서 앞에 조건은 false이고, 쿼리 지연 저장소에 있는 내용이 현재 이벤트의 querySpace(family_regiser)와 관련이 있는지를 확인해보고 있네요."><br><img src="/images/entity-manager-persist-vs-merge/are-tables-to-be-updated-01.png" alt="여러 액션(insert, remove, update 등등)을 반복하는데 그 중에 현재 큐에 있는 액션은 Update(Mother 엔티티에 대한) 뿐입니다."><br>해당 액션이 family_register 테이블과 관련이 있는지 확인하고 있습니다.</p><p><img src="/images/entity-manager-persist-vs-merge/are-tables-to-be-updated-02.png" alt="Update 액션(Mother 엔티티 업데이트)의 테이블(mother)과 이벤트의 querySpace의 테이블(family_regiser)와 관련이 있는지를 확인하고 있네요."><br>관련이 없기 때문에 false를 반환합니다.</p><p>JPQL 호출 시 flush를 무조건 호출하는 줄 알았는데 쿼리 지연 저장소에 생긴 쿼리의 테이블과 관련이 있다는 사실도 참 신기하네요. (어찌보면 쿼리를 날릴 필요가 없으면 안 날리는 게 최적화 측면에서는 당연해보이긴 하네요.)</p><h3 id="motherRepository-save-mother-는-왜-아무런-쿼리도-호출하지-않는가"><a href="#motherRepository-save-mother-는-왜-아무런-쿼리도-호출하지-않는가" class="headerlink" title="motherRepository.save(mother)는 왜 아무런 쿼리도 호출하지 않는가?"></a>motherRepository.save(mother)는 왜 아무런 쿼리도 호출하지 않는가?</h3><p>이것도 내용이 길어서 3줄 요악 해보겠습니다.</p><ol><li>mother가 새로운 엔티티는 아니기 때문에 entityManager.merge(mother)가 호출되고, Merge 이벤트를 발생시킵니다.</li><li>Merge 이벤트의 핸들러인 DefaultMergeEventListener 클래스의 onMerge 메서드에서는 엔티티의 상태가 Persistent이므로 entityIsPersistent 메서드가 호출되는데 cascade는 이전(JPQL 호출 시)에 진작 끝냈기 때문에 아무런 쿼리가 호출되지 않습니다.  </li><li>최상단 트랜잭션(obGyn.naturalDeliveryWith 메서드)이 끝나지 않아 commit을 호출하지 않았기 때문에 flush도 호출되지 않았습니다.</li></ol><p><img src="/images/entity-manager-persist-vs-merge/simple-jpa-repository-save.png" alt="JpaRepository의 구현체인 SimpleJpaRepository 클래스의 save 메서드가 호출됩니다"><br>새로운 엔티티냐, 아니냐에 따라 persist vs merge 메서드를 호출하는데</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ID id = getId(entity);</span><br><span class="line">    Class&lt;ID&gt; idType = getIdType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!idType.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> id == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Number) id).longValue() == <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;Unsupported primitive id type %s!&quot;</span>, idType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractEntityInformation 클래스의 isNew 메서드를 보면 <code>primitive 타입이 아니면 null이거나 Number 타입이면 0인 경우에만 새로운 엔티티</code>라고 취급하고 있습니다.<br>근데 Mother는 id에 값이 있기 때문에 새로운 엔티티가 아니라서 EntityManager의 merge 메서드가 호출됩니다.</p><p><img src="/images/entity-manager-persist-vs-merge/session-impl-merge.png" alt="SessionImpl(하이버네이트에서 EntityManager 인터페이스를 구현한 구현체)의 merge 메서드가 호출되고 MergeEvent를 생성하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-on-merge.png" alt="DefaultMergeEventListener의 onMerge 메서드가 호출되는데 Mother는 Persistent(영속성 컨텍스트에서 Managed되고 있는 상태) 상태이므로 entityIsPersistent 메서드가 호출됩니다."><br><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-entity-is-persistent.png" alt="DefaultMergeEventListener의 entityIsPersistent 메서드가 호출되는데 cascadeOnMerge는 위에서 JPQL 호출되면서 Mother 엔티티의 필드는 전부 cascade가 끝난 상태라 쿼리가 날아가는 게 없고, copyValues는 자기 자신(entity 인스턴스가 entity 인스턴스에게)을 카피 뜨는 거라 크게 관련이 없는 코드입니다."><br><img src="/images/entity-manager-persist-vs-merge/do-not-commit.png" alt="부모 트랜잭션(obGyn.naturalDeliveryWith 메서드)의 트랜잭션이 전파된 거라 새로운 트랜잭션은 아니라서 실제 커밋이 수행되지는 않아 flush도 호출되지 않습니다."></p><h3 id="왜-부모-트랜잭션이-끝난-이후에-mother의-update-쿼리가-날아갔을까"><a href="#왜-부모-트랜잭션이-끝난-이후에-mother의-update-쿼리가-날아갔을까" class="headerlink" title="왜 부모 트랜잭션이 끝난 이후에 mother의 update 쿼리가 날아갔을까?"></a>왜 부모 트랜잭션이 끝난 이후에 mother의 update 쿼리가 날아갔을까?</h3><p>여기도 3줄 요약해보겠습니다.</p><ol><li>트랜잭션이 모두 끝나고 커밋하기 이전에 flush를 해야하는지 FlushMode를 확인합니다.</li><li>FlushMode가 MANUAL이 아니기 때문에 엔티티매니저에 대해 FlushEvent가 발생합니다.</li><li>FlushEvent가 발생하면 DirtyChecking 및 쿼리 지연 저장소에 저장한 후에 flush가 이루어집니다.</li></ol><p>motherRepository.save(mother)에서는 아무런 메서드가 날아가지 않고, 부모 트랜잭션(obGyn.naturalDeliveryWith 메서드)이 끝날 때 무슨 코드 때문에 쿼리를 호출하는 건지도 궁금해졌습니다.<br><img src="/images/entity-manager-persist-vs-merge/before-transaction-completion.png" alt="부모 트랜잭션이 끝날 때 커밋이 되는데 커밋이 되기 이전에 beforeTransactionCompletion 메서드가 호출되는데 이 때 flush가 진행되게 됩니다."></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBeforeTransactionCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> doFlush = isTransactionFlushable()</span><br><span class="line">            &amp;&amp; getHibernateFlushMode() != FlushMode.MANUAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( doFlush ) &#123;</span><br><span class="line">            managedFlush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionMapperStandardImpl.INSTANCE.mapManagedFlushFailure( <span class="string">&quot;error during managed flush&quot;</span>, re, <span class="keyword">this</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하이버네이트의 기본 FlushMode는 AUTO이기 때문에 doFlush가 true이고, managedFlush 메서드를 호출하게 됩니다.</p><p><img src="/images/entity-manager-persist-vs-merge/session-impl-do-flush.png" alt="계속 진행하다보면 엔티티 매니저(SessionImpl)의 doFlush를 호출하는데 이 때 FlushEvent를 발생시킵니다."><br><img src="/images/entity-manager-persist-vs-merge/default-flush-event-listener-on-flush.png" alt="FlushEvent의 이벤트 리스너인 DefaultFlushEventListener 클래스의 onFlush 메서드"><br>FlushEvent의 이벤트 리스너 안에서 Managed Entity가 존재하므로 if 문 안을 보면, flushEverythingToExecutions을 호출하는데 이 때 Dirty Checking과 쿼리 지연 저장소에 저장이 이루어집니다.<br>그리고 performExecutions 안에서 실제 쿼리 지연 저장소에 있는 내용에 대해 flush가 호출됩니다.</p><h3 id="motherRepository-save-mother-를-먼저-수행했을-때-child의-레퍼런스는-왜-바뀌었을까"><a href="#motherRepository-save-mother-를-먼저-수행했을-때-child의-레퍼런스는-왜-바뀌었을까" class="headerlink" title="motherRepository.save(mother)를 먼저 수행했을 때 child의 레퍼런스는 왜 바뀌었을까?"></a>motherRepository.save(mother)를 먼저 수행했을 때 child의 레퍼런스는 왜 바뀌었을까?</h3><p>여기도 너무 길어서 4줄 요약해보자면</p><ol><li>mother가 새로운 엔티티는 아니기 때문에 entityManager.merge(mother)가 호출되고, mother 엔티티에 대해 Merge 이벤트를 발생시킵니다.</li><li>Merge 이벤트의 핸들러인 DefaultMergeEventListener 클래스의 onMerge 메서드에서는 Managed Entity에 대해서 cascade가 발생하는데 child 엔티티에 대해서도 Merge 이벤트를 발생시킵니다.</li><li>DefaultMergeEventListener 클래스의 onMerge 메서드에서는 Transient 상태인 child 엔티티에 대해서 카피본을 뜨고 카피에다가만 id를 할당한 후에 MergeContext 캐시에 entity를 key로, copy를 value로 할당하고 있습니다.</li><li>mother 엔티티의 Merge 이벤트에서는 cascade가 전부 끝난 이후에 프로퍼티에 값 재할당이 일어나는데 이 때 children을 전부 비우고 copy로 채워넣으면서 레퍼런스가 바뀌게 됩니다. </li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObGyn</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> motherRepository: MotherRepository,</span><br><span class="line">    <span class="comment">// 산부인과에서 영재 양성 기관과 호적 저장소를 알고 있는 기이한 현상이지만 예제를 위해서 참아주세요!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> talentedPersonTrainingSchool: TalentedPersonTrainingSchool,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> familyRegisterRepository: FamilyRegisterRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// @Transactional 어노테이션을 붙인 이유는 예제를 위해 영속성 컨텍스트를 강제로 넓히기 위함이지 다른 이유는 없습니다.</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">naturalDeliveryWith</span><span class="params">(father: <span class="type">Father</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mother =</span><br><span class="line">            motherRepository.findByIdOrNull(father.wifeId) ?: <span class="keyword">throw</span> MotherNotFoundException(<span class="string">&quot;병원에 산모가 없습니다.&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> child = Child.create(father, mother)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 엄마가 아이를 낳습니다.</span></span><br><span class="line">        mother.born(child)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// child의 id를 먼저 설정하고 사용하기 위해 save를 먼저 호출 </span></span><br><span class="line">        motherRepository.save(mother)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 아이의 부모는 아이가 태어나자마자 영재라는 삘이 와서 바로 영재 양성 기관에 등록합니다.</span></span><br><span class="line">        talentedPersonTrainingSchool.register(child)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 아이가 너무 마음에 들어 바로 호적에 올려버립니다.</span></span><br><span class="line">        <span class="keyword">val</span> familyRegister = familyRegisterRepository.findByFatherId(father.id)</span><br><span class="line">        familyRegister?.add(child)</span><br><span class="line">        <span class="keyword">if</span> (familyRegister != <span class="literal">null</span>) &#123;</span><br><span class="line">            familyRegisterRepository.save(familyRegister)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/entity-manager-persist-vs-merge/simple-jpa-repository-save-em-merge.png" alt="SimpleJpaRepository.save에서 entity의 id가 primitive tpye이 아닌데 null이 아니기 때문에 새로운 엔티티가 아니라 판단하고 entityManger.merge 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/session-impl-merge-2.png" alt="하이버네이트에서 EntityManager의 구현체인 SessionImpl의 merge 메서드에서는 MergeEvent를 발생시키고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-on-merge-02.png" alt="MergeEvent의 이벤트 핸들러인 DefaultMergeEventListener의 onMerge 메서드에서는 mother 엔티티의 상태가 Persistent이기 때문에 entityIsPersistent 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-entity-is-persistent-02.png" alt="entityIsPersistent 안에서는 cascadeOnMerge 메서드를 실행하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-cascade-on-merge.png" alt="cascadeOnMerge 안에서는 Cascade.cascade를 호출하는데 ACTION_MERGE인 CascadingActions를 넘기고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/do-cascade-02.png" alt="그리고 Mother 엔티티의 모든 프로퍼티에 대해 cascade를 하는데 children은 CascadeType.ALL이기 때문에 true를 반환해서 cascade를 진행합니다."><br><img src="/images/entity-manager-persist-vs-merge/cascade-to-one-for-child-02.png" alt="child 하나에 대해 cascade 할 때 ACTION_MERGE action의 cascade 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/action-merge-cascade.png" alt="ACTION_MERGE action의 cascade 메서드에서는 session(엔티티 매니저)의 merge 메서드를 호출하고 있습니다."><br><img src="/images/entity-manager-persist-vs-merge/session-impl-merge-3.png" alt="SessionImpl(하이버네이트에서 EntityManager 인터페이스의 구현체)의 merge 메서드에서 MergeEvent를 만들고 있습니다."><br>여기가 핵심입니다.<br>이전에 JPQL 호출 시 AutoFlushEvent의 이벤트 리스너에서는 ACTION_PERSIST_ON_FLUSH CascadingActions의 cascade를 호출하면서 <code>Child 엔티티에 대해 PersistEvent를 발생</code>시켰는데,<br>motherRepository.save 호출 시 MergeEvent의 이벤트 리스너에서는 ACTION_MERGE인 CascadingActions의 cascade를 호출하면서 <code>Child 엔티티에 대해 MergeEvent를 발생</code>시키고 있습니다.<br>그럼 PersistEvent와 MergeEvent의 차이점을 알아봅시다.</p><p><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-on-merge-03.png" alt="MergeEvent의 리스너인 DefaultMergeEventListener의 onMerge 메서드에서 Child 엔티티의 상태가 Transient(엔티티 매니저의 영속성 컨텍스트에 저장된 적도, DB에 저장된 적도 없는) 상태이기 때문에 entityIsTransient 메서드가 호출됩니다."><br><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-entity-is-transient.png" alt="entityIsTransient 메서드 안에서는 엔티티에 대한 카피를 뜨고 있습니다."><br>또 결정적 차이가 여기서 나옵니다.<br>PersistEvent의 이벤트 리스너인 DefaultPersistEventListener 클래스의 onPersist 메서드에서 호출하는 <code>DefaultPersistEventListener 클래스의 entityIsTransient 메서드에서는 entity에 대해 카피를 뜬 적이 없습니다.</code><br>하지만 MergeEvent의 이벤트 리스너인 DefaultMergeEventListener 클래스의 onMerge 메서드에서 호출하는 <code>DefaultMergeEventListener 클래스의 entityIsTransient 메서드에서는 entity에 대해 카피를 뜨고 있습니다.</code><br>카피 뜰 때 default constructor가 없으면 아마도 <code>org.hibernate.InstantiationException: No default constructor for entity</code> 요런 예외를 던지지 않을까 싶네요.<br>기본 생성자를 호출했기 때문에 아직 값은 카피되지 않고 객체 생성까지만 된 상태입니다.<br>그리고 copyCache라는 <code>MergeContext에 entity를 key로, copy를 value</code>로 해서 넣고 있습니다.</p><p><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-entity-is-transient-02.png" alt="super.cascadeBeforeSave 안에서는 child entity의 모든 프로퍼티에 대해 cascade를 하고 있고, copyValues 이후에 entity의 모든 값이 복사되고 있습니다."><br>그리고 saveTransientEntity 메서드에서 실질적인 insert가 이루어지는데 entity를 넘기는 게 아니라 <code>copy를 넘기고</code> 있습니다.  </p><p><img src="/images/entity-manager-persist-vs-merge/after-save-transient-entity.png" alt="saveTransientEntity에서 실질적인 insert가 이루어지는데 copy를 넘겼기 때문에 copy에만 id가 할당돼있습니다."><br><img src="/images/entity-manager-persist-vs-merge/default-merge-event-listener-entity-is-persistent-03.png" alt="mother의 모든 프로퍼티에 cascade가 끝나고 copyValues 메서드가 호출됩니다."><br><img src="/images/entity-manager-persist-vs-merge/replace-elements.png" alt="copyValues 안에서는 프로퍼티 하나하나에 대해서 replace를 치고 있는데 children 프로퍼티를 가져와서 리스트를 비워버리고 있네요."><br><img src="/images/entity-manager-persist-vs-merge/replace-elements-02.png" alt="그리고 children에 하나하나씩 값을 replace해서 채워넣고 있는데 이 때 copy로 채워지게 됩니다."></p><p>이렇게 copy를 뜨고, copy에만 id를 할당하고, collection을 비운 후 copy로 채우기 때문에 외부 변수는 여전히 id가 null인 상태로 남게 됩니다.</p><p>여담으로 child가 Transient 상태이기 때문에 카피를 뜨고 카피로 레퍼런스를 바꾸고 했는데, 이미 Persistent 상태인 child였다면 카피를 뜨지 않아 레퍼런스를 바꾸지 않습니다.</p><h2 id="Persist-vs-Merge"><a href="#Persist-vs-Merge" class="headerlink" title="Persist vs Merge"></a>Persist vs Merge</h2><p>이제 진짜 하고 싶었던 핵심인 엔티티 매니저의 persist와 merge 메서드에 대해 이야기 해보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EntityManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make an instance managed and persistent.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity  entity instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> EntityExistsException if the entity already exists.</span></span><br><span class="line"><span class="comment">     * (If the entity already exists, the &lt;code&gt;EntityExistsException&lt;/code&gt; may </span></span><br><span class="line"><span class="comment">     * be thrown when the persist operation is invoked, or the</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;EntityExistsException&lt;/code&gt; or another &lt;code&gt;PersistenceException&lt;/code&gt; may be </span></span><br><span class="line"><span class="comment">     * thrown at flush or commit time.) </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the instance is not an</span></span><br><span class="line"><span class="comment">     *         entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TransactionRequiredException if there is no transaction when</span></span><br><span class="line"><span class="comment">     *         invoked on a container-managed entity manager of that is of type </span></span><br><span class="line"><span class="comment">     *         &lt;code&gt;PersistenceContextType.TRANSACTION&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(Object entity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge the state of the given entity into the</span></span><br><span class="line"><span class="comment">     * current persistence context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity  entity instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the managed instance that the state was merged to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if instance is not an</span></span><br><span class="line"><span class="comment">     *         entity or is a removed entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TransactionRequiredException if there is no transaction when</span></span><br><span class="line"><span class="comment">     *         invoked on a container-managed entity manager of that is of type </span></span><br><span class="line"><span class="comment">     *         &lt;code&gt;PersistenceContextType.TRANSACTION&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">merge</span><span class="params">(T entity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>별 건 없고, persist는 return 타입이 없고, merge는 있는 게 가장 큰 차이입니다.<br>어디서 봤는데 return 타입이 없으면 원본 객체를 수정하고, return type이 있으면 새로운 객체를 반환하는 게 뭐 뭘 분리해서 좋은 패턴이다~<br>라는 걸 본 거 같은데 아시는 분 있으면 댓글 남겨주시면 감사하겠습니다.</p><p>여튼 위에서 말했듯 그런 패턴을 지킨 걸로 보입니다.<br>persists는 return 타입이 없는데 id는 할당해야하니 당연히 새로운 객체를 만들 수는 없고 원본 객체를 수정할테고,<br>merge는 return 타입이 있는 걸로 보아 원본 객체는 수정하지 않고, id가 할당된 새 객체를 반환하는 걸로 보입니다.</p><p>persist와 merge에 대해 이해하면 위에서 있었던 PersistEvent와 MergeEvent가 왜 그렇게 동작했는지 이해할 수 있게 됩니다.<br>JPQL 호출 시 cascade가 이루어질 때는 PersistEvent가 발생하기 때문에 persist 메서드의 특성을 생각해보면 원본 객체에 id가 할당됐던 것이 당연한 게 됩니다.<br>그리고 save 호출 시 cascade가 이루어질 때는 새로운 엔티티가 아니라서 MergeEvent가 발생했기 때문에 merge 메서드의 특성을 생각해보면 새로운 객체를 반환하고, 레퍼런스도 바꿔치는 게 당연한 게 됩니다.</p><p>그럼 persist와 merge에 대한 간단한 예제를 보시면 이해하시는 데 더 도움이 될 것 같습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `새로운 엔티티라면 persist가 호출되면서 원본 엔티티를 반환하고, 새로운 엔티티가 아니면 merge가 호출되면서 새로운 엔티티 객체를 반환한다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mother = Mother()</span><br><span class="line">    <span class="keyword">val</span> persistedMother = motherRepository.save(mother)</span><br><span class="line"></span><br><span class="line">    persistedMother shouldBeSameInstanceAs mother</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> newMother = Mother(<span class="number">2L</span>)</span><br><span class="line">    <span class="keyword">val</span> mergedNewMother = motherRepository.save(newMother)</span><br><span class="line"></span><br><span class="line">    mergedNewMother.id shouldBe <span class="number">2L</span></span><br><span class="line">    mergedNewMother shouldNotBeSameInstanceAs newMother</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mergedMergedNewMother = motherRepository.save(mergedNewMother)</span><br><span class="line"></span><br><span class="line">    mergedMergedNewMother.id shouldBe <span class="number">2L</span></span><br><span class="line">    mergedMergedNewMother shouldNotBeSameInstanceAs mergedNewMother</span><br><span class="line">    mergedMergedNewMother shouldNotBeSameInstanceAs newMother</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="푸념"><a href="#푸념" class="headerlink" title="푸념"></a>푸념</h2><p>단순히 save 메서드의 위치를 바꿨다고 해서 이렇게까지 동작이 달라질 줄은 몰랐습니다.<br>복잡한 연관관계(CascadeAction 등등)와 JPQL이 어느 타이밍에 호출되는데 엔티티는 현재 어떤 상태인지 등등을 고려해가면서 코드를 짜야하니 예측성이 너무 떨어지는 것 같습니다.<br>엔티티를 객체-테이블 매핑 이상의 역할인 도메인(비즈니스 로직을 담은) 객체로 사용하고, 역할에 맞게 객체를 덜 쪼갰기 때문에 요런 문제가 발생하긴 했지만…<br>이제 JPA가 그렇게 좋은지 모르겠네요… 예측성이 너무 떨어지고, 알아야할 게 너무 많은 거 같습니다.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;글을 정리하다 보니 너무 깊게 파고 정리한 거 같아 글이 너무 길어져서 아무도 읽지 않을 것 같아 정리부터 해보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;엔티티 매니저의 persist 메서드는 리턴값이 없기 때문에 원본 객체를 수정하고, merge 메서드는 리턴값이 있기 때문에 새로운 객체를 반환합니다.&lt;/li&gt;
&lt;li&gt;JpaRepository.save 호출 시 엔티티의 식별자(@Id, @EmbeddedId 어노테이션이 붙은 컬럼 등등)가 붙은 필드의 타입이 primitive type이 아닐 때는 null이거나 숫자형일 때는 0이면 새로운 엔티티라고 판단하면서 persist 메서드가 호출되고, 그게 아니면 merge 메서드가 호출됩니다. &lt;/li&gt;
&lt;li&gt;JPQL 호출 시 FlushMode가 AUTO(하이버네이트 기본 FlushMode)라 하더라도 쿼리 지연 저장소에 JPQL에서 사용하는 테이블과 관련있는 쿼리가 저장돼있지 않다면 flush를 호출하지 않습니다.&lt;/li&gt;
&lt;li&gt;JPQL 호출 시 AutoFlushEvent가 발생하면서 flush 이전에 cascade가 먼저 이뤄지는데 이 때는 PersistEvent가 발생하면서 원본 엔티티를 변경합니다.&lt;/li&gt;
&lt;li&gt;JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하고, cascade가 발생하는데 이 때 해당 엔티티에 대해 MergeEvent가 또 발생하면서 Transient 상태인 경우에는 원본 엔티티를 카피하고 카피한 객체의 값을 수정하고 연관관계가 맺어진 엔티티에서는 레퍼런스도 카피 객체로 바꿔치기 하고 있습니다.&lt;/li&gt;
&lt;li&gt;JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하는데 cascade 이후에 DirtyChecking이나 Flush가 호출되지 않습니다.&lt;/li&gt;
&lt;li&gt;모든 트랜잭션이 끝난 이후에 커밋 이전에 FlushMode가 MANUAL이 아니고, Managed Entity가 존재하면 FlushEvent를 발생시켜서 DirtyChecking 및 Flush를 하게 됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;제목은 엔티티 매니저의 persist와 merge에 대해 개념을 설명할 것처럼 적어놨지만 이해를 돕기 위해, 흥미 유발을 위해 사내에서 겪었던 문제 과정을 서술하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;문제-상황&quot;&gt;&lt;a href=&quot;#문제-상황&quot; class=&quot;headerlink&quot; title=&quot;문제 상황&quot;&gt;&lt;/a&gt;문제 상황&lt;/h2&gt;</summary>
    
    
    
    <category term="Back-end" scheme="https://perfectacle.github.io/categories/Back-end/"/>
    
    <category term="Spring" scheme="https://perfectacle.github.io/categories/Back-end/Spring/"/>
    
    
    <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
    <category term="Hibernate" scheme="https://perfectacle.github.io/tags/Hibernate/"/>
    
    <category term="Spring Data JPA" scheme="https://perfectacle.github.io/tags/Spring-Data-JPA/"/>
    
  </entry>
  
  <entry>
    <title>(JPA) 엔티티 매니저는 리퀘스트 당 하나만 생성되지 않을 수 있다.</title>
    <link href="https://perfectacle.github.io/2021/05/24/entity-manager-lifecycle/"/>
    <id>https://perfectacle.github.io/2021/05/24/entity-manager-lifecycle/</id>
    <published>2021-05-23T19:44:56.000Z</published>
    <updated>2021-05-24T17:38:40.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3줄-요약"><a href="#3줄-요약" class="headerlink" title="3줄 요약"></a>3줄 요약</h2><ol><li>OSIV가 꺼져있으면 트랜잭션이 시작될 때 엔티티 매니저가 생성되고, 트랜잭션이 끝날 때 엔티티 매니저를 종료한다.</li><li>OSIV가 꺼져있고, 다른 트랜잭션이라면 엔티티 매니저가 공유되지 않기 때문에 엔티티 매니저의 1차 캐시도 서로 공유되지 않는다.</li><li>OSIV가 켜져있으면 요청 당 엔티티 매니저는 한 번 생성되고, 뷰 렌더링이 끝날 때까지 엔티티 매니저는 종료되지 않고 트랜잭션이 다르더라도 1차 캐시가 공유된다. </li></ol><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>엔티티 매니저 팩토리는 생성 비용이 비싸서 대부분 어플리케이션 당 하나를 생성하는 편이고, 엔티티 매니저는 생성 비용이 비싸지 않아서 어플리케이션에서 여러 번 생성된다.<br>하지만 엔티티 매니저는 쓰레드 세이프 하지 않기 때문에, 쓰레드 당 하나를 생성해야할 것 같고 Spring MVC는 리퀘스트 당 하나의 쓰레드가 할당되기 때문에 리퀘스트 당 하나의 엔티티 매니저가 생성될 것만 같은 기분이 든다.<br>나 또한 그렇게 알고 있었는데 아래 코드를 통해 뭔가 의문이 생겼다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SomeRepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">SomeEntity, Long</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> repository: SomeRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">some</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> someEntity = repository.findById(<span class="number">1L</span>)</span><br><span class="line">        <span class="keyword">val</span> someEntity2 = repository.findById(<span class="number">1L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 보면 select 쿼리는 몇 번 날아갈 것 같은가??<br>첫 라인에서는 엔티티 매니저의 1차 캐시에 아무것도 없어서 쿼리가 날아갈 것 같고, 두 번째 라인에서는 엔티티 매니저의 1차 캐시에 id가 1인 SomeEntity가 있을 것 같으니 쿼리가 안 날아갈 것 같지 않은가?<br>답은 <code>spring.jpa.open-in-view: false</code>로 OSIV 설정이 꺼져있으면 두 번 날아가고, OSIV 설정을 따로 건드리지 않았다면 기본적으로 켜져있을테니 한 번만 날아가게 된다.</p><p>먼저 알아둬야할 사항은 JpaRepository 인터페이스의 기본 구현체인 <a href="https://github.com/spring-projects/spring-data-jpa/blob/main/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java#L83">SimpleJpaRepository</a>에 대해 알아야한다.<br>우리가 만든 인터페이스 SomeRepository도 결국 실행될 때는 객체화 돼야하는데 이 때 JpaRepository 구현체인 SimpleJpaRepository를 상속받아서 구현되기 때문이다.<br><img src="/images/entity-manager-lifecycle/simple-jpa-repository.png" alt="Spring AOP는 인터페이스 타입에 대해서는 JDK Dynamic Proxy를 사용하여 프록시 객체를 생성한다.">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">JpaRepositoryImplementation</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(id, ID_MUST_NOT_BE_NULL);</span><br><span class="line"></span><br><span class="line">        Class&lt;T&gt; domainType = getDomainClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(em.find(domainType, id));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LockModeType type = metadata.getLockModeType();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; hints = getQueryHints().withFetchGraphs(em).asMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(type == <span class="keyword">null</span> ? em.find(domainType, id, hints) : em.find(domainType, id, type, hints));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리가 만든 repository의 findById 메서드를 호출하면 기본적으로 SimpleJpaRepository의 findById 메서드를 호출하게 되고, readOnly <code>트랜잭션 안에서 실행</code>된다고 보면 된다.</p><h2 id="OSIV가-꺼졌을-때"><a href="#OSIV가-꺼졌을-때" class="headerlink" title="OSIV가 꺼졌을 때"></a>OSIV가 꺼졌을 때</h2><h3 id="엔티티-매니저-생성"><a href="#엔티티-매니저-생성" class="headerlink" title="엔티티 매니저 생성"></a>엔티티 매니저 생성</h3><ol><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java#L119">TransactionInterceptor의 invoke 메서드</a>에서 부모 클래스인 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L336">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L382">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L579">createTransactionIfNecessary 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L595">createTransactionIfNecessary 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L341">AbstractPlatformTransactionManager의 getTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L347">AbstractPlatformTransactionManager의 getTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L367">JpaTransactionManager의 doGetTransaction 메서드</a>를 호출한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = <span class="keyword">new</span> JpaTransactionObject();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line"></span><br><span class="line">    EntityManagerHolder emHolder = (EntityManagerHolder)</span><br><span class="line">            TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>엔티티 매니저 팩토리를 가져온 후에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/TransactionSynchronizationManager.java#L138">TransactionSynchronizationManager의 getResource 메서드</a>를 호출하고 있다.  </li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/TransactionSynchronizationManager.java#L140">TransactionSynchronizationManager의 getResource 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/TransactionSynchronizationManager.java#L140">doGetResource 메서드</a>를 호출하고 있다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doGetResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object value = map.get(actualKey);</span><br><span class="line">    <span class="comment">// Transparently remove ResourceHolder that was marked as void...</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">        map.remove(actualKey);</span><br><span class="line">        <span class="comment">// Remove entire ThreadLocal if empty...</span></span><br><span class="line">        <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">            resources.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>actualKey는 엔티티 매니저 팩토리이고, resources는 ThreadLocal Map 객체란 걸 알 수 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>하지만 해당 쓰레드에서는 한 번도 엔티티 매니저 팩토리를 키로 맵에 값을 넣은 적이 없기 때문에 null을 반환하게 된다.</p><p>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L367">JpaTransactionManager의 doGetTransaction 메서드</a>로 돌아와보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = <span class="keyword">new</span> JpaTransactionObject();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line"></span><br><span class="line">    EntityManagerHolder emHolder = (EntityManagerHolder)</span><br><span class="line">            TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());</span><br><span class="line">    <span class="keyword">if</span> (emHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Found thread-bound EntityManager [&quot;</span> + emHolder.getEntityManager() +</span><br><span class="line">                    <span class="string">&quot;] for JPA transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        txObject.setEntityManagerHolder(emHolder, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionSynchronizationManager.getResource(obtainEntityManagerFactory())가 null을 반환하기 때문에 txObject는 entityManagerHolder를 초기화하지 못한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L350">AbstractPlatformTransactionManager의 getTransaction 메서드</a>로 돌아오면 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L391">JpaTransactionManager의 isExistingTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L392">JpaTransactionManager의 isExistingTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L692">JpaTransactionObject의 hasTransaction 매서드</a>를 호출한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.entityManagerHolder != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.entityManagerHolder.isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>entityManagerHolder는 null이기 때문에 hasTransaction은 false이고 isExistingTransaction 메서드도 false이다.</li></ol><p>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L361">AbstractPlatformTransactionManager의 getTransaction 메서드</a>로 돌아와보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">    <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || </span><br><span class="line">            def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">            def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Transactional의 기본 propagation 설정은 PROPAGATION_REQUIRED이기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L394">startTransaction 메서드</a>를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">            definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    doBegin(transaction, definition);</span><br><span class="line">    prepareSynchronization(status, definition);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultTransactionStatus <span class="title">newTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionDefinition definition, <span class="meta">@Nullable</span> Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, <span class="meta">@Nullable</span> Object suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> actualNewSynchronization = newSynchronization &amp;&amp;</span><br><span class="line">            !TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultTransactionStatus(</span><br><span class="line">            transaction, newTransaction, actualNewSynchronization,</span><br><span class="line">            definition.isReadOnly(), debug, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>새롭게 트랜잭션을 시작하는 것이기 때문에 TransactionStatus를 만들 때 newTransaction을 true로 만든다.<br>그리고나서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L396">JpaTransactionManager의 doBegin 메서드</a>를 호출한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = (JpaTransactionObject) transaction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!txObject.hasEntityManagerHolder() ||</span><br><span class="line">                txObject.getEntityManagerHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">            EntityManager newEm = createEntityManagerForTransaction();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Opened new EntityManager [&quot;</span> + newEm + <span class="string">&quot;] for JPA transaction&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            txObject.setEntityManagerHolder(<span class="keyword">new</span> EntityManagerHolder(newEm), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Bind the entity manager holder to the thread.</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewEntityManagerHolder()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.bindResource(</span><br><span class="line">                    obtainEntityManagerFactory(), txObject.getEntityManagerHolder());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 봤다싶이 EntityManagerHolder를 초기화하지 못했기 때문에 위 if문을 타고 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L480">createEntityManagerForTransaction 메서드</a>를 호출하여 엔티티 매니저를 생성하고 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L672">JpaTransactionObject의 setEntityManagerHolder 메서드</a>를 호출하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEntityManagerHolder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> EntityManagerHolder entityManagerHolder, <span class="keyword">boolean</span> newEntityManagerHolder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.entityManagerHolder = entityManagerHolder;</span><br><span class="line">    <span class="keyword">this</span>.newEntityManagerHolder = newEntityManagerHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티 매니저 홀더를 초기화하는 것과 더불어 <code>새로운 엔티티 매니저 홀더라고 마킹</code>까지 하고 있다.<br>그리고 새로운 엔티티 매니저 홀더라고 마킹했기 때문에 txObject.isNewEntityManagerHolder()는 true이고, <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/TransactionSynchronizationManager.java#L177">TransactionSynchronizationManager의 bindResource 메서드</a>를 호출하고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bind the given resource for the given key to the current thread.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key to bind the value to (usually the resource factory)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to bind (usually the active resource object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if there is already a value bound to the thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResourceTransactionManager#getResourceFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bindResource</span><span class="params">(Object key, Object value)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">    Assert.notNull(value, <span class="string">&quot;Value must not be null&quot;</span>);</span><br><span class="line">    Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">    <span class="comment">// set ThreadLocal Map if none found</span></span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        resources.set(map);</span><br><span class="line">    &#125;</span><br><span class="line">    Object oldValue = map.put(actualKey, value);</span><br><span class="line">    <span class="comment">// Transparently suppress a ResourceHolder that was marked as void...</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) oldValue).isVoid()) &#123;</span><br><span class="line">        oldValue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already value [&quot;</span> + oldValue + <span class="string">&quot;] for key [&quot;</span> +</span><br><span class="line">                actualKey + <span class="string">&quot;] bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Bound value [&quot;</span> + value + <span class="string">&quot;] for key [&quot;</span> + actualKey + <span class="string">&quot;] to thread [&quot;</span> +</span><br><span class="line">                Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>쓰레드 로컬 맵인 resources에 엔티티 매니저 팩토리를 키로, 엔티티 매니저 홀더를 값으로 넣고 있다.</p><p>이렇게 트랜잭션이 시작할 때 엔티티 매니저가 생성된다는 것을 알 수 있다.</p><h3 id="엔티티-매니저-종료"><a href="#엔티티-매니저-종료" class="headerlink" title="엔티티 매니저 종료"></a>엔티티 매니저 종료</h3><p>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L336">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>로 돌아오자.  </p><ol><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L407">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L649">commitTransactionAfterReturning 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L654">commitTransactionAfterReturning 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L688">AbstractPlatformTransactionManager의 commit 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L711">AbstractPlatformTransactionManager의 commit 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L720">processCommit 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L790">processCommit 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L998">cleanupAfterCompletion 메서드</a>를 호출하고 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    status.setCompleted();</span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        TransactionSynchronizationManager.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>새롭게 만든 트랜잭션이기 때문에 status.isNewTransaction()은 true이고, <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L615">JpaTransactionManager의 doCleanupAfterCompletion 메서드</a>를 호출한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCleanupAfterCompletion</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = (JpaTransactionObject) transaction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the entity manager holder from the thread, if still there.</span></span><br><span class="line">    <span class="comment">// (Could have been removed by EntityManagerFactoryUtils in order</span></span><br><span class="line">    <span class="comment">// to replace it with an unsynchronized EntityManager).</span></span><br><span class="line">    <span class="keyword">if</span> (txObject.isNewEntityManagerHolder()) &#123;</span><br><span class="line">        TransactionSynchronizationManager.unbindResourceIfPossible(obtainEntityManagerFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티 매니저 홀더를 설정할 때도 새 엔티티 매니저 홀더라고 마킹했기 때문에 txObject.isNewEntityManagerHolder()는 true라서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/TransactionSynchronizationManager.java#L224">TransactionSynchronizationManager의 unbindResourceIfPossible 메서드</a>를 호출한다.<br>그 다음에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/TransactionSynchronizationManager.java#L233">doUnbindResource 메서드</a>를 호출하고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doUnbindResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object value = map.remove(actualKey);</span><br><span class="line">    <span class="comment">// Remove entire ThreadLocal if empty...</span></span><br><span class="line">    <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">        resources.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Transparently suppress a ResourceHolder that was marked as void...</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Removed value [&quot;</span> + value + <span class="string">&quot;] for key [&quot;</span> + actualKey + <span class="string">&quot;] from thread [&quot;</span> +</span><br><span class="line">                Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resources는 쓰레드 로컬 맵이고, 이전에 엔티티 매니저 팩토리를 키로, 엔티티 매니저 홀더를 값으로 넣었기 때문에 해당 키는 삭제된다.</p><p>그리고 다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L645">JpaTransactionManager의 doCleanupAfterCompletion 메서드</a>를 마저 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCleanupAfterCompletion</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = (JpaTransactionObject) transaction;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Remove the entity manager holder from the thread.</span></span><br><span class="line">    <span class="keyword">if</span> (txObject.isNewEntityManagerHolder()) &#123;</span><br><span class="line">        EntityManager em = txObject.getEntityManagerHolder().getEntityManager();</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Closing JPA EntityManager [&quot;</span> + em + <span class="string">&quot;] after transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        EntityManagerFactoryUtils.closeEntityManager(em);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Not closing pre-bound JPA EntityManager after transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JpaTransactionObject을 만들 때 새로운 엔티티 매니저 홀더라고 마킹했기 때문에 txObject.isNewEntityManagerHolder()는 true이고, <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/EntityManagerFactoryUtils.java#L423">EntityManagerFactoryUtils의 closeEntityManager 메서드</a>를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Close the given JPA EntityManager,</span></span><br><span class="line"><span class="comment"> * catching and logging any cleanup exceptions thrown.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> em the JPA EntityManager to close (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> javax.persistence.EntityManager#close()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeEntityManager</span><span class="params">(<span class="meta">@Nullable</span> EntityManager em)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (em != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (em.isOpen()) &#123;</span><br><span class="line">                em.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to release JPA EntityManager&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 트랜잭션이 끝날 때 엔티티 매니저가 종료된다는 것을 알게 되었다.  </p><h3 id="부모-트랜잭션을-사용한다면…"><a href="#부모-트랜잭션을-사용한다면…" class="headerlink" title="부모 트랜잭션을 사용한다면…?"></a>부모 트랜잭션을 사용한다면…?</h3><p>만약 트랜잭션이 부모의 것을 사용하여 쭉 이어진다면 어떻게 될까…?</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> repository: SomeRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">some</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> someEntity = repository.findById(<span class="number">1L</span>)</span><br><span class="line">        <span class="keyword">val</span> someEntity2 = repository.findById(<span class="number">1L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleJpaRepository의 findById(자식)가 SomeService(부모)의 트랜잭션을 사용한다면 어떻게 될까…?<br>먼저 SomeService 진입 시 새로운 트랜잭션이 생성(엔티티 매니저도 생성)되는 건 생략하고 그 이후 과정부터 지켜보자.  </p><ol><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java#L119">TransactionInterceptor의 invoke 메서드</a>에서 부모 클래스인 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L336">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L382">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L579">createTransactionIfNecessary 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L595">createTransactionIfNecessary 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L341">AbstractPlatformTransactionManager의 getTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L347">AbstractPlatformTransactionManager의 getTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L367">JpaTransactionManager의 doGetTransaction 메서드</a>를 호출한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = <span class="keyword">new</span> JpaTransactionObject();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line"></span><br><span class="line">    EntityManagerHolder emHolder = (EntityManagerHolder)</span><br><span class="line">            TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());</span><br><span class="line">    <span class="keyword">if</span> (emHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Found thread-bound EntityManager [&quot;</span> + emHolder.getEntityManager() +</span><br><span class="line">                    <span class="string">&quot;] for JPA transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        txObject.setEntityManagerHolder(emHolder, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>이미 부모 트랜잭션에서 TransactionSynchronizationManager.bindResource 메서드를 호출했기 때문에 TransactionSynchronizationManager.getResource는 null이 아니다.<br>따라서 txObject에 emHolder를 초기화할 수 있는데, 부모 트랜잭션에서 만들어둔 엔티티 매니저 홀더이기 때문에 새로운 엔티티 매니저 홀더가 아니라고 마킹한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">    TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line">    Object transaction = doGetTransaction();</span><br><span class="line">    <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L350">AbstractPlatformTransactionManager의 getTransaction 메서드</a>으로 돌아오면 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L391">JpaTransactionManager의 isExistingTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L392">JpaTransactionManager의 isExistingTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L692">JpaTransactionObject의 hasTransaction 매서드</a>를 호출한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.entityManagerHolder != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.entityManagerHolder.isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>둘 다 true이기 때문에 hasTransaction도 true를 반환한다.<br>결국 isExistingTransaction(transaction)도 true이기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L408">handleExistingTransaction 메서드</a>를 호출한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> DefaultTransactionStatus <span class="title">prepareTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionDefinition definition, <span class="meta">@Nullable</span> Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, <span class="meta">@Nullable</span> Object suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">            definition, transaction, newTransaction, newSynchronization, debug, suspendedResources);</span><br><span class="line">    prepareSynchronization(status, definition);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultTransactionStatus <span class="title">newTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionDefinition definition, <span class="meta">@Nullable</span> Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, <span class="meta">@Nullable</span> Object suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> actualNewSynchronization = newSynchronization &amp;&amp;</span><br><span class="line">            !TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultTransactionStatus(</span><br><span class="line">            transaction, newTransaction, actualNewSynchronization,</span><br><span class="line">            definition.isReadOnly(), debug, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>새로운 트랜잭션이 아니라 부모 트랜잭션을 그대로 사용하는 것이기 때문에 newTransaction을 false로 마킹을 해서 TransactionStatus를 반환한다.<br>결국 새로운 트랜잭션을 시작한 게 아니기 때문에 엔티티 매니저 홀더도 부모가 쓰던 걸 물려받았고, 그렇기 때문에 새롭게 엔티티 매니저를 생성하지 않았다.<br>그럼 부모 트랜잭션부터 시작된 엔티티 매니저가 유지되기 때문에 엔티티 매니저의 1차 캐시도 유지된다고 볼 수 있다.</li></ol><p>그럼 자식 트랜잭션이 종료될 때는 엔티티 매니저를 종료할까??<br>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L336">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>로 돌아오자.  </p><ol><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L407">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L649">commitTransactionAfterReturning 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L654">commitTransactionAfterReturning 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L688">AbstractPlatformTransactionManager의 commit 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L711">AbstractPlatformTransactionManager의 commit 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L720">processCommit 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L790">processCommit 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L998">cleanupAfterCompletion 메서드</a>를 호출하고 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    status.setCompleted();</span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        TransactionSynchronizationManager.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.getSuspendedResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Resuming suspended transaction after completion of inner transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object transaction = (status.hasTransaction() ? status.getTransaction() : <span class="keyword">null</span>);</span><br><span class="line">        resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>transaction이 새로운 트랜잭션이 아니기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L615">JpaTransactionManager의 doCleanupAfterCompletion 메서드</a>를 호출하고 있지 않다.<br>해당 메서드 안에서 쓰레드 로컬 맵도 지우고, 엔티티 매니저도 종료하는 등의 작업을 하고 있는데 호출하지 않기 때문에 엔티티 매니저는 종료되지 않는다.</li></ol><p>즉, 부모 트랜잭션이 종료되기 전까지 엔티티 매니저를 새롭게 생성하거나 종료하는 일이 발생하지 않기 때문에 엔티티 매니저가 유효하고, 1차 캐시도 공유된다는 걸 알 수 있다. (물론 부모 트랜잭션을 사용하지 않는 Propagation.REQUIRES_NEW를 사용한다면 부모 트랜잭션을 사용하지 않고 새로운 트랜잭션을 만들기 때문에 엔티티 매니저를 새롭게 생성하고 해당 트랜잭션이 종료될 때 엔티티 매니저도 같이 종료될 것이다.)<br>트랜잭션 내에서만 1차 캐시의 성능 최적화를 맛 볼 수 있기 때문에 생각보다 1차 캐시의 hit rate가 낮을 것 같다.   </p><h2 id="OSIV가-켜져있을-때"><a href="#OSIV가-켜져있을-때" class="headerlink" title="OSIV가 켜져있을 때"></a>OSIV가 켜져있을 때</h2><p>Spring Boot의 Auto Configuration인 <a href="https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java#L206">JpaWebConfiguration</a>을 보면 아래와 같이 설정이 돼있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(WebMvcConfigurer.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123; OpenEntityManagerInViewInterceptor.class, OpenEntityManagerInViewFilter.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingFilterBean(OpenEntityManagerInViewFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.jpa&quot;, name = &quot;open-in-view&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaWebConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(JpaWebConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">JpaWebConfiguration</span><span class="params">(JpaProperties jpaProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jpaProperties = jpaProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OpenEntityManagerInViewInterceptor <span class="title">openEntityManagerInViewInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.jpaProperties.getOpenInView() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;spring.jpa.open-in-view is enabled by default. &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Therefore, database queries may be performed during view &quot;</span></span><br><span class="line">                    + <span class="string">&quot;rendering. Explicitly configure spring.jpa.open-in-view to disable this warning&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OpenEntityManagerInViewInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">openEntityManagerInViewInterceptorConfigurer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            OpenEntityManagerInViewInterceptor interceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addWebRequestInterceptor(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>spring.jpa.open-in-view</code>가 설정돼있지 않거나 true로 설정돼있으면 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.java#L59">OpenEntityManagerInViewInterceptor</a>가 적용된다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenEntityManagerInViewInterceptor</span> <span class="keyword">extends</span> <span class="title">EntityManagerFactoryAccessor</span> <span class="keyword">implements</span> <span class="title">AsyncWebRequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preHandle</span><span class="params">(WebRequest request)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        EntityManagerFactory emf = obtainEntityManagerFactory();</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.hasResource(emf)) &#123;</span><br><span class="line">            <span class="comment">// Do not modify the EntityManager: just mark the request accordingly.</span></span><br><span class="line">            Integer count = (Integer) request.getAttribute(key, WebRequest.SCOPE_REQUEST);</span><br><span class="line">            <span class="keyword">int</span> newCount = (count != <span class="keyword">null</span> ? count + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            request.setAttribute(getParticipateAttributeName(), newCount, WebRequest.SCOPE_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Opening JPA EntityManager in OpenEntityManagerInViewInterceptor&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                EntityManager em = createEntityManager();</span><br><span class="line">                EntityManagerHolder emHolder = <span class="keyword">new</span> EntityManagerHolder(em);</span><br><span class="line">                TransactionSynchronizationManager.bindResource(emf, emHolder);</span><br><span class="line">    </span><br><span class="line">                AsyncRequestInterceptor interceptor = <span class="keyword">new</span> AsyncRequestInterceptor(emf, emHolder);</span><br><span class="line">                asyncManager.registerCallableInterceptor(key, interceptor);</span><br><span class="line">                asyncManager.registerDeferredResultInterceptor(key, interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (PersistenceException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DataAccessResourceFailureException(<span class="string">&quot;Could not create JPA EntityManager&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(WebRequest request, <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!decrementParticipateCount(request)) &#123;</span><br><span class="line">            EntityManagerHolder emHolder = (EntityManagerHolder)</span><br><span class="line">                    TransactionSynchronizationManager.unbindResource(obtainEntityManagerFactory());</span><br><span class="line">            logger.debug(<span class="string">&quot;Closing JPA EntityManager in OpenEntityManagerInViewInterceptor&quot;</span>);</span><br><span class="line">            EntityManagerFactoryUtils.closeEntityManager(emHolder.getEntityManager());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요청이 들어오면 preHandle 메서드가 실행되는데 TransactionSynchronizationManager.hasResource(emf)는 아마 false가 반환될 것이다. (대부분 그럴 거 같은데 100%는 아닐 것이다.)<br>TransactionSynchronizationManager 안의 쓰레드 로컬 맵(resources 변수)에 해당 키(emf)가 존재하는지 확인하는 메서드인데 아직 해당 키가 존재하지 않을 것이기 때문이다.<br>그럼 else 문을 타서 새롭게 엔티티 매니저, 엔티티 매니저 홀더를 생성하고 TransactionSynchronizationManager의 bindResource 메서드에서 쓰레드 로컬 맵(resources 변수)에 엔티티 매니저 팩토리를 키로, 엔티티 매니저 홀더를 값으로 넣게 된다.</p><p>그리고 뷰 렌더링이 모두 끝나면 afterCompletion이 호출되는데 이 때 TransactionSynchronizationManager의 unbindResource 메서드에서 쓰레드 로컬 맵(resources 변수)에 할당된 키(엔티티 매니저 팩토리)도 제거하고 엔티티 매니저도 종료하는 걸 볼 수 있다.</p><p>그럼 인터셉터에서 엔티티 매니저를 생성한 이후에 또 생성하거나 미리 제거하는 일은 없는 걸까??</p><h3 id="엔티티-매니저-생성-1"><a href="#엔티티-매니저-생성-1" class="headerlink" title="엔티티 매니저 생성"></a>엔티티 매니저 생성</h3><ol><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java#L119">TransactionInterceptor의 invoke 메서드</a>에서 부모 클래스인 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L336">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L382">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L579">createTransactionIfNecessary 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L595">createTransactionIfNecessary 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L341">AbstractPlatformTransactionManager의 getTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L347">AbstractPlatformTransactionManager의 getTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L367">JpaTransactionManager의 doGetTransaction 메서드</a>를 호출한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = <span class="keyword">new</span> JpaTransactionObject();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line"></span><br><span class="line">    EntityManagerHolder emHolder = (EntityManagerHolder)</span><br><span class="line">            TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());</span><br><span class="line">    <span class="keyword">if</span> (emHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Found thread-bound EntityManager [&quot;</span> + emHolder.getEntityManager() +</span><br><span class="line">                    <span class="string">&quot;] for JPA transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        txObject.setEntityManagerHolder(emHolder, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>이미 OpenEntityManagerInViewInterceptor에서 TransactionSynchronizationManager.bindResource 메서드를 호출했기 때문에 TransactionSynchronizationManager.getResource는 null이 아니다.<br>따라서 txObject에 emHolder를 초기화할 수 있는데, OpenEntityManagerInViewInterceptor에서 만들어둔 엔티티 매니저 홀더이기 때문에 새로운 엔티티 매니저 홀더가 아니라고 마킹한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">    TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line">    Object transaction = doGetTransaction();</span><br><span class="line">    <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L350">AbstractPlatformTransactionManager의 getTransaction 메서드</a>으로 돌아오면 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L391">JpaTransactionManager의 isExistingTransaction 메서드</a>를 호출한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L392">JpaTransactionManager의 isExistingTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L692">JpaTransactionObject의 hasTransaction 매서드</a>를 호출한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.entityManagerHolder != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.entityManagerHolder.isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>entityManagerHolder는 null이 아니지만 isTransactionActive가 false이기 때문에 hasTransaction은 false를 반환한다.<br>결국 isExistingTransaction(transaction)은 false이기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L408">handleExistingTransaction 메서드</a>를 호출하지 않는다.</li></ol><p>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L361">AbstractPlatformTransactionManager의 getTransaction 메서드</a>로 돌아와보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">    <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || </span><br><span class="line">            def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">            def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@Transactional의 기본 propagation 설정은 PROPAGATION_REQUIRED이기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L394">startTransaction 메서드</a>를 호출한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">            definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    doBegin(transaction, definition);</span><br><span class="line">    prepareSynchronization(status, definition);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultTransactionStatus <span class="title">newTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionDefinition definition, <span class="meta">@Nullable</span> Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, <span class="meta">@Nullable</span> Object suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> actualNewSynchronization = newSynchronization &amp;&amp;</span><br><span class="line">            !TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultTransactionStatus(</span><br><span class="line">            transaction, newTransaction, actualNewSynchronization,</span><br><span class="line">            definition.isReadOnly(), debug, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>새롭게 트랜잭션을 시작하는 것이기 때문에 TransactionStatus를 만들 때 newTransaction을 true로 만든다.<br>그리고나서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L396">JpaTransactionManager의 doBegin 메서드</a>를 호출한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = (JpaTransactionObject) transaction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!txObject.hasEntityManagerHolder() ||</span><br><span class="line">                txObject.getEntityManagerHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">            EntityManager newEm = createEntityManagerForTransaction();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Opened new EntityManager [&quot;</span> + newEm + <span class="string">&quot;] for JPA transaction&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            txObject.setEntityManagerHolder(<span class="keyword">new</span> EntityManagerHolder(newEm), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Bind the entity manager holder to the thread.</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewEntityManagerHolder()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.bindResource(</span><br><span class="line">                    obtainEntityManagerFactory(), txObject.getEntityManagerHolder());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenEntityManagerInViewInterceptor에서 생성한 엔티티 매니저 홀더를 txObject에 초기화 했기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L480">createEntityManagerForTransaction 메서드</a>를 호출하지 않는다.<br>즉, 새로운 트랜잭션은 맞지만 entity manager는 새롭게 생성하지 않고 OpenEntityManagerInViewInterceptor에서 생성한 엔티티 매니저를 그대로 사용하는 걸 알 수 있다.</p><h3 id="엔티티-매니저-종료-1"><a href="#엔티티-매니저-종료-1" class="headerlink" title="엔티티 매니저 종료"></a>엔티티 매니저 종료</h3><p>다시 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L336">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>로 돌아오자.  </p><ol><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L407">TransactionAspectSupport의 invokeWithinTransaction 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L649">commitTransactionAfterReturning 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L654">commitTransactionAfterReturning 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L688">AbstractPlatformTransactionManager의 commit 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L711">AbstractPlatformTransactionManager의 commit 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L720">processCommit 메서드</a>를 호출하고 있다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L790">processCommit 메서드</a>에서 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L998">cleanupAfterCompletion 메서드</a>를 호출하고 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    status.setCompleted();</span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        TransactionSynchronizationManager.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.getSuspendedResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Resuming suspended transaction after completion of inner transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object transaction = (status.hasTransaction() ? status.getTransaction() : <span class="keyword">null</span>);</span><br><span class="line">        resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>OpenEntityManagerInViewInterceptor를 탔다고 하더라도 새로운 트랜잭션이 시작된 것이기 때문에 status.isNewTransaction()은 true이고 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L615">JpaTransactionManager의 doCleanupAfterCompletion 메서드</a>를 호출한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCleanupAfterCompletion</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">    JpaTransactionObject txObject = (JpaTransactionObject) transaction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the entity manager holder from the thread, if still there.</span></span><br><span class="line">    <span class="comment">// (Could have been removed by EntityManagerFactoryUtils in order</span></span><br><span class="line">    <span class="comment">// to replace it with an unsynchronized EntityManager).</span></span><br><span class="line">    <span class="keyword">if</span> (txObject.isNewEntityManagerHolder()) &#123;</span><br><span class="line">        TransactionSynchronizationManager.unbindResourceIfPossible(obtainEntityManagerFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Remove the entity manager holder from the thread.</span></span><br><span class="line">    <span class="keyword">if</span> (txObject.isNewEntityManagerHolder()) &#123;</span><br><span class="line">        EntityManager em = txObject.getEntityManagerHolder().getEntityManager();</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Closing JPA EntityManager [&quot;</span> + em + <span class="string">&quot;] after transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        EntityManagerFactoryUtils.closeEntityManager(em);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Not closing pre-bound JPA EntityManager after transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>엔티티 매니저 홀더는 새롭게 생성한 게 아니라 OpenEntityManagerInViewInterceptor에서 생성한 것이기 때문에 txObject.isNewEntityManagerHolder 메서드는 전부 false이다.<br>따라서 엔티티 매니저는 종료되지 않고 계속 살아있게 된다.</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;3줄-요약&quot;&gt;&lt;a href=&quot;#3줄-요약&quot; class=&quot;headerlink&quot; title=&quot;3줄 요약&quot;&gt;&lt;/a&gt;3줄 요약&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;OSIV가 꺼져있으면 트랜잭션이 시작될 때 엔티티 매니저가 생성되고, 트랜잭션이 끝날 때 엔티티 매니저를 종료한다.&lt;/li&gt;
&lt;li&gt;OSIV가 꺼져있고, 다른 트랜잭션이라면 엔티티 매니저가 공유되지 않기 때문에 엔티티 매니저의 1차 캐시도 서로 공유되지 않는다.&lt;/li&gt;
&lt;li&gt;OSIV가 켜져있으면 요청 당 엔티티 매니저는 한 번 생성되고, 뷰 렌더링이 끝날 때까지 엔티티 매니저는 종료되지 않고 트랜잭션이 다르더라도 1차 캐시가 공유된다. &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;엔티티 매니저 팩토리는 생성 비용이 비싸서 대부분 어플리케이션 당 하나를 생성하는 편이고, 엔티티 매니저는 생성 비용이 비싸지 않아서 어플리케이션에서 여러 번 생성된다.&lt;br&gt;하지만 엔티티 매니저는 쓰레드 세이프 하지 않기 때문에, 쓰레드 당 하나를 생성해야할 것 같고 Spring MVC는 리퀘스트 당 하나의 쓰레드가 할당되기 때문에 리퀘스트 당 하나의 엔티티 매니저가 생성될 것만 같은 기분이 든다.&lt;br&gt;나 또한 그렇게 알고 있었는데 아래 코드를 통해 뭔가 의문이 생겼다.&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeRepository&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;JpaRepository&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;SomeEntity, Long&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeService&lt;/span&gt;&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; repository: SomeRepository&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;some&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; someEntity = repository.findById(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; someEntity2 = repository.findById(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Back-end" scheme="https://perfectacle.github.io/categories/Back-end/"/>
    
    <category term="DB" scheme="https://perfectacle.github.io/categories/Back-end/DB/"/>
    
    <category term="JPA" scheme="https://perfectacle.github.io/categories/Back-end/DB/JPA/"/>
    
    
    <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>(JPA) Readonly 트랜잭션은 트랜잭션을 시작하지만 flush를 하지 않는다.</title>
    <link href="https://perfectacle.github.io/2021/05/05/readonly-transaction-begin-transaction/"/>
    <id>https://perfectacle.github.io/2021/05/05/readonly-transaction-begin-transaction/</id>
    <published>2021-05-05T08:46:16.000Z</published>
    <updated>2021-05-05T08:55:27.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3줄-요약"><a href="#3줄-요약" class="headerlink" title="3줄 요약"></a>3줄 요약</h1><ol><li>@Transaction(readOnly = true)로 설정해도 트랜잭션은 시작된다. (transaction isolation level 보장)</li><li>readOnly 트랜잭션도 시작한 트랜잭션을 종료시켜야하기 때문에 커밋도 한다.</li><li>readOnly 트랜잭션의 Hibernate Session의 FlushMode는 Manual로 강제하기 때문에 트랜잭션을 커밋하기 전에 flush를 하지 않는다. (readOnly 보장)</li></ol><h2 id="Transaction-readOnly-true-로-설정해도-트랜잭션은-시작된다"><a href="#Transaction-readOnly-true-로-설정해도-트랜잭션은-시작된다" class="headerlink" title="@Transaction(readOnly = true)로 설정해도 트랜잭션은 시작된다."></a>@Transaction(readOnly = true)로 설정해도 트랜잭션은 시작된다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeEntityRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Parent</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="function">List&lt;Parent&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> SomeService &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SomeEntityRepository repository;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(<span class="keyword">final</span> SomeEntityRepository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.findByName(<span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/readonly-transaction-begin-transaction/transaction-interceptor.png"><br>repository의 구현체는 프록시 객체로써 인터페이스이기 때문에 jdk dynamic 프록시 객체가 생성이 된다.<br>또한 TransactionInterceptor라는 Advisor를 가지고 있으며 </p><ol><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java#L119">TransactionInterceptor.invoke()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L382">TransactionAspectSupport.invokeWithinTransaction()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L595">TransactionAspectSupport.createTransactionIfNecessary()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L373">AbstractPlatformTransactionManager.getTransaction()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L400">AbstractPlatformTransactionManager.startTransaction()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L421">JpaTransactionManager.doBegin()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/vendor/HibernateJpaDialect.java#L164">HibernateJpaDialect.beginTransaction()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionImpl.java#L83">TransactionImpl.begin()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jdbc/internal/JdbcResourceLocalTransactionCoordinatorImpl.java#L246">JdbcResourceLocalTransactionCoordinatorImpl.TransactionDriverControlImpl.begin()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/resource/jdbc/internal/LogicalConnectionManagedImpl.java#L285">LogicalConnectionManagedImpl.begin()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/resource/jdbc/internal/AbstractLogicalConnectionImplementor.java#L68">AbstractLogicalConnectionImplementor.begin()</a></li></ol><p>위와 같은 메서드 호출을 통해서 실제로 트랜잭션을 시작하게 된다.</p><h2 id="Transaction-readOnly-true-에-의해-시작된-트랜잭션은-flush를-하지-않는다"><a href="#Transaction-readOnly-true-에-의해-시작된-트랜잭션은-flush를-하지-않는다" class="headerlink" title="@Transaction(readOnly = true)에 의해 시작된 트랜잭션은 flush를 하지 않는다."></a>@Transaction(readOnly = true)에 의해 시작된 트랜잭션은 flush를 하지 않는다.</h2><p><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/vendor/HibernateJpaDialect.java#L136">HibernateJpaDialect.beginTransaction()</a> 을 타고 보다보면 아래와 같은 흐름을 따라가게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">beginTransaction</span><span class="params">(EntityManager entityManager, TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> PersistenceException, SQLException, TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Session session = getSession(entityManager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">        session.getTransaction().setTimeout(definition.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);</span><br><span class="line">    Integer previousIsolationLevel = <span class="keyword">null</span>;</span><br><span class="line">    Connection preparedCon = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isolationLevelNeeded || definition.isReadOnly()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.prepareConnection) &#123;</span><br><span class="line">            preparedCon = HibernateConnectionHandle.doGetConnection(session);</span><br><span class="line">            previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(preparedCon, definition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isolationLevelNeeded) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidIsolationLevelException(getClass().getSimpleName() +</span><br><span class="line">                    <span class="string">&quot; does not support custom isolation levels since the &#x27;prepareConnection&#x27; flag is off.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Standard JPA transaction begin call for full JPA context setup...</span></span><br><span class="line">    entityManager.getTransaction().begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adapt flush mode and store previous isolation level, if any.</span></span><br><span class="line">    FlushMode previousFlushMode = prepareFlushMode(session, definition.isReadOnly());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> FlushMode <span class="title">prepareFlushMode</span><span class="params">(Session session, <span class="keyword">boolean</span> readOnly)</span> <span class="keyword">throws</span> PersistenceException </span>&#123;</span><br><span class="line">    FlushMode flushMode = (FlushMode) ReflectionUtils.invokeMethod(getFlushMode, session);</span><br><span class="line">    Assert.state(flushMode != <span class="keyword">null</span>, <span class="string">&quot;No FlushMode from Session&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readOnly) &#123;</span><br><span class="line">        <span class="comment">// We should suppress flushing for a read-only transaction.</span></span><br><span class="line">        <span class="keyword">if</span> (!flushMode.equals(FlushMode.MANUAL)) &#123;</span><br><span class="line">            session.setFlushMode(FlushMode.MANUAL);</span><br><span class="line">            <span class="keyword">return</span> flushMode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transaction의 설정이 readOnly = true라면 Hibernate Session의 FlushMode를 MANUAL(명시적으로 <a href="https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html#flush--">EntityManager.flush()</a> 메서드를 호출하기 전까지 flush 되지 않음)로 강제하고 있다.</p><p>그리고 나서 실질적인 로직이 끝난 이후에 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L380">TransactionAspectSupport.invokeWithinTransaction()</a> 메서드에서 아래와 같은 호출 흐름을 가진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">            <span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// target invocation exception</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">            <span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">            TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">            <span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>invocation.proceedWithInvocation()에 의해 트랜잭션 내부 로직을 호출한다.  </li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L654">TransactionAspectSupport.commitTransactionAfterReturning()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L711">AbstractPlatformTransactionManager.commit()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L743">AbstractPlatformTransactionManager.processCommit()</a></li><li><a href="https://github.com/spring-projects/spring-framework/blob/main/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L562">JpaTransactionManager.doCommit()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionImpl.java#L101">TransactionImpl.commit()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jdbc/internal/JdbcResourceLocalTransactionCoordinatorImpl.java#L281">JdbcResourceLocalTransactionCoordinatorImpl.TransactionDriverControlImpl.commit()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jdbc/internal/JdbcResourceLocalTransactionCoordinatorImpl.java#L183">JdbcResourceLocalTransactionCoordinatorImpl.beforeCompletionCallback()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcCoordinatorImpl.java#L448">JdbcCoordinatorImpl.beforeTransactionCompletion()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/internal/SessionImpl.java#L2409">SessionImpl.beforeTransactionCompletion()</a></li><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/internal/SessionImpl.java#L3268">SessionImpl.flushBeforeTransactionCompletion()</a></li></ol><p>SessionImpl.flushBeforeTransactionCompletion 코드를 보면 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBeforeTransactionCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> doFlush = isTransactionFlushable()</span><br><span class="line">            &amp;&amp; getHibernateFlushMode() != FlushMode.MANUAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( doFlush ) &#123;</span><br><span class="line">            managedFlush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionMapperStandardImpl.INSTANCE.mapManagedFlushFailure( <span class="string">&quot;error during managed flush&quot;</span>, re, <span class="keyword">this</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 readOnly이면 Hibernate Session의 Flush 모드를 MANUAL로 강제했기 때문에 getHibernateFlushMode()는 MANUAL이 나오기 때문에<br><code>getHibernateFlushMode() != FlushMode.MANUAL</code>는 false이기 때문에 doFlush는 false라서 managedFlush 메서드를 호출하지 않아서 실질적으로 flush가 호출되지 않는다.</p><h2 id="Transaction-readOnly-true-에-의해-시작된-트랜잭션도-종료를-해야하기-때문에-커밋을-한다"><a href="#Transaction-readOnly-true-에-의해-시작된-트랜잭션도-종료를-해야하기-때문에-커밋을-한다" class="headerlink" title="@Transaction(readOnly = true)에 의해 시작된 트랜잭션도 종료를 해야하기 때문에 커밋을 한다."></a>@Transaction(readOnly = true)에 의해 시작된 트랜잭션도 종료를 해야하기 때문에 커밋을 한다.</h2><p>flush는 하지 않았지만 트랜잭션을 시작했기 때문에 트랜잭션을 종료해야 정상적으로 커넥션을 반환하게 된다.<br>다시 <a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jdbc/internal/JdbcResourceLocalTransactionCoordinatorImpl.java#L282">JdbcResourceLocalTransactionCoordinatorImpl.TransactionDriverControlImpl.commit()</a> 로 돌아오면</p><ol><li><a href="https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/resource/jdbc/internal/AbstractLogicalConnectionImplementor.java#L86">AbstractLogicalConnectionImplementor.commit()</a></li><li><a href="https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java#L387">ProxyConnection.commit()</a></li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html#commit()">Connection.commit()</a></li></ol><p>위와 같은 메서드 호출을 통해 실제 DB 물리 커넥션에 commit을 날리기 때문에 위에서 시작한 트랜잭션을 종료하게 된다.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;3줄-요약&quot;&gt;&lt;a href=&quot;#3줄-요약&quot; class=&quot;headerlink&quot; title=&quot;3줄 요약&quot;&gt;&lt;/a&gt;3줄 요약&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;@Transaction(readOnly = true)로 설정해도 트랜잭션은 시작된다. (transaction isolation level 보장)&lt;/li&gt;
&lt;li&gt;readOnly 트랜잭션도 시작한 트랜잭션을 종료시켜야하기 때문에 커밋도 한다.&lt;/li&gt;
&lt;li&gt;readOnly 트랜잭션의 Hibernate Session의 FlushMode는 Manual로 강제하기 때문에 트랜잭션을 커밋하기 전에 flush를 하지 않는다. (readOnly 보장)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Transaction-readOnly-true-로-설정해도-트랜잭션은-시작된다&quot;&gt;&lt;a href=&quot;#Transaction-readOnly-true-로-설정해도-트랜잭션은-시작된다&quot; class=&quot;headerlink&quot; title=&quot;@Transaction(readOnly = true)로 설정해도 트랜잭션은 시작된다.&quot;&gt;&lt;/a&gt;@Transaction(readOnly = true)로 설정해도 트랜잭션은 시작된다.&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeEntityRepository&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;JpaRepository&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Long&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Transactional(readOnly = true)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;Parent&amp;gt; &lt;span class=&quot;title&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; SomeService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SomeEntityRepository repository;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeService&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SomeEntityRepository repository)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.repository = repository;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        repository.findByName(&lt;span class=&quot;string&quot;&gt;&amp;quot;qwer&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;/images/readonly-transaction-begin-transaction/transaction-interceptor.png&quot;&gt;&lt;br&gt;repository의 구현체는 프록시 객체로써 인터페이스이기 때문에 jdk dynamic 프록시 객체가 생성이 된다.&lt;br&gt;또한 TransactionInterceptor라는 Advisor를 가지고 있으며 &lt;/p&gt;</summary>
    
    
    
    <category term="Back-end" scheme="https://perfectacle.github.io/categories/Back-end/"/>
    
    <category term="DB" scheme="https://perfectacle.github.io/categories/Back-end/DB/"/>
    
    <category term="JPA" scheme="https://perfectacle.github.io/categories/Back-end/DB/JPA/"/>
    
    
    <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>Netty 이벤트 핸들러 실행 순서</title>
    <link href="https://perfectacle.github.io/2021/02/28/netty-event-handler-order/"/>
    <id>https://perfectacle.github.io/2021/02/28/netty-event-handler-order/</id>
    <published>2021-02-28T06:53:46.000Z</published>
    <updated>2021-02-28T06:54:56.984Z</updated>
    
    <content type="html"><![CDATA[<p>Netty를 사용하다보면 채널 파이프라인에 여러 이벤트 핸들러를 추가하기 마련이다.<br>그러다보니 순서가 중요할 때가 있다.  </p><ol><li>클라에서 보낸 데이터 중에 헤더를 파싱하고,  </li><li>헤더에 따라 바디를 파싱하고,</li><li>바디를 토대로 뭔가를 또 처리해야하고…</li></ol><p>이런 식으로 N 개의 이벤트 핸들러를 붙여야하고, 순서가 중요하다보니 어떤 순서대로 실행되는지가 궁금해졌다.  </p><h2 id="Inbound-Event-Handler"><a href="#Inbound-Event-Handler" class="headerlink" title="Inbound Event Handler"></a>Inbound Event Handler</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler1</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler2</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler3</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 채널 파이프라인에 순서대로 등록해주자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123;</span><br><span class="line">      ch.pipeline()</span><br><span class="line">        .addLast(ExampleHandler1())</span><br><span class="line">        .addLast(ExampleHandler2())</span><br><span class="line">        .addLast(ExampleHandler3())</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><img src="/images/netty-event-handler-order/inbound-event-handler-order.png" alt="Bottom-Up 순서대로 실행되기 때문에 때문에 먼저 등록한 ExampleHandler1부터 순서대로 실행된다."></p><h2 id="Outbound-Event-Handler"><a href="#Outbound-Event-Handler" class="headerlink" title="Outbound Event Handler"></a>Outbound Event Handler</h2><p>Outbound Event를 발생시키기 위해서는 Inbound Event Handler에서 Outbound Event를 한 번 발생시켜야하기 때문에 둘을 짬뽕시켜보았다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InboundHandler1</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        ctx.write(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutboundHandler2</span> : <span class="type">ChannelOutboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>, promise: <span class="type">ChannelPromise</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        ctx.write(msg, promise)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutboundHandler3</span> : <span class="type">ChannelOutboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>, promise: <span class="type">ChannelPromise</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        ctx.write(msg, promise)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 채널 파이프라인에 순서대로 등록해보았다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123;</span><br><span class="line">      ch.pipeline()</span><br><span class="line">        .addLast(InboundHandler1())</span><br><span class="line">        .addLast(OutboundHandler2())</span><br><span class="line">        .addLast(OutboundHandler3())</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 1만 출력되고, 2와 3은 출력되지 않았다.<br>답은 Outbound Event는 Top-down 순서로 실행되기 때문이다.<br><img src="/images/netty-event-handler-order/outbound-event-handler-order.png" alt="Top-down 순서대로 실행되기 때문에 Outbound Event가 발생한 InboundHandler 아래에 OutboundHandler가 없어서 이벤트를 처리하지 못했다."></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123;</span><br><span class="line">      ch.pipeline()</span><br><span class="line">        .addLast(OutboundHandler3())</span><br><span class="line">        .addLast(OutboundHandler2())</span><br><span class="line">        .addLast(InboundHandler1())</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/netty-event-handler-order/outbound-event-handler-order-2.png" alt="Top-down 순서대로 실행되기 때문에 Outbound Event가 발생한 InboundHandler 아래에 OutboundHandler들이 등록된 순서 역순으로 실행된다."><br>OutboundHandler2, OutboundHandler3 순서대로 실행돼서 1이 찍힌 후에 2와 3이 찍힌다.</p><h2 id="Duplex-Event-Handler"><a href="#Duplex-Event-Handler" class="headerlink" title="Duplex Event Handler"></a>Duplex Event Handler</h2><p>Inbound/Outbound Event를 모두 핸들링하는 Duplex Event Handler를 추가해서 실행 순서를 살펴보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InboundHandler1</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        ctx.write(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutboundHandler2</span> : <span class="type">ChannelOutboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>, promise: <span class="type">ChannelPromise</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        ctx.write(msg, promise)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplexHandler3</span> : <span class="type">ChannelDuplexHandler</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;3 - read&quot;</span>)</span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>, promise: <span class="type">ChannelPromise</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;3 - write&quot;</span>)</span><br><span class="line">        ctx.write(msg, promise)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutboundHandler4</span> : <span class="type">ChannelOutboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>, promise: <span class="type">ChannelPromise</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">        ctx.write(msg, promise)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>채널 파이프라인에 추가해주자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123;</span><br><span class="line">      ch.pipeline()</span><br><span class="line">        .addLast(OutboundHandler4())</span><br><span class="line">        .addLast(DuplexHandler3())</span><br><span class="line">        .addLast(OutboundHandler2())</span><br><span class="line">        .addLast(InboundHandler1())</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/netty-event-handler-order/duplex-event-handler-order.png"><br>Inbound Handler는 Bottom-up 순서대로 실행되기 때문에</p><ol><li>먼저 등록된 DuplexHandler3의 <code>3 - read</code> 출력</li><li>그 후 등록된 InboundHandler1의 <code>1</code> 출력</li></ol><p>Outbound Handler는 Top-down 순서대로 실행되기 때문에</p><ol><li>OutboundHandler2의 <code>2</code> 출력</li><li>DuplexHandler3의 <code>3 - write</code> 출력</li><li>OutboundHandler4의 <code>4</code> 출력</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty를 사용하다보면 채널 파이프라인에 여러 이벤트 핸들러를 추가하기 마련이다.&lt;br&gt;그러다보니 순서가 중요할 때가 있다.  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라에서 보낸 데이터 중에 헤더를 파싱하고,  &lt;/li&gt;
&lt;li&gt;헤더에 따라 바디를 파싱하고,&lt;/li&gt;
&lt;li&gt;바디를 토대로 뭔가를 또 처리해야하고…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이런 식으로 N 개의 이벤트 핸들러를 붙여야하고, 순서가 중요하다보니 어떤 순서대로 실행되는지가 궁금해졌다.  &lt;/p&gt;
&lt;h2 id=&quot;Inbound-Event-Handler&quot;&gt;&lt;a href=&quot;#Inbound-Event-Handler&quot; class=&quot;headerlink&quot; title=&quot;Inbound Event Handler&quot;&gt;&lt;/a&gt;Inbound Event Handler&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExampleHandler1&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;ChannelInboundHandlerAdapter&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;channelRead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ctx: &lt;span class=&quot;type&quot;&gt;ChannelHandlerContext&lt;/span&gt;, msg: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ctx.fireChannelRead(msg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExampleHandler2&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;ChannelInboundHandlerAdapter&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;channelRead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ctx: &lt;span class=&quot;type&quot;&gt;ChannelHandlerContext&lt;/span&gt;, msg: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ctx.fireChannelRead(msg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExampleHandler3&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;ChannelInboundHandlerAdapter&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;channelRead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ctx: &lt;span class=&quot;type&quot;&gt;ChannelHandlerContext&lt;/span&gt;, msg: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ctx.fireChannelRead(msg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/categories/Note/Netty/"/>
    
    
    <category term="TCP" scheme="https://perfectacle.github.io/tags/TCP/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty ByteBuf</title>
    <link href="https://perfectacle.github.io/2021/02/28/netty-byte-buf/"/>
    <id>https://perfectacle.github.io/2021/02/28/netty-byte-buf/</id>
    <published>2021-02-28T05:34:23.000Z</published>
    <updated>2021-02-28T05:34:23.038Z</updated>
    
    <content type="html"><![CDATA[<p>Netty는 왜 자바 표준인 NIO의 <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html">ByteBuffer</a>를 사용하지 않는 걸까 이유를 몰랐는데 <a href="https://www.hanbit.co.kr/media/books/book_view.html?p_code=B2683487348">자바 네트워크 소녀 네티</a>를 보고 이유를 알게되어 정리해봄.<br>ByteBuffer와 ByteBuf의 세부사항 보다는 ByteBuffer는 어떤 문제점을 가지고 있고, ByteBuf는 그 문제점을 어떻게 해결했는지에 초점을 맞추어 정리함.</p><h2 id="ByteBuffer의-문제점"><a href="#ByteBuffer의-문제점" class="headerlink" title="ByteBuffer의 문제점"></a>ByteBuffer의 문제점</h2><p>Netty의 <a href="https://netty.io/4.1/api/io/netty/buffer/ByteBuf.html">ByteBuf</a>는 자바의 ByteBuffer가 가진 문제점들을 해결하기 위해 나왔다.</p><h3 id="데이터-쓰기-읽기-인덱스가-분리돼있지-않다"><a href="#데이터-쓰기-읽기-인덱스가-분리돼있지-않다" class="headerlink" title="데이터 쓰기/읽기 인덱스가 분리돼있지 않다"></a>데이터 쓰기/읽기 인덱스가 분리돼있지 않다</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteBuffer = ByteBuffer.allocate(<span class="number">3</span>) <span class="comment">// 3바이트를 담을 수 있는 힙버퍼, 전부 0으로 초기화된다.</span></span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]</span></span><br><span class="line"></span><br><span class="line">byteBuffer.put(<span class="number">1</span>)</span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]</span></span><br><span class="line"></span><br><span class="line">println(byteBuffer.<span class="keyword">get</span>()) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>3byte를 담을 수 있는 버퍼를 만들고, 첫 번째 버퍼에 1이라는 바이트를 넣었다.<br>그리고나서 읽으려고 하는데 0이 나왔다.<br>이유는 쓰기 인덱스와 읽기 인덱스를 pos라는 하나의 변수로 관리하고 있기 때문이다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteBuffer = ByteBuffer.allocate(<span class="number">3</span>)</span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]</span></span><br><span class="line"></span><br><span class="line">byteBuffer.put(<span class="number">1</span>)</span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]</span></span><br><span class="line"></span><br><span class="line">byteBuffer.flip() <span class="comment">// 읽기 모드로 변경</span></span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=0 lim=1 cap=3]</span></span><br><span class="line">println(byteBuffer.<span class="keyword">get</span>()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>데이터를 쓰다가 읽으려면 flip을 써서 읽기 모드로 변경해서 pos를 0으로 초기화하고 lim을 현재 포지션인 1로 바꾼다.<br>왜냐하면 데이터를 1byte 밖에 안 썼기 때문에 1 byte 밖에 못 읽기 때문이다.<br>그럼 정말 flip은 읽기/쓰기 모드 변환으로 생각해도 되는 걸까?</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteBuffer = ByteBuffer.allocate(<span class="number">3</span>)</span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]</span></span><br><span class="line"></span><br><span class="line">byteBuffer.put(<span class="number">1</span>)</span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]</span></span><br><span class="line"></span><br><span class="line">byteBuffer.flip() <span class="comment">// 읽기 모드로 변경</span></span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=0 lim=1 cap=3]</span></span><br><span class="line">println(byteBuffer.<span class="keyword">get</span>()) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">byteBuffer.flip() <span class="comment">// 쓰기 모드로 변경</span></span><br><span class="line">println(byteBuffer) <span class="comment">// java.nio.HeapByteBuffer[pos=0 lim=1 cap=3]</span></span><br></pre></td></tr></table></figure><p>나는 읽기 모드에서 다시 flip을 하면 lim은 3으로 늘어나고 pos는 다시 1으로 원복될 줄 알았는데 그게 아니었다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flips this buffer.  The limit is set to the current position and then</span></span><br><span class="line"><span class="comment"> * the position is set to zero.  If the mark is defined then it is</span></span><br><span class="line"><span class="comment"> * discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke</span></span><br><span class="line"><span class="comment"> * this method to prepare for a sequence of channel-write or relative</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;get&lt;/i&gt; operations.  For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * buf.put(magic);    // Prepend header</span></span><br><span class="line"><span class="comment"> * in.read(buf);      // Read data into rest of buffer</span></span><br><span class="line"><span class="comment"> * buf.flip();        // Flip buffer</span></span><br><span class="line"><span class="comment"> * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method is often used in conjunction with the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span></span><br><span class="line"><span class="comment"> * one place to another.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>읽기/쓰기 모드가 아니라 그냥 버퍼를 flip하는 거라고 한다. (flip이 뒤집다라는 뜻인데 limit을 현재 포지션으로 뒤집는다는 뜻으로 쓰인 건지는 잘 모르겠다.)<br>limit을 바꾸지 않고 position만 바꾸고 싶다면 <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#rewind()">rewind() 메서드</a>를 사용하거나 <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#position(int)">position(int newPosition) 메서드</a>를 사용해야한다.  </p><h3 id="버퍼의-사이즈가-고정적이다"><a href="#버퍼의-사이즈가-고정적이다" class="headerlink" title="버퍼의 사이즈가 고정적이다"></a>버퍼의 사이즈가 고정적이다</h3><p>limit이나 capacity를 넘어서면 버퍼의 사이즈가 늘어나는 게 아니라 BufferOverflowException 예외를 던진다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteBuffer = ByteBuffer.allocate(<span class="number">3</span>) <span class="comment">// pos: 0, lim: 3, cap: 3</span></span><br><span class="line">byteBuffer.put(<span class="number">1</span>) <span class="comment">// pos: 1, lim: 3, cap: 3</span></span><br><span class="line">byteBuffer.put(<span class="number">1</span>) <span class="comment">// pos: 2, lim: 3, cap: 3</span></span><br><span class="line">byteBuffer.put(<span class="number">1</span>) <span class="comment">// pos: 3, lim: 3, cap: 3</span></span><br><span class="line">assertThrows&lt;BufferOverflowException&gt; &#123; byteBuffer.put(<span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> byteBuffer2 = ByteBuffer.allocate(<span class="number">3</span>) <span class="comment">// pos: 0, lim: 3, cap: 3</span></span><br><span class="line">byteBuffer2.put(<span class="number">1</span>) <span class="comment">// pos: 1, lim: 3, cap: 3</span></span><br><span class="line">byteBuffer2.flip() <span class="comment">// pos: 0, lim: 1, cap: 3</span></span><br><span class="line">byteBuffer2.put(<span class="number">1</span>) <span class="comment">// pos: 1, lim: 1, cap: 3</span></span><br><span class="line">assertThrows&lt;BufferOverflowException&gt; &#123; byteBuffer2.put(<span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="버퍼풀이-존재하지-않는다"><a href="#버퍼풀이-존재하지-않는다" class="headerlink" title="버퍼풀이 존재하지 않는다."></a>버퍼풀이 존재하지 않는다.</h3><p>버퍼풀이 존재하지 않기 때문에 버퍼의 생성 및 메모리 해제 작업이 빈번하여 GC도 자주 유발하게 된다.<br>이런 단점을 보완하려면 객체 풀링을 제공하는 써드파티 라이브러리를 사용하여야한다.</p><h2 id="네티의-ByteBuf"><a href="#네티의-ByteBuf" class="headerlink" title="네티의 ByteBuf"></a>네티의 ByteBuf</h2><p>네티의 ByteBuf는 위의 문제점들 외에 기타 장점들까지 가지고 있기 때문에 고성능에 유지보수하기 쉬운 코드를 지향한다.<br>또한 네티를 쓰지 않더라도 <a href="https://mvnrepository.com/artifact/io.netty/netty-buffer">netty-buffer</a>를 의존성에 추가하고 ByteBuf만 사용하는 것도 가능하다.</p><h3 id="읽기-쓰기-인덱스의-분리"><a href="#읽기-쓰기-인덱스의-분리" class="headerlink" title="읽기/쓰기 인덱스의 분리"></a>읽기/쓰기 인덱스의 분리</h3><p>ByteBuffer에서는 pos라는 인덱스로 읽기/쓰기 인덱스를 공유하여 데이터를 쓰다가 읽으려면 flip, rewind, poistion 메서드를 통해 pos를 변경해주어야만 했다.<br>그리고 flip은 개발자의 혼란을 초래하는 동작방식 때문에 버그를 유발하기도 쉽다. </p><p>ByteBuf는 이런 단점을 보완하고자 읽기/쓰기 인덱스를 분리하였다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteBuf = Unpooled.buffer(<span class="number">3</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 0, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">0</span> <span class="comment">// widx(0) - ridx(0) = 0</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">3</span> <span class="comment">// cap(3) - widx(0) = 3</span></span><br><span class="line"></span><br><span class="line">byteBuf.writeByte(<span class="number">1</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 1, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">1</span> <span class="comment">// widx(1) - ridx(0) = 1</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">2</span> <span class="comment">// cap(3) - widx(1) = 2</span></span><br><span class="line"></span><br><span class="line">byteBuf.readByte() shouldBe <span class="number">1</span></span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 1, widx: 1, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">0</span> <span class="comment">// widx(1) - ridx(1) = 0</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">2</span> <span class="comment">// cap(3) - widx(1) = 2</span></span><br></pre></td></tr></table></figure><h3 id="버퍼의-사이즈가-가변적이다"><a href="#버퍼의-사이즈가-가변적이다" class="headerlink" title="버퍼의 사이즈가 가변적이다."></a>버퍼의 사이즈가 가변적이다.</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteBuf = Unpooled.buffer(<span class="number">3</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 0, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">0</span> <span class="comment">// widx(0) - ridx(0) = 0</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">3</span> <span class="comment">// cap(3) - widx(0) = 3</span></span><br><span class="line"></span><br><span class="line">byteBuf.writeByte(<span class="number">1</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 1, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">1</span> <span class="comment">// widx(1) - ridx(0) = 1</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">2</span> <span class="comment">// cap(3) - widx(1) = 2</span></span><br><span class="line"></span><br><span class="line">byteBuf.writeByte(<span class="number">1</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 2, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">2</span> <span class="comment">// widx(2) - ridx(0) = 2</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">1</span> <span class="comment">// cap(3) - widx(2) = 1</span></span><br><span class="line"></span><br><span class="line">byteBuf.writeByte(<span class="number">1</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 3, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">3</span> <span class="comment">// widx(3) - ridx(0) = 3</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">0</span> <span class="comment">// cap(3) - widx(3) = 0</span></span><br><span class="line"></span><br><span class="line">byteBuf.writeByte(<span class="number">1</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 4, cap: 64, 버퍼의 사이즈가 가변적으로 늘어났다.</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">4</span> <span class="comment">// widx(4) - ridx(0) = 3</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">60</span> <span class="comment">// cap(64) - widx(4) = 60</span></span><br></pre></td></tr></table></figure><p>widx가 cap를 넘어가는 순간 버퍼의 사이즈가 늘어난다.<br>또한 capacity 메서드를 사용하면 명시적인 버퍼의 사이즈를 지정할 수 있다. (기존 capcity보다 작아지면 기존 데이터는 잘릴 수 있다.)<br>당연한 얘기지만 ridx가 widx를 벗어나면 예외를 던지는 건 똑같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteBuf = Unpooled.buffer(<span class="number">3</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 0, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">0</span> <span class="comment">// widx(0) - ridx(0) = 0</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">3</span> <span class="comment">// cap(3) - widx(0) = 3</span></span><br><span class="line"></span><br><span class="line">byteBuf.writeByte(<span class="number">1</span>)</span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 0, widx: 1, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">1</span> <span class="comment">// widx(1) - ridx(0) = 1</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">2</span> <span class="comment">// cap(3) - widx(1) = 2</span></span><br><span class="line"></span><br><span class="line">byteBuf.readByte() shouldBe <span class="number">1</span></span><br><span class="line">println(byteBuf) <span class="comment">// ridx: 1, widx: 1, cap: 3</span></span><br><span class="line">byteBuf.readableBytes() shouldBe <span class="number">0</span> <span class="comment">// widx(1) - ridx(1) = 0</span></span><br><span class="line">byteBuf.writableBytes() shouldBe <span class="number">2</span> <span class="comment">// cap(3) - widx(1) = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> indexOutOfBoundsException = assertThrows&lt;IndexOutOfBoundsException&gt; &#123; byteBuf.readByte() &#125;</span><br><span class="line">indexOutOfBoundsException.printStackTrace()</span><br><span class="line"><span class="comment">// java.lang.IndexOutOfBoundsException: readerIndex(1) + length(1) exceeds writerIndex(1): UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: 1, widx: 1, cap: 3)</span></span><br><span class="line"><span class="comment">//     at io.netty.buffer.AbstractByteBuf.checkReadableBytes0(AbstractByteBuf.java:1478)</span></span><br><span class="line"><span class="comment">//     at io.netty.buffer.AbstractByteBuf.readByte(AbstractByteBuf.java:732)</span></span><br><span class="line"><span class="comment">//     ...</span></span><br></pre></td></tr></table></figure><h3 id="버퍼풀을-지원한다"><a href="#버퍼풀을-지원한다" class="headerlink" title="버퍼풀을 지원한다"></a>버퍼풀을 지원한다</h3><p>풀을 사용하는 이유는 자원을 재활용하기 위함이다.<br>그럼 버퍼를 왜 재사용할까? 바로 버퍼를 빈번히 메모리에 할당/해제 함으로써 발생하는 GC 횟수를 줄이기 위함이다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 버퍼풀을 사용하지 않는다.</span></span><br><span class="line">Unpooled.buffer()</span><br><span class="line">Unpooled.directBuffer() <span class="comment">// direct가 붙은 놈은 힙메모리가 아닌 OS의 커널 영역에 바이트 버퍼를 생성함, 생성 시간은 좀 더 걸리지만 읽기/쓰기 성능이 더 좋다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 버퍼풀을 사용한다.</span></span><br><span class="line">ByteBufAllocator.DEFAULT.heapBuffer()</span><br><span class="line">ByteBufAllocator.DEFAULT.directBuffer()</span><br></pre></td></tr></table></figure><h4 id="Reference-counted-objects"><a href="#Reference-counted-objects" class="headerlink" title="Reference counted objects"></a><a href="https://netty.io/wiki/reference-counted-objects.html">Reference counted objects</a></h4><p>Netty 4 버전 이후로 객체(버퍼)의 라이프사이클은 레퍼런스 카운트에 의해 관리되고 있다.<br>만약 어플리케이션에서 더이상 해당 버퍼를 참조하지 않아도, 풀에 반납하지 않는다면 GC가 돌아도 해당 버퍼는 계속 메모리 상에 남아 메모리 누수를 유발한다.   </p><p>버퍼를 풀에 반납하는 방법은 두 가지가 있다.<br>(아래 나오는 예제는 예시일 뿐이지, channelRead 메서드에서만 반납해야한다거나 그런 규칙은 없다.)</p><h5 id="채널에-버퍼를-기록한다"><a href="#채널에-버퍼를-기록한다" class="headerlink" title="채널에 버퍼를 기록한다."></a>채널에 버퍼를 기록한다.</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        ctx.write(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="명시적으로-반환한다"><a href="#명시적으로-반환한다" class="headerlink" title="명시적으로 반환한다."></a>명시적으로 반환한다.</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg !<span class="keyword">is</span> ByteBuf) <span class="keyword">return</span></span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        ReferenceCountUtil.retain(msg)</span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        ReferenceCountUtil.release(msg)</span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        ReferenceCountUtil.release(msg) <span class="comment">// 레퍼런스 카운트가 0이 되면서 풀에 반납됨.</span></span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 풀에 반납된 객체를 사용하려고 하면 IllegalReferenceCountException 예외를 던진다.</span></span><br><span class="line">        ReferenceCountUtil.release(msg)</span><br><span class="line">        <span class="comment">// io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1</span></span><br><span class="line">        <span class="comment">//    at io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:74)</span></span><br><span class="line">        <span class="comment">//    at io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:138)</span></span><br><span class="line">        <span class="comment">//    at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:100)</span></span><br><span class="line">        <span class="comment">//    at io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:88)</span></span><br><span class="line">        <span class="comment">//    ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="반납-의무를-다음-이벤트-핸들러에게-미루기"><a href="#반납-의무를-다음-이벤트-핸들러에게-미루기" class="headerlink" title="반납 의무를 다음 이벤트 핸들러에게 미루기"></a>반납 의무를 다음 이벤트 핸들러에게 미루기</h5><p>바이트버퍼를 다음 이벤트 핸들러에게 넘기지 않을 때는 해당 이벤트 핸들러에서 반납을 해야하지만, 만약 다음 이벤트 핸들러에게 넘긴다면 반납해서는 안 된다.<br>왜냐하면 IllegalReferenceCountException이 발생하기 때문이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg !<span class="keyword">is</span> ByteBuf) <span class="keyword">return</span></span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        ReferenceCountUtil.retain(msg)</span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        ReferenceCountUtil.release(msg)</span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        ReferenceCountUtil.release(msg) <span class="comment">// 레퍼런스 카운트가 0이 되면서 풀에 반납됨.</span></span><br><span class="line">        println(msg.refCnt()) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 이벤트 핸들러 이후 바이트 버퍼를 사용하는 핸들러에서 io.netty.util.IllegalReferenceCountException 예외가 발생한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        ctx.write(msg)</span><br><span class="line"></span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마찬가지로 채널에 버퍼를 기록하는 경우도 풀에 반납하기 때문에 io.netty.util.IllegalReferenceCountException 예외가 발생한다.</p><p>따라서 반납하지 않고 바이트버퍼를 사용만 하고 그대로 넘겨주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 바이트 버퍼 잘 사용하고 반납은 하지 않기</span></span><br><span class="line"></span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 뒤에 이벤트 핸들러로 넘겨줄 때도 ridx, widx, capacity는 공유된다.<br>동일한 채널에 동일한 이벤트 핸들러를 두 번 등록해보면 ridx가 바뀌는 걸 볼 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 첫 번째 - ridx: 0, widx: 1000, cap: 2048</span></span><br><span class="line">        <span class="comment">// 두 번째 - ridx: 1, widx: 1000, cap: 2048</span></span><br><span class="line">        println(msg)</span><br><span class="line">        (msg <span class="keyword">as</span>? ByteBuf)?.readByte()</span><br><span class="line"></span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>따라서 뒤의 이벤트 핸들러에 영향을 주지 않으려면 ByteBuf를 카피한 후에 카피한 ByteBuf를 사용한 후에 원본 ByteBuf를 다음 이벤트로 넘겨줘야한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(msg) <span class="comment">// 매번 고정적으로 ridx: 0, widx: 1000, cap: 2048</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">is</span> ByteBuf) &#123;</span><br><span class="line">            <span class="keyword">val</span> copiedByteBuf = msg.copy()</span><br><span class="line">            copiedByteBuf.readByte()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.fireChannelRead(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="버퍼풀-반납하기"><a href="#버퍼풀-반납하기" class="headerlink" title="버퍼풀 반납하기"></a>버퍼풀 반납하기</h5><p><strong>후속 이벤트 핸들러에게 바이트 버퍼를 넘기지 않는한</strong> 해당 이벤트 핸들러에서 버퍼풀에 반납하지 않으면 메모리 누수가 발생한다.<br>따라서 채널에 기록하던, 반환하던 무조건 풀에 반납하지 않으면 안 된다. (트래픽이 적으면 서서히 메모리 누수가 발생하겠지만 트래픽이 많다면…)  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.safeRelease(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try로 묶지 않으면 예외 발생 시 메모리 누수가 발생할 수 있으므로 꼭 try로 묶은 후 finally에서 처리하도록 하자.<br>그리고 try에서 혹시나 반납을 이미 해버렸고, 반납된 이후에 예외가 터지거나 할 수 있기 때문에 safeRelease(이미 반납됐어도 예외를 던지지 않음) 메서드를 사용하자.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty는 왜 자바 표준인 NIO의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html&quot;&gt;ByteBuffer&lt;/a&gt;를 사용하지 않는 걸까 이유를 몰랐는데 &lt;a href=&quot;https://www.hanbit.co.kr/media/books/book_view.html?p_code=B2683487348&quot;&gt;자바 네트워크 소녀 네티&lt;/a&gt;를 보고 이유를 알게되어 정리해봄.&lt;br&gt;ByteBuffer와 ByteBuf의 세부사항 보다는 ByteBuffer는 어떤 문제점을 가지고 있고, ByteBuf는 그 문제점을 어떻게 해결했는지에 초점을 맞추어 정리함.&lt;/p&gt;
&lt;h2 id=&quot;ByteBuffer의-문제점&quot;&gt;&lt;a href=&quot;#ByteBuffer의-문제점&quot; class=&quot;headerlink&quot; title=&quot;ByteBuffer의 문제점&quot;&gt;&lt;/a&gt;ByteBuffer의 문제점&lt;/h2&gt;&lt;p&gt;Netty의 &lt;a href=&quot;https://netty.io/4.1/api/io/netty/buffer/ByteBuf.html&quot;&gt;ByteBuf&lt;/a&gt;는 자바의 ByteBuffer가 가진 문제점들을 해결하기 위해 나왔다.&lt;/p&gt;
&lt;h3 id=&quot;데이터-쓰기-읽기-인덱스가-분리돼있지-않다&quot;&gt;&lt;a href=&quot;#데이터-쓰기-읽기-인덱스가-분리돼있지-않다&quot; class=&quot;headerlink&quot; title=&quot;데이터 쓰기/읽기 인덱스가 분리돼있지 않다&quot;&gt;&lt;/a&gt;데이터 쓰기/읽기 인덱스가 분리돼있지 않다&lt;/h3&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; byteBuffer = ByteBuffer.allocate(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 3바이트를 담을 수 있는 힙버퍼, 전부 0으로 초기화된다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(byteBuffer) &lt;span class=&quot;comment&quot;&gt;// java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;byteBuffer.put(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(byteBuffer) &lt;span class=&quot;comment&quot;&gt;// java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(byteBuffer.&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;()) &lt;span class=&quot;comment&quot;&gt;// 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/categories/Note/Netty/"/>
    
    
    <category term="TCP" scheme="https://perfectacle.github.io/tags/TCP/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty 이벤트 루프</title>
    <link href="https://perfectacle.github.io/2021/02/28/netty-event-loop/"/>
    <id>https://perfectacle.github.io/2021/02/28/netty-event-loop/</id>
    <published>2021-02-27T16:32:12.000Z</published>
    <updated>2021-02-27T16:32:12.423Z</updated>
    
    <content type="html"><![CDATA[<p>이벤트 루프의 개념이 명확하지 않아 <a href="https://www.hanbit.co.kr/media/books/book_view.html?p_code=B2683487348">자바 네트워크 소녀 네티</a>를 보고 정리해봄.</p><p>통상적으로 이벤트 기반 어플리케이션이 이벤트를 처리하는 방식은 아래 두 가지가 존재한다고 함.</p><h2 id="이벤트-리스너와-이벤트-처리-쓰레드-방식"><a href="#이벤트-리스너와-이벤트-처리-쓰레드-방식" class="headerlink" title="이벤트 리스너와 이벤트 처리 쓰레드 방식"></a>이벤트 리스너와 이벤트 처리 쓰레드 방식</h2><p>브라우저에서 DOM에 클릭 이벤트를 어떻게 핸들링하는지 생각해보면 된다.  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>).onclick = <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.dir(e) </span><br></pre></td></tr></table></figure><p>이벤트를 처리하는 로직을 가진 메서드(<code>e =&gt; console.dir(e)</code>)를 대상 객체(<code>document.querySelector(&#39;body&#39;)</code>)의 이벤트 리스너(<code>onclick</code>)에 등록하고,<br>객체에 이벤트(click)가 발생했을 때 이벤트 처리 쓰레드에서 등록된 메서드를 수행하는 방식.</p><p>이런 처리 방식은 대부분 단일 쓰레드에서 이벤트를 처리한다. (js도 그래서 이벤트 리스너에서 병목이 발생하면 거의 stop the world에 걸린다고 보면 됨.)</p><h2 id="이벤트-큐에-이벤트를-등록하고-이벤트-루프가-이벤트-큐에-접근하여-처리하는-방식"><a href="#이벤트-큐에-이벤트를-등록하고-이벤트-루프가-이벤트-큐에-접근하여-처리하는-방식" class="headerlink" title="이벤트 큐에 이벤트를 등록하고 이벤트 루프가 이벤트 큐에 접근하여 처리하는 방식"></a>이벤트 큐에 이벤트를 등록하고 이벤트 루프가 이벤트 큐에 접근하여 처리하는 방식</h2><p><img src="/images/netty-event-loop/event-loop.png" alt="책에 나온 이벤트 루프 간단 도식화"><br>이벤트 루프는 쉽게 말해서 이벤트를 실행하기 위한 무한루프 스레드를 말한다. (이벤트가 올 때까지 해당 쓰레드가 block이 걸릴 수도 있고, 안 걸릴 수도 있고…)<br>이벤트 루프 쓰레드는 무한 루프를 돌면서 이벤트 큐에 이벤트가 있나 없나? 계속 감시를 하고 이벤트가 존재하면 큐에서 꺼내서 이벤트를 처리한다.</p><h3 id="단일-쓰레드와-다중-쓰레드-이벤트-루프"><a href="#단일-쓰레드와-다중-쓰레드-이벤트-루프" class="headerlink" title="단일 쓰레드와 다중 쓰레드 이벤트 루프"></a>단일 쓰레드와 다중 쓰레드 이벤트 루프</h3><h4 id="단일-쓰레드-이벤트-루프"><a href="#단일-쓰레드-이벤트-루프" class="headerlink" title="단일 쓰레드 이벤트 루프"></a>단일 쓰레드 이벤트 루프</h4><p><img src="/images/netty-event-loop/event-loop-node-js.png" alt="Node.js에서 이벤트 루프">  </p><p>Node.js와 같이 단일 쓰레드에서 이벤트 루프를 처리하게 되면 이벤트의 처리 순서를 보장할 수 있는 장점이 존재한다.<br>하지만 이벤트 처리 도중 병목이 걸리면 뒤에 있는 이벤트들도 전부 지연된다는 단점이 존재한다.<br>이런 단점을 극복하고자 노드에서는 CPU 코어 갯수만큼 프로세스를 띄우기도 한다.</p><h4 id="다중-쓰레드-이벤트-루프"><a href="#다중-쓰레드-이벤트-루프" class="headerlink" title="다중 쓰레드 이벤트 루프"></a>다중 쓰레드 이벤트 루프</h4><p><img src="/images/netty-event-loop/multithread-event-loop.png" alt="책에 나온 다중 쓰레드 이벤트 루프 간단 도식화"><br>다중 쓰레드 이벤트 루프는 여러 쓰레드에서 이벤트 루프를 처리하기 때문에 단일 쓰레드보다 더 효율적으로 이벤트를 처리할 수 있다는 장점이 존재한다.<br>하지만 하나의 자원(이벤트 큐)에 대해 여러 쓰레드에서 경합을 하기 때문에 다른 쓰레드에서 대기하는 시간이 발생할 수 있다.<br>또한 CPU 코어는 동시에 하나의 쓰레드만 실행할 수 있으므로 쓰레드가 CPU 코어 갯수를 초과하는 경우 아래와 같은 컨텍스트 스위칭 비용이 발생한다.  </p><ol><li>운영체제는 현재 쓰레드 상태가 대기(Waiting), 슬립(Sleep), 지연(Blocked)인 쓰레드 중 하나를 선택하여 실행(Run) 상태로 바꾼다.  </li><li>이 때 쓰레드가 가진 스택 정보를 현재 코어의 레지스터로 복사(컨텍스트 스위칭)한다.</li></ol><p>그리고 여러 쓰레드에서 하나의 이벤트 큐에 접근하므로 이벤트 처리에 대한 순서를 보장할 수 없다.</p><ol><li>이벤트 큐는 하나, 이벤트 루프 쓰레드는 2개라고 가정.</li><li>이벤트 큐에 E1, E2, E3가 쌓여있음.</li><li>이벤트 루프 쓰레드 1에서 E1 처리 시작</li><li>이벤트 루프 쓰레드 2에서 E2 처리 시작</li><li>이벤트 루프 쓰레드 2에서 E2 처리 끝</li><li>이벤트 루프 쓰레드 2에서 E3 처리 시작</li><li>이벤트 루프 쓰레드 2에서 E3 처리 끝</li><li>이벤트 루프 쓰레드 1에서 E1 처리 끝</li></ol><p>이벤트 처리 시작에 대한 순서는 보장할 수 있어도 순서가 상관있는 이벤트를 순차적으로 시작하고 끝내는 걸 할 수가 없다.<br>만약 파일에서 InputStream을 열어 데이터를 읽어서(E1), 버퍼에 기록하고(E2), 스트림을 닫는다(E3)라고 하면 순서가 보장되지 않으면 데이터를 다 읽기도 전에 스트림이 닫혀버릴 수도 있다.<br>이렇게 다중 쓰레드 이벤트 루프를 사용할 때는 순서를 보장하지 않아도 되는 이벤트에 대해서만 처리 로직을 작성하여야한다. </p><p><img src="/images/netty-event-loop/event-loop-netty.png" alt="책에 나온 네티의 다중 쓰레드 이벤트 루프 간단 도식화"><br>네티는 이런 단점을 보완하고자 이벤트 루프 쓰레드마다 이벤트 큐를 가지도록 하였다.<br>이렇게 되면 여러 쓰레드가 하나의 자원(이벤트 큐)을 사용하고자 서로 경합을 벌이지 않아도 된다.<br>그리고 이벤트 루프 쓰레드에 채널이 등록되고, 해당 채널에서 이벤트를 발생시키기 때문에 독립적인 이벤트 큐에 대해 하나의 이벤트 루프 쓰레드만 처리를 진행하므로 순서도 보장할 수 있다.<br>그리고 Netty의 NioEventLoopGroup은 CPU 코어 갯수 * 2개의 이벤트 루프 쓰레드를 만들어서 컨텍스트 스위칭 비용도 최소화하였다.<br>2배로 만드는 이유는 아마 한 쓰레드에서 병목이 발생하면(최대한 적어야겠지만) 다른 쓰레드에서 커버쳐주기 위함이 아닐까 싶다.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;이벤트 루프의 개념이 명확하지 않아 &lt;a href=&quot;https://www.hanbit.co.kr/media/books/book_view.html?p_code=B2683487348&quot;&gt;자바 네트워크 소녀 네티&lt;/a&gt;를 보고 정리해봄.&lt;/p&gt;
&lt;p&gt;통상적으로 이벤트 기반 어플리케이션이 이벤트를 처리하는 방식은 아래 두 가지가 존재한다고 함.&lt;/p&gt;
&lt;h2 id=&quot;이벤트-리스너와-이벤트-처리-쓰레드-방식&quot;&gt;&lt;a href=&quot;#이벤트-리스너와-이벤트-처리-쓰레드-방식&quot; class=&quot;headerlink&quot; title=&quot;이벤트 리스너와 이벤트 처리 쓰레드 방식&quot;&gt;&lt;/a&gt;이벤트 리스너와 이벤트 처리 쓰레드 방식&lt;/h2&gt;&lt;p&gt;브라우저에서 DOM에 클릭 이벤트를 어떻게 핸들링하는지 생각해보면 된다.  &lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;string&quot;&gt;&amp;#x27;body&amp;#x27;&lt;/span&gt;).onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.dir(e) &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/categories/Note/Netty/"/>
    
    
    <category term="TCP" scheme="https://perfectacle.github.io/tags/TCP/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty 용어사전</title>
    <link href="https://perfectacle.github.io/2021/02/28/netty-glossary/"/>
    <id>https://perfectacle.github.io/2021/02/28/netty-glossary/</id>
    <published>2021-02-27T15:32:51.000Z</published>
    <updated>2021-03-06T13:23:48.946Z</updated>
    
    <content type="html"><![CDATA[<p>Netty의 개념이 하도 익숙하지 않아 <a href="https://www.hanbit.co.kr/media/books/book_view.html?p_code=B2683487348">자바 네트워크 소녀 네티</a>를 보고 용어를 정리해봄.</p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a><a href="https://netty.io/">Netty</a></h2><blockquote><p>Netty is an asynchronous event-driven network application framework<br>for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p>네티는 비동기 이벤트 기반 네트워크 어플리케이션 프레임워크로써 유지보수를 고려한 고성능 프로토콜 서버와 클라이언트를 빠르게 개발할 수 있다.<br>즉, TCP 통신을 위해 무조건 Netty를 써야하는 건 아니지만 유지보수하기도 쉽고, 비동기 이벤트 기반이기 때문에 고성능도 보장하게 된다.<br><a href="https://docs.spring.io/spring-integration/reference/html/ip.html">Spring Integration</a> 또한 TCP 통신을 지원한다.</p><blockquote><p>Spring Integration provides channel adapters for receiving and sending messages over internet protocols.<br>  Both UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) adapters are provided.</p></blockquote><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>네티로 작성한 네트워크 어플리케이션의 동작 방식과 환경을 설정하는 도우미 클래스, 주로 클라이언트 어플리케이션에 사용된다.<br>추상화가 잘 돼있어서 블로킹 모드에서 논블로킹 모드로 바꾸는 등의 설정이 매우 쉬우며 아래 설정이 가능하다.    </p><ul><li>전송 계층 (소켓 모드 및 I/O 종류)</li><li>이벤트 루프 (단일 스레드, 다중 스레드)</li><li>채널 파이프라인 설정</li><li>소켓 주소와 포트</li><li>소켓 옵션</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// BootStrap</span></span><br><span class="line">    <span class="keyword">val</span> bootstrap = Bootstrap()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 이벤트 루프 (단일 스레드, 다중 스레드)</span></span><br><span class="line">    <span class="keyword">val</span> group: EventLoopGroup = NioEventLoopGroup()</span><br><span class="line"></span><br><span class="line">    bootstrap</span><br><span class="line">        .group(group) <span class="comment">// 이벤트 루프</span></span><br><span class="line">        .channel(NioServerSocketChannel::<span class="keyword">class</span>.java) <span class="comment">// 전송 계층 (소켓 모드 및 I/O 종류)</span></span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>) <span class="comment">// 채널 옵션</span></span><br><span class="line">        .handler(<span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123; <span class="comment">// 채널 데이터 가공 핸들러</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123; <span class="comment">// 소켓 채널이 생성될 때(서버와 연결을 맺을 때) 실행됨</span></span><br><span class="line">                <span class="comment">// 채널 파이프라인 설정</span></span><br><span class="line">                ch.pipeline().addLast(ReadTimeoutHandler(<span class="number">60</span>, TimeUnit.SECONDS))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 서버의 주소와 포트</span></span><br><span class="line">    <span class="keyword">val</span> f: ChannelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h2><p>Bootstrap 중에 서버의 설정을 돕기 위한 클래스, 주로 서버 어플리케이션에 사용된다.<br>아래 설정이 가능하다.  </p><ul><li>전송 계층 (소켓 모드 및 I/O 종류)</li><li>이벤트 루프 (단일 스레드, 다중 스레드)<ul><li>서버 소켓 채널 이벤트 루프</li><li>소켓 채널 이벤트 루프</li></ul></li><li>채널 파이프라인 설정<ul><li>서버 소켓 채널 파이프라인 설정</li><li>소켓 채널 파이프라인 설정</li></ul></li><li>소켓 주소와 포트</li><li>소켓 옵션</li></ul><p>서버 소켓 채널은 특정 포트를 listen하고 있다가 해당 포트로 커넥션 요청이 들어오면 해당 커넥션을 요청한 클라이언트와 통신하기 위해 소켓 채널을 만든다.<br>실질적인 통신은 소켓 채널에서 이루어진다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ServerBootStrap</span></span><br><span class="line">    <span class="keyword">val</span> bootstrap = ServerBootstrap()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 이벤트 루프 (단일 스레드, 다중 스레드)</span></span><br><span class="line">    <span class="keyword">val</span> bossGroup: EventLoopGroup = NioEventLoopGroup()</span><br><span class="line">    <span class="keyword">val</span> workerGroup: EventLoopGroup = NioEventLoopGroup()</span><br><span class="line"></span><br><span class="line">    bootstrap</span><br><span class="line">        .group(</span><br><span class="line">            bossGroup, <span class="comment">// 서버 소켓 채널 이벤트 루프</span></span><br><span class="line">            workerGroup <span class="comment">// 소켓 채널 이벤트 루프</span></span><br><span class="line">        )</span><br><span class="line">        .channel(NioServerSocketChannel::<span class="keyword">class</span>.java) <span class="comment">// 전송 계층 (소켓 모드 및 I/O 종류)</span></span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>) <span class="comment">// 서버 소켓 채널 옵션</span></span><br><span class="line">        .childOption(ChannelOption.TCP_NODELAY, <span class="literal">false</span>) <span class="comment">// 소켓 채널 옵션</span></span><br><span class="line">        .handler(<span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123; <span class="comment">// 서버 소켓 채널</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123; <span class="comment">// 서버 소켓 채널 데이터 가공 핸들러 (서버 소켓 채널이 생성될 때(서버 소켓에 포트가 바인딩될 때) 실행됨)</span></span><br><span class="line">                <span class="comment">// 서버 소켓 채널 파이프라인 설정</span></span><br><span class="line">                ch.pipeline().addLast(ReadTimeoutHandler(<span class="number">60</span>, TimeUnit.SECONDS))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .childHandler(<span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123; <span class="comment">// 소켓 채널</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123; <span class="comment">// 소켓 채널 데이터 가공 핸들러 (소켓 채널이 생성될 때(클라이언트와 연결을 맺을 때) 실행됨)</span></span><br><span class="line">                <span class="comment">// 소켓 채널 파이프라인 설정</span></span><br><span class="line">                ch.pipeline().addLast(ReadTimeoutHandler(<span class="number">60</span>, TimeUnit.SECONDS))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 서버 소켓 채널 주소와 포트</span></span><br><span class="line">    <span class="keyword">val</span> f: ChannelFuture = bootstrap.bind(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h2><p>EventLoop를 그룹핑한 것이다.<br>여러 EventLoop가 존재하는데 그 중에 나는 NioEventLoopGroup를 주로 사용한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventLoopGroup</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>NioEventLoopGroup은 멀티쓰레드 환경의 이벤트 루프 그룹이다.<br>또한 NioEventLoopGroup은 기본 생성자를 사용하면 <code>CPU 코어 수 * 2</code>개의 EventLoop가 생성된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">            <span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>)); <span class="comment">// &lt;-- CPU 코어 갯수에 2를 곱하고  있다.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args); <span class="comment">// &lt;-- 기본 생성자는 nThreads가 0이다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyRuntime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">availableProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.availableProcessors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AvailableProcessorsHolder holder = <span class="keyword">new</span> AvailableProcessorsHolder();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableProcessorsHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> availableProcessors;</span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">availableProcessors</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.availableProcessors == <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> availableProcessors = </span><br><span class="line">                        SystemPropertyUtil.getInt(</span><br><span class="line">                            <span class="string">&quot;io.netty.availableProcessors&quot;</span>, </span><br><span class="line">                            Runtime.getRuntime().availableProcessors() <span class="comment">// &lt;-- 여기에서 CPU 코어 갯수를 반환함.</span></span><br><span class="line">                        );</span><br><span class="line">                setAvailableProcessors(availableProcessors); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.availableProcessors; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setAvailableProcessors</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> availableProcessors)</span> </span>&#123; </span><br><span class="line">            ObjectUtil.checkPositive(availableProcessors, <span class="string">&quot;availableProcessors&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.availableProcessors != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">final</span> String message = String.format(</span><br><span class="line">                    Locale.ROOT, </span><br><span class="line">                    <span class="string">&quot;availableProcessors is already set to [%d], rejecting [%d]&quot;</span>, </span><br><span class="line">                    <span class="keyword">this</span>.availableProcessors, </span><br><span class="line">                    availableProcessors</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.availableProcessors = availableProcessors; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 CPU 코어수 * 2개라는 건 알았으니까 정말로 그만큼의 NioEventLoop이 생성되는지 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args); <span class="comment">// &lt;-- 기본 생성자는 nThreads가 0이다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads)); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123; </span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        children = <span class="keyword">new</span> EventExecutor[nThreads]; <span class="comment">// 코어 갯수 * 2개의 배열 생성</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123; <span class="comment">// 코어 갯수 * 2개만큼 반복</span></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                children[i] = newChild(executor, args);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>], </span><br><span class="line">                ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop는 이벤트가 올 때까지 무한 반복을 도는 쓰레드이다.<br>EventLoopGroup에 따라 어떤 EventLoop가 생성될지 모르는데 나는 주로 NioEventLoopGroup을 사용하다보니 NioEventLoop를 파보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoop</span> <span class="keyword">extends</span> <span class="title">SingleThreadEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 무한 반복</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEventLoop는 단일 쓰레드 이벤트 루프이다. (하나의 이벤트 루프에 하나의 쓰레드 할당)<br>그럼 이벤트가 올 때까지 해당 쓰레드가 block되는 건 아닐까? 하는 의문이 들었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoop</span> <span class="keyword">extends</span> <span class="title">SingleThreadEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br><span class="line">  </span><br><span class="line">    NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, </span><br><span class="line">                 EventLoopTaskQueueFactory queueFactory) &#123; </span><br><span class="line">        <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory), </span><br><span class="line">                rejectedExecutionHandler);</span><br><span class="line">        <span class="keyword">this</span>.provider = ObjectUtil.checkNotNull(selectorProvider, <span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.selectStrategy = ObjectUtil.checkNotNull(strategy, <span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">        <span class="keyword">this</span>.selector = selectorTuple.selector;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntSupplier selectNowSupplier = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> selectNow(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> selector.selectNow(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/netty-glossary/nio-event-loop.png"><br>selector는 io.netty.channel.nio.SelectedSelectionKeySetSelector 클래스이다.<br>그리고 그 안에 delegate는 KQueueSelectorImpl이다.<br><a href="https://stackoverflow.com/questions/7916324/do-nio-selectors-use-event-notifications-by-default">JRE마다 SelectorImpl은 달라질 수 있다.</a>  </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Windows </span><br><span class="line">sun.nio.ch.WindowsSelectorImpl</span><br><span class="line"></span><br><span class="line">Mac OS </span><br><span class="line">sun.nio.ch.KQueueSelectorImpl</span><br><span class="line"></span><br><span class="line">Linux </span><br><span class="line">sun.nio.ch.EPollSelectorImpl</span><br><span class="line"></span><br><span class="line">Solaris</span><br><span class="line">sun.nio.ch.PollSelectorImpl</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySetSelector</span> <span class="keyword">extends</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectedSelectionKeySet selectionKeys;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector delegate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selectionKeys.reset();</span><br><span class="line">        <span class="keyword">return</span> delegate.selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorImpl</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractSelector</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lockAndDoSelect(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isOpen())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">      <span class="keyword">synchronized</span> (publicKeys) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">          <span class="keyword">return</span> doSelect(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KQueueSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        <span class="keyword">boolean</span> var3 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException(); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.processDeregisterQueue();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> var7;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                <span class="keyword">this</span>.begin();</span><br><span class="line">                var7 = <span class="keyword">this</span>.kqueueWrapper.poll(var1); </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">                <span class="keyword">this</span>.end(); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.processDeregisterQueue();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.updateSelectedKeys(var7); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KQueueArrayWrapper</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> var1)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.updateRegistrations();</span><br><span class="line">        <span class="comment">// var1은 timeout에서 넘어온 0이므로 블락시키지 않고 바로 다음 구문으로 간다.</span></span><br><span class="line">        <span class="keyword">int</span> var3 = <span class="keyword">this</span>.kevent0(<span class="keyword">this</span>.kq, <span class="keyword">this</span>.keventArrayAddress, <span class="number">128</span>, var1);</span><br><span class="line">        <span class="keyword">return</span> var3; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">kevent0</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">long</span> var5)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selectNow 메서드는 KQueue의 timeout에 0을 넘기기 때문에 기다리지 않는다.</p><h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>자바의 바이트 버퍼 클래스(java.nio.ByteBuffer)와 유사하지만 더 나은 성능과 편의성을 가진 Netty의 버퍼 클래스</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>일반적인 소켓 프로그래밍에서 말하는 소켓과 같다고 보면 된다고 함.</p><h2 id="Channel-Pipeline"><a href="#Channel-Pipeline" class="headerlink" title="Channel Pipeline"></a>Channel Pipeline</h2><p>네티의 채널과 이벤트 핸들러 사이에서 연결 통로 역할을 수행.<br>채널에서 발생한 이벤트가 채널 파이프라인을 타고 흘러가고, 이벤트 핸들러는 이벤트를 수신한 후에 본인이 처리해야하는 이벤트인지 판단하고 처리한다.</p><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><h3 id="Inbound-Event"><a href="#Inbound-Event" class="headerlink" title="Inbound Event"></a>Inbound Event</h3><p>연결 상대방이 어떤 동작을 취했을 때 발생함</p><ul><li>channelRegistered - 채널이 이벤트 루프에 등록되었을 때 발생<br>서버 소켓 채널의 channelRegistered 이벤트는 서버 소켓 채널이 생성됐을 때 발생하고, 클라이언트 소켓 채널의 channelRegistered 이벤트는 새로운 클라이언트가 서버에 접속하며 클라이언트 소켓 채널이 생성될 때 발생한다.  </li><li>channelActive - channelRegistered 이후에 발생<br>채널이 생성되고 이벤트 루프에 등록된 이후에 네티 API를 사용하여 입출력을 수행할 상태가 되었음을 알려주는 이벤트</li><li>channelRead - 데이터가 수신될 때마다 발생하는 이벤트</li><li>channelReadComplete - 데이터 수신이 완료됐을 때 발생하는 이벤트<br>channelRead 이벤트는 채널에 데이터가 있을 때 발생하고, channelReadComplete는 채널의 데이터를 다 읽어서 더 이상 데이터가 없을 때 발생한다.</li><li>channelInactive -  채널이 비활성화되었을 때 발생</li><li>channelUnregistered -  채널이 이벤트 루프에 제거되었을 대 발생</li></ul><h3 id="Outbound-Event"><a href="#Outbound-Event" class="headerlink" title="Outbound Event"></a>Outbound Event</h3><p>프로그래머가 요청한 동작에 해당하는 이벤트</p><ul><li>bind - 서버 소켓 채널이 클라이언트의 연결을 대기하는 IP와 포트가 설정되었을 때 발생</li><li>connect - 클라이언트 소켓 채널이 서버에 연결되었을 때 발생</li><li>disconnect -  클라이언트 소켓 채널의 연결이 끊어졌을 때 발생</li><li>close - 클라이언트 소켓 채널의 연결이 닫혔을 때 발생</li><li>write - 소켓 채널에 데이터가 기록되었을 때 발생</li><li>flush - 소켓 채널에 flush 메서드가 호출되었을 때 발생</li></ul><h2 id="Event-Handler"><a href="#Event-Handler" class="headerlink" title="Event Handler"></a>Event Handler</h2><p>이벤트가 발생했을 때 이벤트를 처리하는 역할을 담당한다.<br>크게 이벤트 유형에 따라 ChannelInboundHandler, ChannelOutboundHandler 인터페이스로 나눌 수 있다.</p><h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>채널에 대한 입출력 처리 및 채널 파이프라인에 대한 상호작용을 도와주는 인터페이스<br>ChannelHandlerContext의 writeAndFlush 메서드로 채널에 데이터를 기록하거나 close 메서드로 채널의 연결을 종료할 수 있다.<br>또한 ChannelHandlerContext는 채널이 초기화될 때 설정된 채널 파이프라인을 가져오는 메서드를 제공하기 때문에 채널 파이프라인을 수정할 수 있다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">object</span> : ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">             <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">Channel</span>)</span></span> &#123;</span><br><span class="line">                 ch.pipeline().addLast(ReadTimeoutHandler(<span class="number">60</span>, TimeUnit.SECONDS))</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure><h2 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h2><p>보통 동영상 압축 알고리즘을 코덱이라 부름.  </p><ul><li>원본 -&gt; 인코딩(압축) -&gt; 압축된 동영상 파일</li><li>압축된 동영상 파일 -&gt; 디코딩 (압축 해제) -&gt; 원본 파일</li></ul><h3 id="Encoder-Outbound-Event-Handler"><a href="#Encoder-Outbound-Event-Handler" class="headerlink" title="Encoder (Outbound Event Handler)"></a>Encoder (Outbound Event Handler)</h3><p>송신 데이터 -&gt; 인코더 (데이터 변환 알고리즘) -&gt; 소켓 채널</p><h3 id="Decoder-Inbound-Event-Handler"><a href="#Decoder-Inbound-Event-Handler" class="headerlink" title="Decoder (Inbound Event Handler)"></a>Decoder (Inbound Event Handler)</h3><p>소켓 채널 -&gt; 디코더 (데이터 변환 알고리즘) -&gt; 수신 데이터</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty의 개념이 하도 익숙하지 않아 &lt;a href=&quot;https://www.hanbit.co.kr/media/books/book_view.html?p_code=B2683487348&quot;&gt;자바 네트워크 소녀 네티&lt;/a&gt;를 보고 용어를 정리해봄.&lt;/p&gt;
&lt;h2 id=&quot;Netty&quot;&gt;&lt;a href=&quot;#Netty&quot; class=&quot;headerlink&quot; title=&quot;Netty&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://netty.io/&quot;&gt;Netty&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Netty is an asynchronous event-driven network application framework&lt;br&gt;for rapid development of maintainable high performance protocol servers &amp;amp; clients.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;네티는 비동기 이벤트 기반 네트워크 어플리케이션 프레임워크로써 유지보수를 고려한 고성능 프로토콜 서버와 클라이언트를 빠르게 개발할 수 있다.&lt;br&gt;즉, TCP 통신을 위해 무조건 Netty를 써야하는 건 아니지만 유지보수하기도 쉽고, 비동기 이벤트 기반이기 때문에 고성능도 보장하게 된다.&lt;br&gt;&lt;a href=&quot;https://docs.spring.io/spring-integration/reference/html/ip.html&quot;&gt;Spring Integration&lt;/a&gt; 또한 TCP 통신을 지원한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Integration provides channel adapters for receiving and sending messages over internet protocols.&lt;br&gt;  Both UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) adapters are provided.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/categories/Note/Netty/"/>
    
    
    <category term="TCP" scheme="https://perfectacle.github.io/tags/TCP/"/>
    
    <category term="Netty" scheme="https://perfectacle.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>(Spring Boot) SimpleClientHttpRequestFactory와 Connection Pool</title>
    <link href="https://perfectacle.github.io/2021/02/14/simple-client-http-request-factory-connection-pool/"/>
    <id>https://perfectacle.github.io/2021/02/14/simple-client-http-request-factory-connection-pool/</id>
    <published>2021-02-14T04:04:05.000Z</published>
    <updated>2021-02-14T04:35:08.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="N줄-요약"><a href="#N줄-요약" class="headerlink" title="N줄 요약"></a>N줄 요약</h2><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html">SimpleClientHttpRequestFactory</a>(RestTemplate을 기본생성자로 만들었을 때 사용하는)를 사용하더라도 내부에서 <a href="https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/net/www/http/KeepAliveCache.java">KeepAliveCache</a>를 사용하여 커넥션 풀을 관리한다.<br>기본적으로 <a href="https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/net/www/http/KeepAliveCache.java#L295">KeepAliveKey(protocol, host, port)</a> 당 5개의 풀을 가지며 시스템 프로퍼티 <code>http.maxConnections</code>를 할당해주면 늘릴 수 있다.<br>커넥션 풀을 초과하면 커넥션은 바로 종료되며, 커넥션 풀 내의 커넥션은 매번 연결을 맺고 끊는 게 아니라 재사용 된다.<br>당연하게도 서버에서 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive">Keep-Alive</a>를 사용하지 않으면 매번 커넥션이 종료된다.<br>그럼에도 불구하고 SimpleClientHttpRequestFactory는 다음의 단점이 있기 때문에 토이 프로젝트가 아닌 이상 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html">HttpComponentsClientHttpRequestFactory</a> 같은 다른 구현체를 사용해야할 것 같다.  </p><ul><li>http.maxConnections라는 시스템 프로퍼티를 설정해야하는데 설정을 위해 자주 사용하던 properties(yml)에는 설정할 수 없다보니 다른 방법으로 설정을 해줘야하고, 그러다 보면 설정을 파악하려면 한 군데(properties 또는 yml)만 집중해서는 파악할 수 없는 내용도 있다보니 실수할 여지가 발생할 수 있다.  </li><li>KeepAliveCache가 static 변수이다보니 서로 다른 SimpleClientHttpRequestFactory여도 동일한 커넥션 풀을 참조한다.</li><li>route(프로토콜, 호스트, 포트) 별 커넥션 풀은 설정할 수 있지만 토탈 커넥션 풀은 제한이 없다. </li></ul><h2 id="SimpleClientHttpRequestFactory가-뭐지"><a href="#SimpleClientHttpRequestFactory가-뭐지" class="headerlink" title="SimpleClientHttpRequestFactory가 뭐지??"></a>SimpleClientHttpRequestFactory가 뭐지??</h2><p>RestTemplate의 기본 생성자를 사용하면 ClientHttpRequestFactory를 별도로 초기화하지 않으므로 기본값인 SimpleClientHttpRequestFactory를 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplate</span> <span class="keyword">extends</span> <span class="title">InterceptingHttpAccessor</span> <span class="keyword">implements</span> <span class="title">RestOperations</span> </span>&#123;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptingHttpAccessor</span> <span class="keyword">extends</span> <span class="title">HttpAccessor</span> </span>&#123;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Logger available to subclasses. */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Log logger = HttpLogging.forLogName(getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/client/ClientHttpRequest.html#:~:text=Interface%20ClientHttpRequest&text=Represents%20a%20client%2Dside%20HTTP,which%20can%20be%20read%20from.">ClientHttpRequest</a>의 javadoc을 보면 아래와 같이 나와있다.</p><blockquote><p>Represents a client-side HTTP request. Created via an implementation of the ClientHttpRequestFactory.<br>  A ClientHttpRequest can be executed, receiving a ClientHttpResponse which can be read from.</p></blockquote><p>ClientHttpRequest는 클라이언트 측면의 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpRequest.html">HttpRequest</a>이며, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/client/ClientHttpRequestFactory.html">ClientHttpRequestFactory</a> 구현체에 의해 생성된다.<br>ClientHttpRequest는 실행될 수 있으머, ClientHttpResponse를 받아서 읽을 수 있다.<br>대충 해석해보면 그냥 팩토리로 request 만들어서 서버로 전송하고 응답받을 수 있다는 내용 같다.</p><p>HTTP 통신을 사용할 때 사용하다보니 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html">SimpleClientHttpRequestFactory</a>에는 기본적인 타임아웃을 설정할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClientHttpRequestFactory</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestFactory</span>, <span class="title">AsyncClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CHUNK_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Proxy proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> bufferRequestBody = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> chunkSize = DEFAULT_CHUNK_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> connectTimeout = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> readTimeout = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 ClientHttpRequestFactory는 RestTemplate을 이용하여 통신할 때 사용된다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplate</span> <span class="keyword">extends</span> <span class="title">InterceptingHttpAccessor</span> <span class="keyword">implements</span> <span class="title">RestOperations</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span><br><span class="line">        HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span><br><span class="line">                <span class="keyword">new</span> HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span><br><span class="line">        <span class="keyword">return</span> execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String url, HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">    </span><br><span class="line">        URI expanded = getUriTemplateHandler().expand(url, uriVariables);</span><br><span class="line">        <span class="keyword">return</span> doExecute(expanded, method, requestCallback, responseExtractor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(URI url, <span class="meta">@Nullable</span> HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">    </span><br><span class="line">        Assert.notNull(url, <span class="string">&quot;URI is required&quot;</span>);</span><br><span class="line">        Assert.notNull(method, <span class="string">&quot;HttpMethod is required&quot;</span>);</span><br><span class="line">        ClientHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClientHttpRequest request = createRequest(url, method);</span><br><span class="line">            <span class="keyword">if</span> (requestCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                requestCallback.doWithRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">            response = request.execute();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doExecute에서 호출하는 createRequest는 HttpAccessor에 있는 메서드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new &#123;<span class="doctag">@link</span> ClientHttpRequest&#125; via this template&#x27;s &#123;<span class="doctag">@link</span> ClientHttpRequestFactory&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url the URL to connect to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method the HTTP method to execute (GET, POST, etc)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the created request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException in case of I/O errors</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getRequestFactory()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ClientHttpRequestFactory#createRequest(URI, HttpMethod)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClientHttpRequest <span class="title">createRequest</span><span class="params">(URI url, HttpMethod method)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClientHttpRequest request = getRequestFactory().createRequest(url, method);</span><br><span class="line">        initialize(request);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;HTTP &quot;</span> + method.name() + <span class="string">&quot; &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 SimpleClientHttpRequestFactory의 createRequest 메서드를 보면 요청을 보내기 위해 <a href="https://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html">HttpURLConnection</a>을 사용한다는 사실을 알 수 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ClientHttpRequestFactory&#125; implementation that uses standard JDK facilities.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.net.HttpURLConnection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HttpComponentsClientHttpRequestFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClientHttpRequestFactory</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestFactory</span>, <span class="title">AsyncClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpRequest <span class="title">createRequest</span><span class="params">(URI uri, HttpMethod httpMethod)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpURLConnection connection = openConnection(uri.toURL(), <span class="keyword">this</span>.proxy);</span><br><span class="line">        prepareConnection(connection, httpMethod.name());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.bufferRequestBody) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleBufferingClientHttpRequest(connection, <span class="keyword">this</span>.outputStreaming);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleStreamingClientHttpRequest(connection, <span class="keyword">this</span>.chunkSize, <span class="keyword">this</span>.outputStreaming);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Opens and returns a connection to the given URL.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation uses the given &#123;<span class="doctag">@linkplain</span> #setProxy(java.net.Proxy) proxy&#125; -</span></span><br><span class="line"><span class="comment">     * if any - to open a connection.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url the URL to open a connection to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy the proxy to use, may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the opened connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException in case of I/O errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpURLConnection <span class="title">openConnection</span><span class="params">(URL url, <span class="meta">@Nullable</span> Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URLConnection urlConnection = (proxy != <span class="keyword">null</span> ? url.openConnection(proxy) : url.openConnection());</span><br><span class="line">        <span class="keyword">if</span> (!(urlConnection <span class="keyword">instanceof</span> HttpURLConnection)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;HttpURLConnection required for [&quot;</span> + url + <span class="string">&quot;] but got: &quot;</span> + urlConnection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (HttpURLConnection) urlConnection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleClientHttpRequestFactory는-정말로-커넥션-풀을-사용하지-않을까"><a href="#SimpleClientHttpRequestFactory는-정말로-커넥션-풀을-사용하지-않을까" class="headerlink" title="SimpleClientHttpRequestFactory는 정말로 커넥션 풀을 사용하지 않을까?"></a>SimpleClientHttpRequestFactory는 정말로 커넥션 풀을 사용하지 않을까?</h2><p>내 머릿 속 어딘가에서는 SimpleClientHttpRequestFactory는 커넥션 풀을 사용하지 않는다고 기억을 하고 있다.<br>이 말 뜻은 매번 커넥션을 맺고 끊는다는 것인데 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive">Keep-Alive</a> 메커니즘을 전혀 따르지 않는 것으로 보였다.</p><p>정말 이 말이 사실일까 싶어서 테스트를 해보았다.<br>우선 로컬에 간단한 서버를 띄워야하니 컨트롤러를 추가하자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 SimpleClientHttpRequestFactory를 사용하는 테스트를 작성해보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConnectionPoolTest</span></span>(</span><br><span class="line">    <span class="meta">@LocalServerPort</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> port: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> `총 12개의 요청을 두 번에 끊어서 동시에 6개씩 전송`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> threadCount = <span class="number">6</span></span><br><span class="line">        <span class="keyword">val</span> threadPool = Executors.newFixedThreadPool(threadCount)</span><br><span class="line">        <span class="keyword">val</span> futures = mutableListOf&lt;CompletableFuture&lt;String?&gt;&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> restTemplate = RestTemplate()</span><br><span class="line">        <span class="keyword">val</span> total = threadCount * <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..total) &#123;</span><br><span class="line">            futures.add(CompletableFuture.supplyAsync(</span><br><span class="line">                <span class="comment">// 와이어샤크의 패킷 캡쳐를 위해 일부러 private IP를 직접 박음</span></span><br><span class="line">                &#123; restTemplate.getForObject(<span class="string">&quot;http://192.168.0.144:<span class="subst">$&#123;port&#125;</span>&quot;</span>, String::<span class="keyword">class</span>.java) &#125;,</span><br><span class="line">                threadPool</span><br><span class="line">            ))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        futures.forEach &#123; it.join() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// spring-boot-starter-web 모듈의 기본 내장 서버인 embedded tomcat의 </span></span><br><span class="line">        <span class="comment">// 기본 Keep-Alive 헤더의 timeout 파라미터 값인 60초 이후에 커넥션이 끊기는지 확인하기 위해 서버 종료를 딜레이 시킴.</span></span><br><span class="line">        Thread.sleep(<span class="number">70_000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/simple-client-http-request-factory-connection-pool/default-connection-pool-packet-1.png"><br>와이어샤크를 통해 패킷 캡쳐를 해보니 6개의 커넥션이 동시에 맺혀지고 있다.  </p><p><img src="/images/simple-client-http-request-factory-connection-pool/default-connection-pool-packet-2.png"><br>커넥션 풀을 사용하지 않는다면 모든 커넥션이 종료돼야하는데 하나의 커넥션만 종료되고 있다.<br>가장 처음 응답을 받은 소켓(50322 포트)이 닫혔다.<br>그리고 다음에 또 6개의 요청을 보내야하는데 커넥션이 하나 모자르므로 소켓(50324 포트)을 하나 더 열어서 커넥션을 맺었다.  </p><p><img src="/images/simple-client-http-request-factory-connection-pool/default-connection-pool-packet-3.png"><br>위와 동일하게 50324 포트는 응답을 받자마자 바로 커넥션이 끊겼다.<br>그리고 나머지 5개의 커넥션은 Keep-Alive의 timeout 파라미터인 60초 이후에 커넥션이 끊기기 시작했다.  </p><h2 id="SimpleClientHttpRequestFactory와-커넥션-풀"><a href="#SimpleClientHttpRequestFactory와-커넥션-풀" class="headerlink" title="SimpleClientHttpRequestFactory와 커넥션 풀"></a>SimpleClientHttpRequestFactory와 커넥션 풀</h2><p>위 테스트를 토대로 SimpleClientHttpRequestFactory가 커넥션 풀을 사용은 하는 것 같은데 최대 5개가 아닐까 의심이 들었다.  </p><p>그래서 다시 한 번 RestTemplate의 getForObject 메서드에 브레이크 포인트를 걸고 쫓아가보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplate</span> <span class="keyword">extends</span> <span class="title">InterceptingHttpAccessor</span> <span class="keyword">implements</span> <span class="title">RestOperations</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span><br><span class="line">        HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span><br><span class="line">                <span class="keyword">new</span> HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span><br><span class="line">        <span class="keyword">return</span> execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String url, HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">    </span><br><span class="line">        URI expanded = getUriTemplateHandler().expand(url, uriVariables);</span><br><span class="line">        <span class="keyword">return</span> doExecute(expanded, method, requestCallback, responseExtractor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(URI url, <span class="meta">@Nullable</span> HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">    </span><br><span class="line">        Assert.notNull(url, <span class="string">&quot;URI is required&quot;</span>);</span><br><span class="line">        Assert.notNull(method, <span class="string">&quot;HttpMethod is required&quot;</span>);</span><br><span class="line">        ClientHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClientHttpRequest request = createRequest(url, method);</span><br><span class="line">            <span class="keyword">if</span> (requestCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                requestCallback.doWithRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">            response = request.execute();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>request는 SimpleClientHttpRequestFactory에 의해 생성됐기 때문에 HttpURLConnection을 가지고 있다.<br>그리고 request.execute()를 쭉 타고가보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClientHttpRequest</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClientHttpResponse <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        assertNotExecuted();</span><br><span class="line">        ClientHttpResponse result = executeInternal(<span class="keyword">this</span>.headers);</span><br><span class="line">        <span class="keyword">this</span>.executed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBufferingClientHttpRequest</span> <span class="keyword">extends</span> <span class="title">AbstractClientHttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">executeInternal</span><span class="params">(HttpHeaders headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">this</span>.bufferedOutput.toByteArray();</span><br><span class="line">        <span class="keyword">if</span> (headers.getContentLength() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            headers.setContentLength(bytes.length);</span><br><span class="line">        &#125;</span><br><span class="line">        ClientHttpResponse result = executeInternal(headers, bytes);</span><br><span class="line">        <span class="keyword">this</span>.bufferedOutput = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBufferingClientHttpRequest</span> <span class="keyword">extends</span> <span class="title">AbstractBufferingClientHttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">executeInternal</span><span class="params">(HttpHeaders headers, <span class="keyword">byte</span>[] bufferedOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        addHeaders(<span class="keyword">this</span>.connection, headers);</span><br><span class="line">        <span class="comment">// JDK &lt;1.8 doesn&#x27;t support getOutputStream with HTTP DELETE</span></span><br><span class="line">        <span class="keyword">if</span> (getMethod() == HttpMethod.DELETE &amp;&amp; bufferedOutput.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.connection.setDoOutput(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection.getDoOutput() &amp;&amp; <span class="keyword">this</span>.outputStreaming) &#123;</span><br><span class="line">            <span class="keyword">this</span>.connection.setFixedLengthStreamingMode(bufferedOutput.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.connection.connect();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection.getDoOutput()) &#123;</span><br><span class="line">            FileCopyUtils.copy(bufferedOutput, <span class="keyword">this</span>.connection.getOutputStream());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Immediately trigger the request in a no-output scenario as well</span></span><br><span class="line">            <span class="keyword">this</span>.connection.getResponseCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleClientHttpResponse(<span class="keyword">this</span>.connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.connection.connect()에서 실제 커넥션을 맺는데 한번 들어가보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpURLConnection</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">net</span>.<span class="title">HttpURLConnection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            connecting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        plainConnect();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">plainConnect</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       plainConnect0();</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">plainConnect0</span><span class="params">()</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        http = getNewHttpClient(url, p, connectTimeout, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// subclass HttpsClient will overwrite &amp; return an instance of HttpsClient</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpClient <span class="title">getNewHttpClient</span><span class="params">(URL url, Proxy p, <span class="keyword">int</span> connectTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HttpClient.New(url, p, connectTimeout, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 HttpClient 클래스를 봐보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> <span class="keyword">extends</span> <span class="title">NetworkClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* where we cache currently open, persistent connections */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> KeepAliveCache kac = <span class="keyword">new</span> KeepAliveCache();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpClient <span class="title">New</span><span class="params">(URL url, Proxy p, <span class="keyword">int</span> to,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpURLConnection httpuc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> New(url, p, to, <span class="keyword">true</span>, httpuc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpClient <span class="title">New</span><span class="params">(URL url, Proxy p, <span class="keyword">int</span> to, <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpURLConnection httpuc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = Proxy.NO_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">        HttpClient ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/* see if one&#x27;s already around */</span></span><br><span class="line">        <span class="keyword">if</span> (useCache) &#123;</span><br><span class="line">            ret = kac.get(url, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> HttpClient(url, p, to);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kac.get(url, null)</code> - KeepAliveCache에 이미 커넥션이 존재하는지 확인하고 없으면 새로운 커넥션을 맺고 있다.<br><code>protected static KeepAliveCache kac = new KeepAliveCache();</code>에서 보다싶이 KeepAliveCache는 static 변수이다보니 어플리케이션 전역에서 공유되는 자원이다. (즉, 서로 다른 SimpleClientHttpRequestFactory를 가진 RestTemplate이라도 커넥션 풀을 공유한다는 소리다.)<br>캐시에 이미 맺어진 커넥션이 캐시에 존재한다면 그걸 사용하고, 아니면 다시 tcp 커넥션을 맺는다.<br>이제 KeepAliveCache가 어떻게 생겨먹었는지 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveCache</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">KeepAliveKey</span>, <span class="title">ClientVector</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> HttpClient <span class="title">get</span><span class="params">(URL url, Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        KeepAliveKey key = <span class="keyword">new</span> KeepAliveKey(url, obj);</span><br><span class="line">        ClientVector v = <span class="keyword">super</span>.get(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123; <span class="comment">// nothing in cache yet</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepAliveKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String      protocol = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String      host = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>         port = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object      obj = <span class="keyword">null</span>; <span class="comment">// additional key, such as socketfactory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url the URL containing the protocol, host and port information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeepAliveKey</span><span class="params">(URL url, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.protocol = url.getProtocol();</span><br><span class="line">        <span class="keyword">this</span>.host = url.getHost();</span><br><span class="line">        <span class="keyword">this</span>.port = url.getPort();</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine whether or not two objects of this type are equal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj <span class="keyword">instanceof</span> KeepAliveKey) == <span class="keyword">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        KeepAliveKey kae = (KeepAliveKey)obj;</span><br><span class="line">        <span class="keyword">return</span> host.equals(kae.host)</span><br><span class="line">            &amp;&amp; (port == kae.port)</span><br><span class="line">            &amp;&amp; protocol.equals(kae.protocol)</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.obj == kae.obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The hashCode() for this object is the string hashCode() of</span></span><br><span class="line"><span class="comment">     * concatenation of the protocol, host name and port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = protocol+host+port;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.obj == <span class="keyword">null</span>? str.hashCode() :</span><br><span class="line">            str.hashCode() + <span class="keyword">this</span>.obj.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientVector</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Stack</span>&lt;<span class="title">KeepAliveEntry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> HttpClient <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Loop until we find a connection that has not timed out</span></span><br><span class="line">            HttpClient hc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                KeepAliveEntry e = pop();</span><br><span class="line">                <span class="keyword">if</span> ((currentTime - e.idleStartTime) &gt; nap) &#123;</span><br><span class="line">                    e.hc.closeServer();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hc = e.hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((hc== <span class="keyword">null</span>) &amp;&amp; (!empty()));</span><br><span class="line">            <span class="keyword">return</span> hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepAliveEntry</span> </span>&#123;</span><br><span class="line">    HttpClient hc;</span><br><span class="line">    <span class="keyword">long</span> idleStartTime;</span><br><span class="line"></span><br><span class="line">    KeepAliveEntry(HttpClient hc, <span class="keyword">long</span> idleStartTime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hc = hc;</span><br><span class="line">        <span class="keyword">this</span>.idleStartTime = idleStartTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/simple-client-http-request-factory-connection-pool/keep-alive-cache.png"><br>KeepAliveCache를 보면 KeepAliveKey(프로토콜, 호스트, 포트)를 키로 가지고 있고, ClientVector(Stack을 상속받음)에 실제 커넥션(KeepAliveEntry)들이 들어있다.<br>그리고 스택에서 하나씩 커넥션을 꺼내오고 있다.</p><p>그럼 언제 KeepAliveCache에 put 할까??</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBufferingClientHttpRequest</span> <span class="keyword">extends</span> <span class="title">AbstractBufferingClientHttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">executeInternal</span><span class="params">(HttpHeaders headers, <span class="keyword">byte</span>[] bufferedOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        addHeaders(<span class="keyword">this</span>.connection, headers);</span><br><span class="line">        <span class="comment">// JDK &lt;1.8 doesn&#x27;t support getOutputStream with HTTP DELETE</span></span><br><span class="line">        <span class="keyword">if</span> (getMethod() == HttpMethod.DELETE &amp;&amp; bufferedOutput.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.connection.setDoOutput(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection.getDoOutput() &amp;&amp; <span class="keyword">this</span>.outputStreaming) &#123;</span><br><span class="line">            <span class="keyword">this</span>.connection.setFixedLengthStreamingMode(bufferedOutput.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.connection.connect();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection.getDoOutput()) &#123;</span><br><span class="line">            FileCopyUtils.copy(bufferedOutput, <span class="keyword">this</span>.connection.getOutputStream());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Immediately trigger the request in a no-output scenario as well</span></span><br><span class="line">            <span class="keyword">this</span>.connection.getResponseCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleClientHttpResponse(<span class="keyword">this</span>.connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>커넥션을 모두 끝마치고 this.connection.getResponseCode() 쪽을 주목해보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpURLConnection</span> <span class="keyword">extends</span> <span class="title">URLConnection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResponseCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We&#x27;re got the response code already</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (responseCode != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> responseCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that we have connected to the server. Record</span></span><br><span class="line"><span class="comment">         * exception as we need to re-throw it if there isn&#x27;t</span></span><br><span class="line"><span class="comment">         * a status line.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Exception exc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getInputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exc = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpURLConnection</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">net</span>.<span class="title">HttpURLConnection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">protected</span> HttpClient http;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> getInputStream0();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> InputStream <span class="title">getInputStream0</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        http.parseHTTP(responses, pi, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        http.finished();</span><br><span class="line">        <span class="comment">// ...                </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 parseHTTP부터 봐보자 (응답의 헤더를 파싱한다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> <span class="keyword">extends</span> <span class="title">NetworkClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> keepingAlive = <span class="keyword">false</span>;     <span class="comment">/* this is a keep-alive connection */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> disableKeepAlive;<span class="comment">/* keep-alive has been disabled for this</span></span><br><span class="line"><span class="comment">                                         connection - this will be used when</span></span><br><span class="line"><span class="comment">                                         recomputing the value of keepingAlive */</span></span><br><span class="line">    <span class="keyword">int</span> keepAliveConnections = -<span class="number">1</span>;    <span class="comment">/* number of keep-alives left */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**Idle timeout value, in milliseconds. Zero means infinity,</span></span><br><span class="line"><span class="comment">     * iff keepingAlive=true.</span></span><br><span class="line"><span class="comment">     * Unfortunately, we can&#x27;t always believe this one.  If I&#x27;m connected</span></span><br><span class="line"><span class="comment">     * through a Netscape proxy to a server that sent me a keep-alive</span></span><br><span class="line"><span class="comment">     * time of 15 sec, the proxy unilaterally terminates my connection</span></span><br><span class="line"><span class="comment">     * after 5 sec.  So we have to hard code our effective timeout to</span></span><br><span class="line"><span class="comment">     * 4 sec for the case where we&#x27;re using a proxy. *SIGH*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> keepAliveTimeout = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Parse the first line of the HTTP request.  It usually looks</span></span><br><span class="line"><span class="comment">            something like: &quot;HTTP/1.0 &lt;number&gt; comment\r\n&quot;. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseHTTP</span><span class="params">(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* If &quot;HTTP/*&quot; is found in the beginning, return true.  Let</span></span><br><span class="line"><span class="comment">         * HttpURLConnection parse the mime header itself.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If this isn&#x27;t valid HTTP, then we don&#x27;t try to parse a header</span></span><br><span class="line"><span class="comment">         * out of the beginning of the response into the responses,</span></span><br><span class="line"><span class="comment">         * and instead just queue up the output stream to it&#x27;s very beginning.</span></span><br><span class="line"><span class="comment">         * This seems most reasonable, and is what the NN browser does.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverInput = serverSocket.getInputStream();</span><br><span class="line">            <span class="keyword">if</span> (capture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                serverInput = <span class="keyword">new</span> HttpCaptureInputStream(serverInput, capture);</span><br><span class="line">            &#125;</span><br><span class="line">            serverInput = <span class="keyword">new</span> BufferedInputStream(serverInput);</span><br><span class="line">            <span class="keyword">return</span> (parseHTTPHeader(responses, pi, httpuc));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseHTTPHeader</span><span class="params">(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* If &quot;HTTP/*&quot; is found in the beginning, return true.  Let</span></span><br><span class="line"><span class="comment">         * HttpURLConnection parse the mime header itself.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If this isn&#x27;t valid HTTP, then we don&#x27;t try to parse a header</span></span><br><span class="line"><span class="comment">         * out of the beginning of the response into the responses,</span></span><br><span class="line"><span class="comment">         * and instead just queue up the output stream to it&#x27;s very beginning.</span></span><br><span class="line"><span class="comment">         * This seems most reasonable, and is what the NN browser does.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        keepAliveConnections = -<span class="number">1</span>;</span><br><span class="line">        keepAliveTimeout = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        HeaderParser p = <span class="keyword">new</span> HeaderParser(responses.findValue(<span class="string">&quot;Keep-Alive&quot;</span>));</span><br><span class="line">        <span class="comment">/* default should be larger in case of proxy */</span></span><br><span class="line">        keepAliveConnections = p.findInt(<span class="string">&quot;max&quot;</span>, usingProxy?<span class="number">50</span>:<span class="number">5</span>);</span><br><span class="line">        keepAliveTimeout = p.findInt(<span class="string">&quot;timeout&quot;</span>, usingProxy?<span class="number">60</span>:<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Keep-Alive 헤더를 파싱해서 max(커넥션 재활용 가능 횟수), timeout(응답 이후 커넥션 유지 기간) 파라미터의 값을 가져오고 있는데 proxy를 쓰지 않는다는 가정하에 둘 다 기본값이 5이다.<br>그리고 이번에는 finished 메서드를 봐보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> <span class="keyword">extends</span> <span class="title">NetworkClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return it to the cache as still usable, if:</span></span><br><span class="line"><span class="comment">     * 1) It&#x27;s keeping alive, AND</span></span><br><span class="line"><span class="comment">     * 2) It still has some connections left, AND</span></span><br><span class="line"><span class="comment">     * 3) It hasn&#x27;t had a error (PrintStream.checkError())</span></span><br><span class="line"><span class="comment">     * 4) It hasn&#x27;t timed out</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If this client is not keepingAlive, it should have been</span></span><br><span class="line"><span class="comment">     * removed from the cache in the parseHeaders() method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reuse) <span class="comment">/* will be reused */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        keepAliveConnections--;</span><br><span class="line">        poster = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (keepAliveConnections &gt; <span class="number">0</span> &amp;&amp; isKeepingAlive() &amp;&amp;</span><br><span class="line">               !(serverOutput.checkError())) &#123;</span><br><span class="line">            <span class="comment">/* This connection is keepingAlive &amp;&amp; still valid.</span></span><br><span class="line"><span class="comment">             * Return it to the cache.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            putInKeepAliveCache();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putInKeepAliveCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inCache) &#123;</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span> : <span class="string">&quot;Duplicate put to keep alive cache&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inCache = <span class="keyword">true</span>;</span><br><span class="line">        kac.put(url, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>keepAliveConnections(max 파라미터)에서 하나 까고 커넥션 재사용 횟수가 아직 남아있다면 KeepAliveCache에 집어넣고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveCache</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">KeepAliveKey</span>, <span class="title">ClientVector</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register this URL and HttpClient (that supports keep-alive) with the cache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url  The URL contains info about the host and port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http The HttpClient to be cached</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> URL url, Object obj, HttpClient http)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        KeepAliveKey key = <span class="keyword">new</span> KeepAliveKey(url, obj);</span><br><span class="line">        ClientVector v = <span class="keyword">super</span>.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> keepAliveTimeout = http.getKeepAliveTimeout();</span><br><span class="line">            v = <span class="keyword">new</span> ClientVector(keepAliveTimeout &gt; <span class="number">0</span>?</span><br><span class="line">                                 keepAliveTimeout*<span class="number">1000</span> : LIFETIME);</span><br><span class="line">            v.put(http);</span><br><span class="line">            <span class="keyword">super</span>.put(key, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v.put(http);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientVector</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Stack</span>&lt;<span class="title">KeepAliveEntry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* return a still valid, unused HttpClient */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(HttpClient h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() &gt;= KeepAliveCache.getMaxConnections()) &#123;</span><br><span class="line">            h.closeServer(); <span class="comment">// otherwise the connection remains in limbo</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            push(<span class="keyword">new</span> KeepAliveEntry(h, System.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClientVector(커넥션 풀)의 사이즈가 KeepAliveCache의 maxConnections보다 작지 않으면 커넥션을 바로 끊고 있다.<br>그게 아니면 커넥션 풀에 여유가 있다는 거니 밀어넣고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveCache</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">KeepAliveKey</span>, <span class="title">ClientVector</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2937172892064557949L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maximum # keep-alive connections to maintain at once</span></span><br><span class="line"><span class="comment">     * This should be 2 by the HTTP spec, but because we don&#x27;t support pipe-lining</span></span><br><span class="line"><span class="comment">     * a larger value is more appropriate. So we now set a default of 5, and the value</span></span><br><span class="line"><span class="comment">     * refers to the number of idle connections per destination (in the cache) only.</span></span><br><span class="line"><span class="comment">     * It can be reset by setting system property &quot;http.maxConnections&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CONNECTIONS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxConnections</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">            result = java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> sun.security.action.GetIntegerAction(<span class="string">&quot;http.maxConnections&quot;</span>,</span><br><span class="line">                                                         MAX_CONNECTIONS))</span><br><span class="line">                .intValue();</span><br><span class="line">            <span class="keyword">if</span> (result &lt;= <span class="number">0</span>)</span><br><span class="line">                result = MAX_CONNECTIONS;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>커넥션 풀의 최대 사이즈는 기본값이 5이고, http.maxConnections이라는 시스템 프로퍼티를 사용한다는 것을 알 수 있다.  </p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>사실 맨 상단에 있는 N줄 요약이 결론이나 다름없다.<br>다만 왜 커넥션이 5개가 넘어가면 커넥션을 바로 끊었는지, route(프로토콜, 호스트, 포트)가 다르다면 커넥션이 5개가 넘어가도 왜 커넥션이 유지되었는지 알게 되어 좋았다.<br>하지만 SimpleClientHttpRequestFactory는 다양한 단점 때문에 실무에서 쓸만한 수준이 아닌데 괜히 깊게 판 것 같아서 시간이 좀 아깝다는 생각도 많이 들었다. (앞으로 좀 쓸 데 없어보이면 적당히만 파보고 더 가치있는 것을 딥하게 파야겠다.)  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;N줄-요약&quot;&gt;&lt;a href=&quot;#N줄-요약&quot; class=&quot;headerlink&quot; title=&quot;N줄 요약&quot;&gt;&lt;/a&gt;N줄 요약&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html&quot;&gt;SimpleClientHttpRequestFactory&lt;/a&gt;(RestTemplate을 기본생성자로 만들었을 때 사용하는)를 사용하더라도 내부에서 &lt;a href=&quot;https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/net/www/http/KeepAliveCache.java&quot;&gt;KeepAliveCache&lt;/a&gt;를 사용하여 커넥션 풀을 관리한다.&lt;br&gt;기본적으로 &lt;a href=&quot;https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/net/www/http/KeepAliveCache.java#L295&quot;&gt;KeepAliveKey(protocol, host, port)&lt;/a&gt; 당 5개의 풀을 가지며 시스템 프로퍼티 &lt;code&gt;http.maxConnections&lt;/code&gt;를 할당해주면 늘릴 수 있다.&lt;br&gt;커넥션 풀을 초과하면 커넥션은 바로 종료되며, 커넥션 풀 내의 커넥션은 매번 연결을 맺고 끊는 게 아니라 재사용 된다.&lt;br&gt;당연하게도 서버에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive&quot;&gt;Keep-Alive&lt;/a&gt;를 사용하지 않으면 매번 커넥션이 종료된다.&lt;br&gt;그럼에도 불구하고 SimpleClientHttpRequestFactory는 다음의 단점이 있기 때문에 토이 프로젝트가 아닌 이상 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html&quot;&gt;HttpComponentsClientHttpRequestFactory&lt;/a&gt; 같은 다른 구현체를 사용해야할 것 같다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http.maxConnections라는 시스템 프로퍼티를 설정해야하는데 설정을 위해 자주 사용하던 properties(yml)에는 설정할 수 없다보니 다른 방법으로 설정을 해줘야하고, 그러다 보면 설정을 파악하려면 한 군데(properties 또는 yml)만 집중해서는 파악할 수 없는 내용도 있다보니 실수할 여지가 발생할 수 있다.  &lt;/li&gt;
&lt;li&gt;KeepAliveCache가 static 변수이다보니 서로 다른 SimpleClientHttpRequestFactory여도 동일한 커넥션 풀을 참조한다.&lt;/li&gt;
&lt;li&gt;route(프로토콜, 호스트, 포트) 별 커넥션 풀은 설정할 수 있지만 토탈 커넥션 풀은 제한이 없다. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SimpleClientHttpRequestFactory가-뭐지&quot;&gt;&lt;a href=&quot;#SimpleClientHttpRequestFactory가-뭐지&quot; class=&quot;headerlink&quot; title=&quot;SimpleClientHttpRequestFactory가 뭐지??&quot;&gt;&lt;/a&gt;SimpleClientHttpRequestFactory가 뭐지??&lt;/h2&gt;&lt;p&gt;RestTemplate의 기본 생성자를 사용하면 ClientHttpRequestFactory를 별도로 초기화하지 않으므로 기본값인 SimpleClientHttpRequestFactory를 사용한다.&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/categories/Spring-Boot/"/>
    
    
    <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/tags/Spring-Boot/"/>
    
    <category term="RestTemplate" scheme="https://perfectacle.github.io/tags/RestTemplate/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Test에서 Test Configuration 감지하기</title>
    <link href="https://perfectacle.github.io/2020/12/27/detecting-test-configuration-in-spring-boot-test/"/>
    <id>https://perfectacle.github.io/2020/12/27/detecting-test-configuration-in-spring-boot-test/</id>
    <published>2020-12-26T18:00:37.000Z</published>
    <updated>2020-12-26T21:13:19.657Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-detecting-config">Spring Boot Reference의 Testing - Detecting Test Configuration 파트</a>를 보면 다음과 같은 내용이 나온다.  </p><blockquote><p>If you are familiar with the Spring Test Framework, you may be used to using @ContextConfiguration(classes=…​) in order to specify which Spring @Configuration to load. Alternatively, you might have often used nested @Configuration classes within your test.<br>When testing Spring Boot applications, this is often not required. Spring Boot’s @*Test annotations search for your primary configuration automatically whenever you do not explicitly define one.<br>The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration.</p></blockquote><p>Detecting Test Configuration을 위해서 스프링에 친숙하다면 @ContextConfiguration이나 Nested @Configuration이 필요하다고 하고,<br>Spring Boot를 사용하면 @*Test(@SpringBootTest, @WebMvcTest, @DataJpaTest, etc.)에서 별다른 설정을 하지 않았다면 primary configuration을 찾아나간다고 한다.  </p><h2 id="N줄-요약"><a href="#N줄-요약" class="headerlink" title="N줄 요약"></a>N줄 요약</h2><p>글이 길어지다보니 아무도 안 볼 거 같고, 집중을 하고 소스코드를 따라가면서 읽어야해서 우선 먼저 요약을 적어놓는다.</p><p>TestContext를 로딩하기 위한 Test Configuaration은 다음과 같은 우선순위를 가진다.</p><ol><li>@ContextConfiguration 또는 @ContextHierarchy(여러 @ContextConfiguration을 포함)</li><li>Nested @Configuration</li><li>@SpringBootConfiguration (@SpringBootApplication 어노테이션이 @SpringBootConfiguration 어노테이션을 포함하고 있음)</li><li>Nested @TestConfiguration</li></ol><p>1, 2, 3 중 하나는 필수이며 셋 중에 하나만 적용된다.<br>Nested @TestConfiguration은 @ContextConfiguration을 사용했을 때는 적용되지 않고, Nested @Configuration이나 @SpringBootConfiguration에 추가로 적용된다고 보면 된다.<br>Nested @Configuration은 여러 개 만들어도 전부 적용되고, Nested @TestConfiguration도 여러 개 만들어도 전부 추가로 적용된다. </p><h2 id="ContextConfiguration"><a href="#ContextConfiguration" class="headerlink" title="@ContextConfiguration"></a>@ContextConfiguration</h2><p><a href="https://spring.io/blog/2011/06/21/spring-3-1-m2-testing-with-configuration-classes-and-profiles">Spring 3.1</a>에 추가된 기능으로 해당 블로그를 보면 아래와 같이 나와있다.</p><blockquote><p>At its core, the TestContext framework allows you to annotate test classes with @ContextConfiguration to specify which configuration files to use to load the ApplicationContext for your test.</p></blockquote><p>@ContextConfiguration 어노테이션에 기술한 configuration file들이 ApplicationContext에 로딩되는 걸 TestContext framework에서 해준다는 내용이다.<br>그럼 @ContextConfiguration에 기술할 수 있는 configuration file에는 무엇이 있을까?<br><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ContextConfiguration.html">ContextConfiguration Javadoc</a>을 보면 다음과 같이 나와있다.  </p><blockquote><p>Component Classes<br>  The term component class can refer to any of the following.<br>  -A class annotated with @Configuration<br>  -A component (i.e., a class annotated with @Component, @Service, @Repository, etc.)<br>  -A JSR-330 compliant class that is annotated with javax.inject annotations<br>  -Any class that contains @Bean-methods<br>  -Any other class that is intended to be registered as a Spring component (i.e., a Spring bean in the ApplicationContext), potentially taking advantage of automatic autowiring of a single constructor without the use of Spring annotations</p></blockquote><p>빈에 관련된 설정(@Configuration) 파일이나 빈에 등록될 수 있는 어노테이션(@Component, @Service, @Repository 등등)은 기본적으로 기술할 수 있다고 보면 된다.</p><p>테스트 코드를 통해 간단히 확인해보자<br>우선 src/main에 인터페이스를 하나 만들자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SomeInterface</span></span></span><br></pre></td></tr></table></figure><p>그리고 src/test에 구현체를 하나 만들어주자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInterfaceInContextConfiguration</span> : <span class="type">SomeInterface</span></span></span><br></pre></td></tr></table></figure><p>이제 테스트 클래스를 작성해서 @ContextConfiguration의 간단한 동작을 검증해보자.<br>참고로 Spring Boot 2.1.x 미만에서는 @ExtendWith(SpringExtension::class)를 추가해줘야한다.<br>또한 Spring Boot 2.2.x 미만에서는 @TestConstructor 어노테이션이 없기 때문에 생성자 안의 파라미터 마다 @Autowired 어노테이션을 추가해줘야한다.<br>그리고 JUnit 4에서는 Field Injection 밖에 지원하지 않기 때문에 Constructor Injection을 사용하려면 JUnit 5를 사용해야한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = [SomeInterfaceInContextConfiguration::class])</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextConfigurationTest2</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface: SomeInterface</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `@ContextConfiguration에 기술된 Component Classes들이 Test Configuration으로 사용된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 어떻게 동작하는지 하나씩 찾아나가보자.<br><a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTest.java#L81">@SpringBootTest 어노테이션</a>을 보면 그 안에 @ExtendWith(SpringExtension.class) 어노테이션이 포함돼있다.<br>또한 @BootstrapWith 어노테이션을 통해 어떤 클래스를 통해 Spring TestContext Framework를 부트스트랩할 지 명시하고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(SpringBootTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootTest &#123;</span><br></pre></td></tr></table></figure><p>그리고 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L113">SpringExtension 클래스의 beforeAll 메서드</a>를 보면 testContextManager를 가져오고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAll</span><span class="params">(ExtensionContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    getTestContextManager(context).beforeTestClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 그 안에서 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L294">TestContextManager를 초기화</a>하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TestContextManager <span class="title">getTestContextManager</span><span class="params">(ExtensionContext context)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(context, <span class="string">&quot;ExtensionContext must not be null&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; testClass = context.getRequiredTestClass();</span><br><span class="line">    Store store = getStore(context);</span><br><span class="line">    <span class="keyword">return</span> store.getOrComputeIfAbsent(testClass, TestContextManager::<span class="keyword">new</span>, TestContextManager.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/TestContextManager.java#L122">TestContextManager 생성자</a>에서는 TestContextBootstrapper를 resolving하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestContextManager</span><span class="params">(Class&lt;?&gt; testClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(BootstrapUtils.resolveTestContextBootstrapper(BootstrapUtils.createBootstrapContext(testClass)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/BootstrapUtils.java#L130">BootstrapUtils.resolveTestContextBootstrapper 메서드 안에서는 resolveExplicitTestContextBootstrapper 메서드를 호출</a>하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TestContextBootstrapper <span class="title">resolveTestContextBootstrapper</span><span class="params">(BootstrapContext bootstrapContext)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; testClass = bootstrapContext.getTestClass();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clazz = resolveExplicitTestContextBootstrapper(testClass);</span><br></pre></td></tr></table></figure><p>resolveExplicitTestContextBootstrapper 메서드를 보면 testClass에 달려있는 BootstrapWith 어노테이션을 사용하는 걸 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; resolveExplicitTestContextBootstrapper(Class&lt;?&gt; testClass) &#123;</span><br><span class="line">    Set&lt;BootstrapWith&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    AnnotationDescriptor&lt;BootstrapWith&gt; descriptor =</span><br><span class="line">            TestContextAnnotationUtils.findAnnotationDescriptor(testClass, BootstrapWith.class);</span><br><span class="line">    <span class="keyword">while</span> (descriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        annotations.addAll(descriptor.findAllLocalMergedAnnotations());</span><br><span class="line">        descriptor = descriptor.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (annotations.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (annotations.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> annotations.iterator().next().value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow directly-present annotation to override annotations that are meta-present.</span></span><br><span class="line">    BootstrapWith bootstrapWith = testClass.getDeclaredAnnotation(BootstrapWith.class);</span><br><span class="line">    <span class="keyword">if</span> (bootstrapWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bootstrapWith.value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">            <span class="string">&quot;Configuration error: found multiple declarations of @BootstrapWith for test class [%s]: %s&quot;</span>,</span><br><span class="line">            testClass.getName(), annotations));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>testClass에 BootstrapWith 어노테이션을 찾는다.  </li><li>없으면 null을 반환한다.</li><li>하나만 있으면 어노테이션의 value에 기술된 TestContextBootstrapper 클래스를 반환한다.</li><li>두 개 이상이면 테스트 클래스에 직접적으로 기술된 BootstrapWith 어노테이션을 찾는다.</li><li>있으면 value에 기술된 TestContextBootstrapper 클래스를 반환한다.</li><li>없으면 우선순위 충돌로 인해 multiple @BootstrapWith 어노테이션을 발견했다는 에러를 반환한다.</li></ol><p>우리는 @SpringBootTest 어노테이션에 있는 @BootstrapWith(SpringBootTestContextBootstrapper.class) 하나만 기술돼있기 때문에 SpringBootTestContextBootstrapper가 반환된다 </p><p>이제 testContextBootstrapper를 구했으면 인자로 넘겨서 TestContextManager를 초기화 하고 있는데 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/TestContextManager.java#L136">TestContextManager 생성자</a> 안에서는 testContext를 만들고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestContextManager</span><span class="params">(TestContextBootstrapper testContextBootstrapper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.testContext = testContextBootstrapper.buildTestContext();</span><br><span class="line">    registerTestExecutionListeners(testContextBootstrapper.getTestExecutionListeners());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 메서드를 쭉쭉 타고 들어가다보면 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/support/AbstractTestContextBootstrapper.java#L265">AbstractTestContextBootstrapper 클래스의 buildMergedContextConfiguration 메서드에서 ContextConfiguration 어노테이션 유무를 판단</a>하고 처리하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MergedContextConfiguration <span class="title">buildMergedContextConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; testClass = getBootstrapContext().getTestClass();</span><br><span class="line">    CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate = getCacheAwareContextLoaderDelegate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TestContextAnnotationUtils.findAnnotationDescriptorForTypes(</span><br><span class="line">            testClass, ContextConfiguration.class, ContextHierarchy.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> buildDefaultMergedContextConfiguration(testClass, cacheAwareContextLoaderDelegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TestContextAnnotationUtils.findAnnotationDescriptor(testClass, ContextHierarchy.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildMergedContextConfiguration(testClass,</span><br><span class="line">                            ContextLoaderUtils.resolveContextConfigurationAttributes(testClass),</span><br><span class="line">                            <span class="keyword">null</span>, cacheAwareContextLoaderDelegate, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>testClass에 ContextConfiguration 어노테이션이나 ContextHierarchy 어노테이션이 포함됐는지 확인한다.</li><li>포함됐으면 ContextHierarchy 어노테이션이 포함됐는지 확인 후에 처리한 걸 반환한다.</li><li>ContextConfiguration 어노테이션이 포함됐는지 확인 후에 처리한 걸 반환한다.  </li></ol><p>3번에 의해 동작이 되는 거라고 보면 된다.<br>@ContextHierarchy 어노테이션은 @ContextConfiguration을 배열로 가지는 어노테이션으로 여러 @ContextConfiguration이 필요할 때 사용하면 된다.</p><h2 id="Nested-Configuration"><a href="#Nested-Configuration" class="headerlink" title="Nested @Configuration"></a>Nested @Configuration</h2><p>우선 동작하는 코드를 간단히 살펴보자.<br>src/test에 인터페이스의 구현체를 하나 더 추가해보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInterfaceInNestedConfiguration</span> : <span class="type">SomeInterface</span></span></span><br></pre></td></tr></table></figure><p>그리고 테스트 코드를 통해 검증해보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedConfigurationTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface: SomeInterface</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">someInterface</span><span class="params">()</span></span> = SomeInterfaceInNestedConfiguration()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `@ContextConfiguration 어노테이션 다음으로는 Nested @Configuration 클래스가 Test Configuration으로 사용된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInNestedConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 실제로 어떻게 동작하는지 또 알아보자.<br>기본적으로 위에 설정한 동작방식 그대로를 쫓아가다가 분기문에서 갈라진다고 보면 된다.<br><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/support/AbstractTestContextBootstrapper.java#L265">AbstractTestContextBootstrapper 클래스의 buildMergedContextConfiguration 메서드에서 ContextConfiguration 어노테이션 유무를 판단</a>하고 있는 걸 위에서 살펴보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MergedContextConfiguration <span class="title">buildMergedContextConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; testClass = getBootstrapContext().getTestClass();</span><br><span class="line">    CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate = getCacheAwareContextLoaderDelegate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TestContextAnnotationUtils.findAnnotationDescriptorForTypes(</span><br><span class="line">            testClass, ContextConfiguration.class, ContextHierarchy.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> buildDefaultMergedContextConfiguration(testClass, cacheAwareContextLoaderDelegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리 클래스에서는 해당 어노테이션이 없기 때문에 buildDefaultMergedContextConfiguration 메서드를 쭉쭉 타고 보면 <a href="https://github.com/spring-projects/spring-framework/blob/885f6dbab94712fa76545276058a62216e17881e/spring-test/src/main/java/org/springframework/test/context/support/AbstractTestContextBootstrapper.java#L338">buildMergedContextConfiguration 메서드</a>까지 가게 된다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MergedContextConfiguration buildMergedContextConfiguration(Class&lt;?&gt; testClass,</span><br><span class="line">        List&lt;ContextConfigurationAttributes&gt; configAttributesList, <span class="meta">@Nullable</span> MergedContextConfiguration parentConfig,</span><br><span class="line">        CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,</span><br><span class="line">        boolean requireLocationsClassesOrInitializers) &#123;</span><br><span class="line"></span><br><span class="line">    Assert.notEmpty(configAttributesList, <span class="string">&quot;ContextConfigurationAttributes list must not be null or empty&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @BootstrapWith(SpringBootTestContextBootstrapper.class)에 의해 SpringBootTestContextBootstrapper의 getDefaultContextLoaderClass 메서드를 호출하여</span></span><br><span class="line">    <span class="comment">// SpringBootContextLoader가 resolving 됨</span></span><br><span class="line">    ContextLoader contextLoader = resolveContextLoader(testClass, configAttributesList); </span><br><span class="line">    List&lt;String&gt; locations = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; initializers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ContextConfigurationAttributes configAttributes : configAttributesList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(String.format(<span class="string">&quot;Processing locations and classes for context configuration attributes %s&quot;</span>,</span><br><span class="line">                    configAttributes));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contextLoader instanceof SmartContextLoader) &#123;  <span class="comment">// SpringBootContextLoader는 SmartContextLoader의 구현체이다 </span></span><br><span class="line">            SmartContextLoader smartContextLoader = (SmartContextLoader) contextLoader;</span><br><span class="line">            smartContextLoader.processContextConfiguration(configAttributes);</span><br></pre></td></tr></table></figure><p>그리고 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootContextLoader.java#L204">SpringBootContextLoader의 processContextConfiguration 메서드를 보면 detectDefaultConfigurationClasses를 호출</a>하고 있다.<br>(우리의 테스트 코드에서는 resource가 비어있는데 그거까지 이 포스트에서 다루기에는 너무 방대해져서 생략했다.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processContextConfiguration</span><span class="params">(ContextConfigurationAttributes configAttributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.processContextConfiguration(configAttributes);</span><br><span class="line">    <span class="keyword">if</span> (!configAttributes.hasResources()) &#123;</span><br><span class="line">        Class&lt;?&gt;[] defaultConfigClasses = detectDefaultConfigurationClasses(configAttributes.getDeclaringClass());</span><br><span class="line">        configAttributes.setClasses(defaultConfigClasses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메서드를 또 쭉쭉 타고 들어가다 보면 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/support/AnnotationConfigContextLoaderUtils.java#L62">AnnotationConfigContextLoaderUtils 클래스의 detectDefaultConfigurationClasses 메서드</a>를 호출하고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt;[] detectDefaultConfigurationClasses(Class&lt;?&gt; declaringClass) &#123;</span><br><span class="line">    Assert.notNull(declaringClass, <span class="string">&quot;Declaring class must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; configClasses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; candidate : declaringClass.getDeclaredClasses()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDefaultConfigurationClassCandidate(candidate)) &#123;</span><br><span class="line">            configClasses.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    <span class="keyword">return</span> ClassUtils.toClassArray(configClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 그 안에는 testClass(declaringClass)에 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredClasses--">getDeclaredClasses 메서드</a>를 호출하고 있다.<br>해당 메서드는 클래스에 정의된 클래스 객체를 반환하는 메서드라고 보면 된다.<br>따라서 Nested class들을 전부 반환하게 되는데 이 class 들을 for-loop 돌면서 isDefaultConfigurationClassCandidate 메서드를 호출해서 DefaultConfigurationClassCandidate라면 추가한 후에 반환하고 있다.</p><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/support/AnnotationConfigContextLoaderUtils.java#L107">isDefaultConfigurationClassCandidate 메서드</a>를 보면 static이면서 private이 아니고, final이 아닌 클래스인데 @Configuration 어노테이션이 붙어있는지 판단하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDefaultConfigurationClassCandidate</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (clazz != <span class="keyword">null</span> &amp;&amp; isStaticNonPrivateAndNonFinal(clazz) &amp;&amp;</span><br><span class="line">            AnnotatedElementUtils.hasAnnotation(clazz, Configuration.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 Nested @Configuration 클래스를 추가했으면 그 다음에 또 메서드를 쭉쭉 타고 들어가다보면 <a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTestContextBootstrapper.java#L229">SpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드</a>를 호출하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) &#123;</span><br><span class="line">    Class&lt;?&gt;[] classes = mergedConfig.getClasses();</span><br><span class="line">    <span class="keyword">if</span> (containsNonTestComponent(classes) || mergedConfig.hasLocations()) &#123;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTestContextBootstrapper.java#L242">containsNonTestComponent 메서드</a>에서는 Nested @Configuration classes 중에 @TestConfiguration 어노테이션이 붙지 않은 클래스가 하나라도 존재하면 Nested @Configuration classes들을 merge 하여 Test Configuration으로 사용하고 있다.<br>즉 Nested @Configuration 클래스가 2개여도 두 @Configuration을 하나로 머지하여 사용한다고 보면 된다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNonTestComponent</span><span class="params">(Class&lt;?&gt;[] classes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; candidate : classes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MergedAnnotations.from(candidate, SearchStrategy.INHERITED_ANNOTATIONS)</span><br><span class="line">                .isPresent(TestConfiguration.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>스프링 부트의 primary configuration은 @SpringBootConfiguration이다.<br>하지만 @SpringBootConfiguration을 직접 사용하는 경우는 아직까지 보지 못했고 @SpringBootApplication을 사용하면 그 안에 포함돼있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>src/main에 @SpringBootApplication 클래스를 하나 추가해주자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span></span></span><br></pre></td></tr></table></figure><p>그리고 SomeInterface의 구현체도 하나 작성해주자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInterfaceInConfiguration</span> : <span class="type">SomeInterface</span></span></span><br></pre></td></tr></table></figure><p>해당 클래스를 빈으로 등록해줄 Config 클래스도 작성하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInterfaceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">someInterface</span><span class="params">()</span></span> = SomeInterfaceInConfiguration()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 테스트를 통해 해당 빈이 주입되는지 검증해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootConfigurationTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface: SomeInterface</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `테스트용 설정이 없으면 기본적으로 @SpringBootApplication 클래스가 Test Configuration으로 사용된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 실제로 왜 이렇게 동작하는지 알아보자.<br>위에 살펴봤던 것과 같이 <a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTestContextBootstrapper.java#L229">SpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드</a>를 호출하고 있다.<br>그리고 Nested @Configuration 클래스가 하나라도 존재하는지 containsNonTestComponent 메서드를 통해 검증했었다.<br>하지만 이번에는 하나도 설정한 게 없으므로 그 아래에 있는 부분을 탄다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) &#123;</span><br><span class="line">    Class&lt;?&gt;[] classes = mergedConfig.getClasses();</span><br><span class="line">    <span class="keyword">if</span> (containsNonTestComponent(classes) || mergedConfig.hasLocations()) &#123;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; found = <span class="keyword">new</span> AnnotatedClassFinder(SpringBootConfiguration.class)</span><br><span class="line">            .findFromClass(mergedConfig.getTestClass());</span><br><span class="line">    Assert.state(found != <span class="keyword">null</span>, <span class="string">&quot;Unable to find a @SpringBootConfiguration, you need to use &quot;</span></span><br><span class="line">            + <span class="string">&quot;@ContextConfiguration or @SpringBootTest(classes=...) with your test&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;Found @SpringBootConfiguration &quot;</span> + found.getName() + <span class="string">&quot; for test &quot;</span> + mergedConfig.getTestClass());</span><br><span class="line">    <span class="keyword">return</span> merge(found, classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>nested @Configuration 클래스를 가져온다.</li><li>nested @TestConfiguration이 아닌 nested @Configuration 클래스가 하나라도 존재한다면 nested @Configuration(nested @TestConfiguration 포함) 클래스들을 반환한다.</li><li>@SpringBootConfiguration 어노테이션이 붙은 클래스를 가져온다.  </li><li>3에서 클래스를 찾지 못했다면 @SpringBootConfiguration이 붙은 클래스를 찾지 못하여 @ContextConfiguration이나 @SpringBootTest에 component classes를 명시하라고 에러를 뱉는다.  </li><li>3에서 찾은 클래스와 nested @Configuration 클래스를 머지한다.</li></ol><p>이렇게 nested @Configuration 클래스가 없다면 디폴트로 @SpringBootConfiguration이 붙은 @SpringBootApplication이 붙은 클래스가 Test Configuration으로 사용된다고 보면 된다.</p><h2 id="Nested-TestConfiguration"><a href="#Nested-TestConfiguration" class="headerlink" title="Nested @TestConfiguration"></a>Nested @TestConfiguration</h2><p><a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTestContextBootstrapper.java#L229">SpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드</a>를 보면 <a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTestContextBootstrapper.java#L242">containsNonTestComponent</a> 메서드를 호출하고 있다.<br>즉, Nested @TestConfiguration이 아닌 Nested @Configuration 클래스가 하나라도 존재하는지 찾는 것인데…<br>Nested @TestConfiguration 클래스는 어떤 역할을 하는 걸까??</p><p>src/test에 SomeInterface의 구현체를 하나 더 추가해보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInterfaceInNestedTestConfiguration</span> : <span class="type">SomeInterface</span></span></span><br></pre></td></tr></table></figure><p>그리고 해당 빈이 주입되도록 Nested @TestConfiguration을 사용하여 테스트를 작성해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedTestConfigurationTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface: SomeInterface,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface2: SomeInterface,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">someInterface2</span><span class="params">()</span></span> = SomeInterfaceInNestedTestConfiguration()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `@SpringBootConfiguration에 의해 src에 있는 @Configuration 클래스에 있는 빈이 주입된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `@SpringBootConfiguration에 없는 건 @TestConfiguration 클래스에 있는 빈이 주입된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface2).isExactlyInstanceOf(SomeInterfaceInNestedTestConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제로 src/main에 있는 @Configuration도 주입되고, Nested @TestConfiguration도 주입된 걸 볼 수 있다.<br>Nested @TestConfiguration의 용도는 원래 Configuration(@SpringBootConfigurtion 또는 Nested @Configuration)에 추가적으로 설정할 Configuration을 위해 사용한다고 보면 된다.</p><p>위에 살펴봤던 것과 같이 <a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTestContextBootstrapper.java#L229">SpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드</a>를 호출하고 있다.<br>그리고 Nested @Configuration 클래스가 하나라도 존재하는지 containsNonTestComponent 메서드를 통해 검증했었다.<br>이번에는 Nested @TestConfiguration 클래스를 설정했으므로 그 관점에서 바라보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) &#123;</span><br><span class="line">    Class&lt;?&gt;[] classes = mergedConfig.getClasses();</span><br><span class="line">    <span class="keyword">if</span> (containsNonTestComponent(classes) || mergedConfig.hasLocations()) &#123;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; found = <span class="keyword">new</span> AnnotatedClassFinder(SpringBootConfiguration.class)</span><br><span class="line">            .findFromClass(mergedConfig.getTestClass());</span><br><span class="line">    Assert.state(found != <span class="keyword">null</span>, <span class="string">&quot;Unable to find a @SpringBootConfiguration, you need to use &quot;</span></span><br><span class="line">            + <span class="string">&quot;@ContextConfiguration or @SpringBootTest(classes=...) with your test&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;Found @SpringBootConfiguration &quot;</span> + found.getName() + <span class="string">&quot; for test &quot;</span> + mergedConfig.getTestClass());</span><br><span class="line">    <span class="keyword">return</span> merge(found, classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>nested @Configuration 클래스를 가져온다.</li><li>nested @TestConfiguration이 아닌 nested @Configuration 클래스가 하나라도 존재한다면 nested @Configuration(nested @TestConfiguration 포함) 클래스들을 반환한다.</li><li>@SpringBootConfiguration 어노테이션이 붙은 클래스를 가져온다.  </li><li>3에서 클래스를 찾지 못했다면 @SpringBootConfiguration이 붙은 클래스를 찾지 못하여 @ContextConfiguration이나 @SpringBootTest에 component classes를 명시하라고 에러를 뱉는다.  </li><li>3에서 찾은 클래스와 nested @Configuration 클래스를 머지한다.</li></ol><p><a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/TestConfiguration.java#L45">@TestConfiguration 어노테이션</a>이 @Configuration을 포함하고 있으므로 <code>mergedConfig.getClasses()</code>에서는 Nested @Configuration과 Nested @TestConfiguration 클래스가 나온다고 보면 된다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@TestComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestConfiguration &#123;</span><br></pre></td></tr></table></figure><p>그리고 우리는 Nested @Configuration 클래스는 하나도 없으므로 <code>containsNonTestComponent(classes)</code>에서 false를 뱉고<br>그 아래에서 <code>Class&lt;?&gt; found = new AnnotatedClassFinder(SpringBootConfiguration.class).findFromClass(mergedConfig.getTestClass());</code>로 찾아온 @SpringBootApplication 클래스와 Nested @TestConfiguration 클래스가 머지된다고 보면 된다.<br>실제로 <a href="https://github.com/spring-projects/spring-boot/blob/8cd07dbc60f6146891a686967c9209edb053dd38/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTestContextBootstrapper.java#L252">merge()</a> 메서드에서는 두 Configuration들을 머지하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] merge(Class&lt;?&gt; head, Class&lt;?&gt;[] existing) &#123;</span><br><span class="line">    Class&lt;?&gt;[] result = <span class="keyword">new</span> Class&lt;?&gt;[existing.length + <span class="number">1</span>];</span><br><span class="line">    result[<span class="number">0</span>] = head;</span><br><span class="line">    System.arraycopy(existing, <span class="number">0</span>, result, <span class="number">1</span>, existing.length);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>참고로 @ContextConfiguration을 사용할 때는 Nested @Configuration/@TestConfiuration이 먹히지 않는다. (물론 @SpringBootConfiguration도 씹힌다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = [SomeInterfaceInContextConfiguration::class])</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextConfigurationTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface: SomeInterface,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface2: SomeInterface,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> someInterface3: SomeInterface,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">NestConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">someInterface2</span><span class="params">()</span></span> = SomeInterfaceInNestedConfiguration()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedTestConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">someInterface3</span><span class="params">()</span></span> = SomeInterfaceInNestedTestConfiguration()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `@ContextConfiguration에 기술된 Component Classes들이 Test Configuration으로 사용된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `@ContextConfiguratio을 적용했으면 Nested @Configuration은 무시된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface2).isNotExactlyInstanceOf(SomeInterfaceInNestedConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">        assertThat(someInterface2).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `@ContextConfiguratio을 적용했으면 Nested @TestConfiguration은 무시된다`<span class="params">()</span></span> &#123;</span><br><span class="line">        assertThat(someInterface3).isNotExactlyInstanceOf(SomeInterfaceInNestedTestConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">        assertThat(someInterface3).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-detecting-config&quot;&gt;Spring Boot Reference의 Testing - Detecting Test Configuration 파트&lt;/a&gt;를 보면 다음과 같은 내용이 나온다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are familiar with the Spring Test Framework, you may be used to using @ContextConfiguration(classes=…​) in order to specify which Spring @Configuration to load. Alternatively, you might have often used nested @Configuration classes within your test.&lt;br&gt;When testing Spring Boot applications, this is often not required. Spring Boot’s @*Test annotations search for your primary configuration automatically whenever you do not explicitly define one.&lt;br&gt;The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Detecting Test Configuration을 위해서 스프링에 친숙하다면 @ContextConfiguration이나 Nested @Configuration이 필요하다고 하고,&lt;br&gt;Spring Boot를 사용하면 @*Test(@SpringBootTest, @WebMvcTest, @DataJpaTest, etc.)에서 별다른 설정을 하지 않았다면 primary configuration을 찾아나간다고 한다.  &lt;/p&gt;
&lt;h2 id=&quot;N줄-요약&quot;&gt;&lt;a href=&quot;#N줄-요약&quot; class=&quot;headerlink&quot; title=&quot;N줄 요약&quot;&gt;&lt;/a&gt;N줄 요약&lt;/h2&gt;&lt;p&gt;글이 길어지다보니 아무도 안 볼 거 같고, 집중을 하고 소스코드를 따라가면서 읽어야해서 우선 먼저 요약을 적어놓는다.&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/tags/Spring-Boot/"/>
    
    <category term="Test" scheme="https://perfectacle.github.io/tags/Test/"/>
    
    <category term="JUnit" scheme="https://perfectacle.github.io/tags/JUnit/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ (Spring Boot) vs Gradle (bootRun)에서 클래스패스의 차이점</title>
    <link href="https://perfectacle.github.io/2020/12/26/intellij-vs-gradle-in-classpath/"/>
    <id>https://perfectacle.github.io/2020/12/26/intellij-vs-gradle-in-classpath/</id>
    <published>2020-12-26T07:56:41.000Z</published>
    <updated>2020-12-26T08:02:53.645Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly(<span class="string">&quot;org.springframework.boot:spring-boot-starter-web:2.4.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/intellij-vs-gradle-in-classpath/classpath.png" alt="compileOnly는 compile classpath에만 추가된다."><br>runtime classpath에는 추가되지 않아서 원래는 <code>java.lang.ClassNotFoundException</code>이 나야 정상이다.<br>하지만 IntelliJ의 Spring Boot Configuration으로 실행하면 실행이 잘만 된다.</p><p><img src="/images/intellij-vs-gradle-in-classpath/spring-boot-intellij-configuration.png"><br>실제로 classpath를 찍어보면 아래와 같이 spring-boot-starter-web을 포함하고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> property = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>)</span><br><span class="line">    println(property)</span><br><span class="line">    runApplication&lt;DemoApplication&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;IdeaProjects&#x2F;demo&#x2F;build&#x2F;classes&#x2F;kotlin&#x2F;main:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;IdeaProjects&#x2F;demo&#x2F;build&#x2F;resources&#x2F;main:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains.kotlin&#x2F;kotlin-stdlib-jdk8&#x2F;1.4.10&#x2F;998caa30623f73223194a8b657abd2baec4880ea&#x2F;kotlin-stdlib-jdk8-1.4.10.jar:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web&#x2F;2.4.0&#x2F;4bdd422c370d1d66ffc12ecafdecc70cad406367&#x2F;spring-boot-starter-web-2.4.0.jar:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains.kotlin&#x2F;kotlin-stdlib-jdk7&#x2F;1.4.10&#x2F;30e46450b0bb3dbf43898d2f461be4a942784780&#x2F;kotlin-stdlib-jdk7-1.4.10.jar:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains.kotlin&#x2F;kotlin-stdlib&#x2F;1.4.10&#x2F;ea29e063d2bbe695be13e9d044dcfb0c7add398e&#x2F;kotlin-stdlib-1.4.10.jar:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>하지만 spring boot gradle plugin을 사용하여 bootRun Task를 실행하면 클래스패스가 아래와 같이 spring-boot-starter-web을 포함하고 있지 않는다.<br><img src="/images/intellij-vs-gradle-in-classpath/gradle-boot-run-task.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;IdeaProjects&#x2F;demo&#x2F;build&#x2F;classes&#x2F;java&#x2F;main:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;IdeaProjects&#x2F;demo&#x2F;build&#x2F;classes&#x2F;kotlin&#x2F;main:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;IdeaProjects&#x2F;demo&#x2F;build&#x2F;resources&#x2F;main:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains.kotlin&#x2F;kotlin-stdlib-jdk8&#x2F;1.4.10&#x2F;998caa30623f73223194a8b657abd2baec4880ea&#x2F;kotlin-stdlib-jdk8-1.4.10.jar:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains.kotlin&#x2F;kotlin-stdlib-jdk7&#x2F;1.4.10&#x2F;30e46450b0bb3dbf43898d2f461be4a942784780&#x2F;kotlin-stdlib-jdk7-1.4.10.jar:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains.kotlin&#x2F;kotlin-stdlib&#x2F;1.4.10&#x2F;ea29e063d2bbe695be13e9d044dcfb0c7add398e&#x2F;kotlin-stdlib-1.4.10.jar:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains.kotlin&#x2F;kotlin-stdlib-common&#x2F;1.4.10&#x2F;6229be3465805c99db1142ad75e6c6ddeac0b04c&#x2F;kotlin-stdlib-common-1.4.10.jar:</span><br><span class="line">&#x2F;Users&#x2F;perfectacle&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.jetbrains&#x2F;annotations&#x2F;13.0&#x2F;919f0dfe192fb4e063e7dacadee7f8bb9a2672a9&#x2F;annotations-13.0.jar</span><br></pre></td></tr></table></figure><p>실제 build된 jar 파일을 실행했을 때는 classpath 내에 spring-boot-starter-web jar 파일이 없기 때문에 서버가 뜨지도 않기 때문에 bootRun task의 클래스패스가 더 리얼월드에 가깝다.<br>따라서 인텔리제이에서 돌려봤을 때 서버 뜬다고 신나하면 안 되고 gradle의 bootRun task까지 돌려봐야 가장 정확할 것 같다. (test code도 마찬가지일 듯??)</p>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compileOnly(&lt;span class=&quot;string&quot;&gt;&amp;quot;org.springframework.boot:spring-boot-starter-web:2.4.0&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/images/intellij-vs-gradle-in-classpath/classpath.png&quot; alt=&quot;compileOnly는 compile classpath에만 추가된다.&quot;&gt;&lt;br&gt;runtime classpath에는 추가되지 않아서 원래는 &lt;code&gt;java.lang.ClassNotFoundException&lt;/code&gt;이 나야 정상이다.&lt;br&gt;하지만 IntelliJ의 Spring Boot Configuration으로 실행하면 실행이 잘만 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/intellij-vs-gradle-in-classpath/spring-boot-intellij-configuration.png&quot;&gt;&lt;br&gt;실제로 classpath를 찍어보면 아래와 같이 spring-boot-starter-web을 포함하고 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; property = System.getProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;java.class.path&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(property)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runApplication&amp;lt;DemoApplication&amp;gt;(*args)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;Users&amp;#x2F;perfectacle&amp;#x2F;IdeaProjects&amp;#x2F;demo&amp;#x2F;build&amp;#x2F;classes&amp;#x2F;kotlin&amp;#x2F;main:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;Users&amp;#x2F;perfectacle&amp;#x2F;IdeaProjects&amp;#x2F;demo&amp;#x2F;build&amp;#x2F;resources&amp;#x2F;main:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;Users&amp;#x2F;perfectacle&amp;#x2F;.gradle&amp;#x2F;caches&amp;#x2F;modules-2&amp;#x2F;files-2.1&amp;#x2F;org.jetbrains.kotlin&amp;#x2F;kotlin-stdlib-jdk8&amp;#x2F;1.4.10&amp;#x2F;998caa30623f73223194a8b657abd2baec4880ea&amp;#x2F;kotlin-stdlib-jdk8-1.4.10.jar:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;Users&amp;#x2F;perfectacle&amp;#x2F;.gradle&amp;#x2F;caches&amp;#x2F;modules-2&amp;#x2F;files-2.1&amp;#x2F;org.springframework.boot&amp;#x2F;spring-boot-starter-web&amp;#x2F;2.4.0&amp;#x2F;4bdd422c370d1d66ffc12ecafdecc70cad406367&amp;#x2F;spring-boot-starter-web-2.4.0.jar:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;Users&amp;#x2F;perfectacle&amp;#x2F;.gradle&amp;#x2F;caches&amp;#x2F;modules-2&amp;#x2F;files-2.1&amp;#x2F;org.jetbrains.kotlin&amp;#x2F;kotlin-stdlib-jdk7&amp;#x2F;1.4.10&amp;#x2F;30e46450b0bb3dbf43898d2f461be4a942784780&amp;#x2F;kotlin-stdlib-jdk7-1.4.10.jar:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;Users&amp;#x2F;perfectacle&amp;#x2F;.gradle&amp;#x2F;caches&amp;#x2F;modules-2&amp;#x2F;files-2.1&amp;#x2F;org.jetbrains.kotlin&amp;#x2F;kotlin-stdlib&amp;#x2F;1.4.10&amp;#x2F;ea29e063d2bbe695be13e9d044dcfb0c7add398e&amp;#x2F;kotlin-stdlib-1.4.10.jar:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/categories/Spring-Boot/"/>
    
    
    <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
    <category term="IntelliJ" scheme="https://perfectacle.github.io/tags/IntelliJ/"/>
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/tags/Spring-Boot/"/>
    
    <category term="Gradle" scheme="https://perfectacle.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot + JUnit에서 의존성 주입하기</title>
    <link href="https://perfectacle.github.io/2020/12/25/dependency-injection-in-junit/"/>
    <id>https://perfectacle.github.io/2020/12/25/dependency-injection-in-junit/</id>
    <published>2020-12-24T17:55:29.000Z</published>
    <updated>2020-12-24T17:52:42.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUnt-4"><a href="#JUnt-4" class="headerlink" title="JUnt 4"></a>JUnt 4</h2><p>Field Injection 밖에 되지 않음.<br><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes#junit-5">Spring Boot 2.2.0</a>부터 JUnit 5가 기본으로 탑재되기 시작했고,<br><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.4-Release-Notes#junit-5s-vintage-engine-removed-from-spring-boot-starter-test">Spring Boot 2.4.0</a>부터는 아예 JUnit 4 의존성이 제거됐기 때문에 <code>JUnit 4의 사용은 하지 말아야한다.</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner::class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> a: SomeComponent</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">contextLoad</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUnit-5"><a href="#JUnit-5" class="headerlink" title="JUnit 5"></a>JUnit 5</h2><p>JUnit 5의 <a href="https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/ExtendWith.html">@ExtendedWith</a> 어노테이션을 이용하면 테스트 전/후로 다양한 일을 할 수 있다.<br>@ExtendedWith 어노테이션은 어노테이션에 명시한 <a href="https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/Extension.html">Extension</a>들을 실행하는 역할 뿐이 하지 않는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Extensions.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExtendWith &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * An array of one or more &#123;<span class="doctag">@link</span> Extension&#125; classes to register.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Class&lt;? extends Extension&gt;[] value()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/AfterEachCallback.html">AfterEachCallback</a>과 같은 다양한 Extension 인터페이스들을 직접 개발자가 구현하고 본인이 원하는 Extension만 넣으면 되는 구조다.<br>이렇게 함으로써 전/후 처리 해야되는 내용들은 Extnsion을 통해 직접 구현하고 @ExtendedWith에 기술함으로써 개발자가 좀 더 테스트에 집중할 수 있게 만들어준다.</p><p><a href="https://github.com/spring-projects/spring-boot/blob/2.0.x/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTest.java#L75">@SpringBootTest</a>처럼 어플리케이션 컨텍스트를 로딩해야하는 테스트를 작성할 때 컨텍스트 로딩하는 코드를 직접 테스트 코드에 삽입하지 않고,<br>여러 Extension을 구현한 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L78">SpringExtension</a>을 사용하여 문제를 해결할 수 있다.<br>또한 SpringExtension을 사용하면 Constructor Injection도 지원하는데 SpringExtension이 <a href="https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/ParameterResolver.html">ParameterResolver</a> Extension을 구현했기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtension</span> <span class="keyword">implements</span> <span class="title">BeforeAllCallback</span>, <span class="title">AfterAllCallback</span>, <span class="title">TestInstancePostProcessor</span>,</span></span><br><span class="line"><span class="class">    <span class="title">BeforeEachCallback</span>, <span class="title">AfterEachCallback</span>, <span class="title">BeforeTestExecutionCallback</span>, <span class="title">AfterTestExecutionCallback</span>,</span></span><br><span class="line"><span class="class">       <span class="title">ParameterResolver</span> </span>&#123;</span><br></pre></td></tr></table></figure><blockquote><p>ParameterResolver defines the API for Extensions that wish to dynamically resolve arguments for parameters at runtime.<br>  If a constructor for a test class or a @Test, @BeforeEach, @AfterEach, @BeforeAll, or @AfterAll method declares a parameter, an argument for the parameter must be resolved at runtime by a ParameterResolver.</p></blockquote><p>ParameterResolver는 두 개의 API를 가지고 있는데 해당 파라미터의 리졸빙을 지원하는지를 판단하는 <a href="https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/ParameterResolver.html#supportsParameter-org.junit.jupiter.api.extension.ParameterContext-org.junit.jupiter.api.extension.ExtensionContext-">supportsParameter</a> 메서드와 실제 리졸빙을 하는 <a href="https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/ParameterResolver.html#resolveParameter-org.junit.jupiter.api.extension.ParameterContext-org.junit.jupiter.api.extension.ExtensionContext-">resolveParameter</a> 메서드가 있다.</p><h3 id="Spring-Boot-2-0-x-Spring-5-0-x"><a href="#Spring-Boot-2-0-x-Spring-5-0-x" class="headerlink" title="Spring Boot 2.0.x (Spring 5.0.x)"></a>Spring Boot 2.0.x (Spring 5.0.x)</h3><p><a href="https://github.com/spring-projects/spring-boot/blob/2.0.x/spring-boot-project/spring-boot-dependencies/pom.xml#L156">Spring Boot 2.0.x는 Spring 5.0.x를 사용</a>하기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/5.0.x/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L60">Spring Test 5.0.x의 SpringExtension 클래스</a>를 보면 당연히 ParameterResolver Extension을 구현하였다.<br><a href="https://github.com/spring-projects/spring-framework/blob/5.0.x/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L161">supportsParameter 메서드 로직 중에 @Autowired 어노테이션이 포함돼있는지를 판단</a>하여 지원 여부를 구분하고</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(ParameterContext parameterContext, ExtensionContext extensionContext)</span> </span>&#123;</span><br><span class="line">    Parameter parameter = parameterContext.getParameter();</span><br><span class="line">    <span class="keyword">int</span> index = parameterContext.getIndex();</span><br><span class="line">    Executable executable = parameter.getDeclaringExecutable();</span><br><span class="line">    <span class="keyword">return</span> (executable <span class="keyword">instanceof</span> Constructor &amp;&amp;</span><br><span class="line">        AnnotatedElementUtils.hasAnnotation(executable, Autowired.class)) ||</span><br><span class="line">        ParameterAutowireUtils.isAutowirable(parameter, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-framework/blob/5.0.x/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L179">resolveParameter 메서드에서는 ParameterAutowireUtils.resolveDependency 메서드를 호출</a>하여 실제 리졸빙을 수행하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveParameter</span><span class="params">(ParameterContext parameterContext, ExtensionContext extensionContext)</span> </span>&#123;</span><br><span class="line">    Parameter parameter = parameterContext.getParameter();</span><br><span class="line">    <span class="keyword">int</span> index = parameterContext.getIndex();</span><br><span class="line">    Class&lt;?&gt; testClass = extensionContext.getRequiredTestClass();</span><br><span class="line">    ApplicationContext applicationContext = getApplicationContext(extensionContext);</span><br><span class="line">    <span class="keyword">return</span> ParameterAutowireUtils.resolveDependency(parameter, index, testClass, applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <a href="https://github.com/spring-projects/spring-boot/blob/2.0.x/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTest.java#L75">Spring Boot Test 2.0.x에서는 @SpringBootTest 어노테이션</a>에 @ExtendedWith(SpringExtension.class)가 포함돼있지 않다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(SpringBootTestContextBootstrapper.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootTest &#123;</span><br></pre></td></tr></table></figure><p>따라서 @ExtendedWith(SpringExtension.class)를 무조건 명시해주어야 어플리케이션 컨텍스트가 정상적으로 로딩된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendedWith(SpringExtension::class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeTest</span>(</span></span><br><span class="line"><span class="class">    @<span class="title">Autowired</span></span></span><br><span class="line">    private val a: SomeComponent</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function">fun <span class="title">contextLoad</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-2-1-x-Spring-5-1-x"><a href="#Spring-Boot-2-1-x-Spring-5-1-x" class="headerlink" title="Spring Boot 2.1.x (Spring 5.1.x)"></a>Spring Boot 2.1.x (Spring 5.1.x)</h3><p><a href="https://github.com/spring-projects/spring-boot/blob/2.1.x/spring-boot-project/spring-boot-dependencies/pom.xml#L168">Spring Boot 2.1.x는 Spring 5.1.x를 사용</a>하기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L161">Spring Test 5.1.x의 SpringExtension 클래스의 supportsParameter 메서드를 보면 Autowired 어노테이션이 있는지 비교하는 부분</a>은 똑같아서 큰 변화가 없다.<br>하지만 <a href="https://github.com/spring-projects/spring-boot/blob/2.1.x/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTest.java#L78">Spring Boot Test 2.1.x에서는 @SpringBootTest 어노테이션에 @ExtendedWith(SpringExtension.class)가 포함</a>됐다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(SpringBootTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootTest &#123;</span><br></pre></td></tr></table></figure><p>이는 어플리케이션 컨텍스트를 로딩하는 다른 테스트 <a href="https://github.com/spring-projects/spring-boot/blob/2.1.x/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/web/servlet/WebMvcTest.java#L80">@WebMvcTest</a>, <a href="https://github.com/spring-projects/spring-boot/blob/2.1.x/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/DataJpaTest.java#L75">@DataJpaTest</a>, <a href="https://github.com/spring-projects/spring-boot/blob/2.1.x/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/json/JsonTest.java#L68">@JsonTest</a> 등등과 같은 Slice Test 류에도 동일하게 적용되었다.<br>따라서 테스트를 작성할 때 @ExtendWith가 생략 가능해졌다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeTest</span>(</span></span><br><span class="line"><span class="class">    @<span class="title">Autowired</span></span></span><br><span class="line">    private val a: SomeComponent</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function">fun <span class="title">contextLoad</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-2-2-x-Spring-5-2x"><a href="#Spring-Boot-2-2-x-Spring-5-2x" class="headerlink" title="Spring Boot 2.2.x (Spring 5.2x)"></a>Spring Boot 2.2.x (Spring 5.2x)</h3><p><a href="https://github.com/spring-projects/spring-boot/blob/2.2.x/spring-boot-project/spring-boot-dependencies/pom.xml#L194">Spring Boot 2.2.x는 Spring 5.2.x</a>를 사용하기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L166">Spring Test 5.2.x의 SpringExtension 클래스를 보면 supportsParameter 메서드</a>의 로직이 달라져있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(ParameterContext parameterContext, ExtensionContext extensionContext)</span> </span>&#123;</span><br><span class="line">    Parameter parameter = parameterContext.getParameter();</span><br><span class="line">    Executable executable = parameter.getDeclaringExecutable();</span><br><span class="line">    Class&lt;?&gt; testClass = extensionContext.getRequiredTestClass();</span><br><span class="line">    <span class="keyword">return</span> (TestConstructorUtils.isAutowirableConstructor(executable, testClass) ||</span><br><span class="line">        ApplicationContext.class.isAssignableFrom(parameter.getType()) ||</span><br><span class="line">        ParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>단순히 @Autowired 어노테이션이 있는지 검사하는 게 아니라 <a href="https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-test/src/main/java/org/springframework/test/context/support/TestConstructorUtils.java#L60">TestConstructorUtils.isAutowirableConstructor 메서드</a>를 호출하는 것으로 변하였다. 해당 메서드를 계속 추적하다보면 아래 메서드를 만나게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAutowirableConstructor</span><span class="params">(Constructor&lt;?&gt; constructor, Class&lt;?&gt; testClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is the constructor annotated with @Autowired?</span></span><br><span class="line">    <span class="keyword">if</span> (AnnotatedElementUtils.hasAnnotation(constructor, Autowired.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    AutowireMode autowireMode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the test class annotated with @TestConstructor?</span></span><br><span class="line">    TestConstructor testConstructor = AnnotatedElementUtils.findMergedAnnotation(testClass, TestConstructor.class);</span><br><span class="line">    <span class="keyword">if</span> (testConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        autowireMode = testConstructor.autowireMode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Custom global default?</span></span><br><span class="line">        String value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                autowireMode = AutowireMode.valueOf(value.trim().toUpperCase());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(String.format(<span class="string">&quot;Failed to parse autowire mode &#x27;%s&#x27; for property &#x27;%s&#x27;: %s&quot;</span>, value,</span><br><span class="line">                        TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME, ex.getMessage()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (autowireMode == AutowireMode.ALL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@Autowired 어노테이션이 달려있으면 true를 반환한다.</li><li>autowireMode 변수를 선언하고, null로 초기화한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-test/src/main/java/org/springframework/test/context/TestConstructor.java#L66">@TestConstructor 어노테이션</a>이 달려있는지 확인한다.<ol><li>달려있으면 해당 어노테이션의 autowireMode 프로퍼티를 autowireMode 변수에 할단한다.</li><li>달려있지 않으면 아래 분기를 탄다.<ol><li> 클래스 패스에 있는 spring.properties 파일에서 spring.test.constructor.autowire.mode 프로퍼티를 가져온다.</li><li>프로퍼티를 AutowireMode enum으로 변환해보고 성공하면 autowireMode 변수에 할당한다.</li></ol></li></ol></li><li>autowireMode 변수가 AutowireMode.ALL과 같으면 true, 다르면 false를 반환한다.</li></ol><h4 id="TestConstructor-어노테이션을-통한-Autowired-어노테이션-생략"><a href="#TestConstructor-어노테이션을-통한-Autowired-어노테이션-생략" class="headerlink" title="@TestConstructor 어노테이션을 통한 @Autowired 어노테이션 생략"></a>@TestConstructor 어노테이션을 통한 @Autowired 어노테이션 생략</h4><p>테스트 별로 설정이 다를 때 테스트 마다 @TestConstructor를 달고 안 달고 설정할 수 있다.<br>spring.properties에 spring.test.constructor.autowire.mode=all로 설정하지 않는 이상 @TestConstructor(autowireMode = TestConstructor.AutowireMode.NONE)이 기본 값처럼 동작하기 때문에 전역적으로 ALL로 설정한 게 아닌 이상 AutowireMode.NONE은 굳이 사용할 필요가 없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a: SomeComponent</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">contextLoad</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spring-properties-파일을-통한-Autowired-어노테이션-생략"><a href="#spring-properties-파일을-통한-Autowired-어노테이션-생략" class="headerlink" title="spring.properties 파일을 통한 @Autowired 어노테이션 생략"></a>spring.properties 파일을 통한 @Autowired 어노테이션 생략</h4><p><a href="https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-test/src/main/java/org/springframework/test/context/support/TestConstructorUtils.java#L60">TestConstructorUtils.isAutowirableConstructor 메서드</a>에서 전역으로 설정된 값을 가져오기 위해 이런 부분이 있었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestConstructor &#123;</span><br><span class="line">String value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);</span><br></pre></td></tr></table></figure><p>그리고 TestConstructor에는 TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME이 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME = <span class="string">&quot;spring.test.constructor.autowire.mode&quot;</span>;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-core/src/main/java/org/springframework/core/SpringProperties.java#L109">SpringProperties 클래스의 getProperty 메서드</a>를 보면 localProperties 변수로부터 프로퍼티를 가져오고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String value = localProperties.getProperty(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure><p>그리고 localProperties는 static final 변수라서 다시 재할당 되지 않고, <a href="https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-core/src/main/java/org/springframework/core/SpringProperties.java#L58">static 초기화 블럭</a>에 의해 어떻게 초기화 되는지 봐보면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPERTIES_RESOURCE_LOCATION = <span class="string">&quot;spring.properties&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties localProperties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader cl = SpringProperties.class.getClassLoader();</span><br><span class="line">        URL url = (cl != <span class="keyword">null</span> ? cl.getResource(PROPERTIES_RESOURCE_LOCATION) :</span><br><span class="line">        ClassLoader.getSystemResource(PROPERTIES_RESOURCE_LOCATION));</span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Found &#x27;spring.properties&#x27; file in local classpath&quot;</span>);</span><br><span class="line">            InputStream is = url.openStream();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                localProperties.load(is);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Could not load &#x27;spring.properties&#x27; file from local classpath: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PROPERTIES_RESOURCE_LOCATION 변수에 있는 리소스를 읽어들여서 localProperties에 로딩하는 걸 볼 수 있다.<br>PROPERTIES_RESOURCE_LOCATION 변수도 static final 변수이기 때문에 무조건 classpath 내에 존재하는 <a href="/2020/12/25/spring-properties-file">spring.properties</a>라는 파일로부터 읽어들인다는 사실을 알 수 있다.</p><p><a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_project_layout">Gradle의 java plugin</a>을 사용하면 기본적으로 src/main/resources나 src/test/resources를 classpath에 등록해준다.<br>하지만 spring boot를 사용하기 위해 필수적으로 적용하는 <a href="https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/gradle-plugin/reference/html">Spring Boot Gradle Plugin</a>을 사용하면 Spring Boot 2.0.0.RELEASE 이후부터는 기본적으로 java 플러그인이 적용되기 때문에 따로 적용할 필요가 없다.</p><blockquote><p>A typical Spring Boot project will apply the groovy, java, or org.jetbrains.kotlin.jvm plugin and the io.spring.dependency-management plugin as a minimum.</p></blockquote><p>이 설정은 테스트용 설정이기 때문에 <code>src/test/resources에 spring.properties 파일</code>을 만들고 아래와 같이 프로퍼티를 설정하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.test.constructor.autowire.mode&#x3D;all</span><br></pre></td></tr></table></figure><p>위와 같이 전역에 공통적으로 autowireMode를 설정하고 나면 테스트 코드에서 @TestConstructor 어노테이션을 사용하지 않아도 @Autowired 어노테이션 없이 생성자를 통한 의존성 주입을 받을 수 있다</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a: SomeComponent</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">contextLoad</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-2-3-x-Spring-5-2-x"><a href="#Spring-Boot-2-3-x-Spring-5-2-x" class="headerlink" title="Spring Boot 2.3.x (Spring 5.2.x)"></a>Spring Boot 2.3.x (Spring 5.2.x)</h3><p><a href="https://github.com/spring-projects/spring-boot/blob/2.3.x/spring-boot-project/spring-boot-dependencies/build.gradle#L1675">Spring Boot 2.3.x는 Spring 5.2.x를 사용</a>하는데 Spring Boot 2.2.x와 동일한 스프링 버전을 사용했기 때문인지 Junit 5에서 Dependency Injection을 위한 변화는 없었다.</p><h3 id="Spring-Boot-2-4-x-Spring-5-3-2"><a href="#Spring-Boot-2-4-x-Spring-5-3-2" class="headerlink" title="Spring Boot 2.4.x (Spring 5.3.2)"></a>Spring Boot 2.4.x (Spring 5.3.2)</h3><p><a href="https://github.com/spring-projects/spring-boot/blob/2.4.x/spring-boot-project/spring-boot-dependencies/build.gradle#L1567">Spring Boot 2.4.x는 Spring 5.3.x를 사용</a>하기 때문에 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java#L233">Spring Test 5.3.x의 SpringExtension 클래스를 보면 supportsParameter</a> 메서드의 로직이 달라져있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(ParameterContext parameterContext, ExtensionContext extensionContext)</span> </span>&#123;</span><br><span class="line">    Parameter parameter = parameterContext.getParameter();</span><br><span class="line">    Executable executable = parameter.getDeclaringExecutable();</span><br><span class="line">    Class&lt;?&gt; testClass = extensionContext.getRequiredTestClass();</span><br><span class="line">    PropertyProvider junitPropertyProvider = propertyName -&gt;</span><br><span class="line">    extensionContext.getConfigurationParameter(propertyName).orElse(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) ||</span><br><span class="line">        ApplicationContext.class.isAssignableFrom(parameter.getType()) ||</span><br><span class="line">        ParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번엔 <a href="https://github.com/spring-projects/spring-framework/blob/65a395ef0e96c5e5ce28526d1fe975daaa566b0d/spring-test/src/main/java/org/springframework/test/context/support/TestConstructorUtils.java#L92">TestConstructorUtils.isAutowirableConstructor 메서드</a>에 junitPropertyProvider까지 넘기고 있다.<br>그리고 해당 메서드를 계속 타고 들어가면 아래와 같이 로직이 바뀌어있는 걸 볼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAutowirableConstructor</span><span class="params">(Constructor&lt;?&gt; constructor, Class&lt;?&gt; testClass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> PropertyProvider fallbackPropertyProvider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the constructor annotated with @Autowired?</span></span><br><span class="line">    <span class="keyword">if</span> (AnnotatedElementUtils.hasAnnotation(constructor, Autowired.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    AutowireMode autowireMode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the test class annotated with @TestConstructor?</span></span><br><span class="line">    TestConstructor testConstructor = TestContextAnnotationUtils.findMergedAnnotation(testClass, TestConstructor.class);</span><br><span class="line">    <span class="keyword">if</span> (testConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        autowireMode = testConstructor.autowireMode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Custom global default from SpringProperties?</span></span><br><span class="line">        String value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);</span><br><span class="line">        autowireMode = AutowireMode.from(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use fallback provider?</span></span><br><span class="line">        <span class="keyword">if</span> (autowireMode == <span class="keyword">null</span> &amp;&amp; fallbackPropertyProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = fallbackPropertyProvider.get(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);</span><br><span class="line">            autowireMode = AutowireMode.from(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (autowireMode == AutowireMode.ALL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@Autowired 어노테이션이 달려있으면 true를 반환한다.</li><li>autowireMode 변수를 선언하고, null로 초기화한다.</li><li><a href="https://github.com/spring-projects/spring-framework/blob/65a395ef0e96c5e5ce28526d1fe975daaa566b0d/spring-test/src/main/java/org/springframework/test/context/TestConstructor.java#L75">@TestConstructor 어노테이션</a>이 달려있는지 확인한다.<ol><li>달려있으면 해당 어노테이션의 autowireMode 프로퍼티를 autowireMode 변수에 할단한다.</li><li>달려있지 않으면 아래 분기를 탄다.<ol><li> 클래스 패스에 있는 spring.properties 파일에서 spring.test.constructor.autowire.mode 프로퍼티를 가져온다.</li><li>가져온 프로퍼티를 AutowireMode enum으로 변환해서 autowireMode 변수에 할당한다.</li><li>AutowireMode enum으로 변환에 실패했는데 fallbackPropertyProvider(junitPropertyProvider)가 존재하면 아래 분기를 탄다.<ol><li>junitPropertyProvider에서 spring.test.constructor.autowire.mode 프로퍼티를 가져온다.</li><li>프로퍼티를 AutowireMode enum으로 변환해서 autowireMode 변수에 할당한다.</li></ol></li></ol></li></ol></li><li>autowireMode 변수가 AutowireMode.ALL과 같으면 true, 다르면 false를 반환한다.</li></ol><p>junitPropertyProvider로부터 읽어오는 부분이 추가된 건데 추가하는 방법은 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#integration-testing-annotations-testconstructor">스프링 공식 문서</a>에 나와있다.</p><blockquote><p>Changing the default test constructor autowire mode<br>The default test constructor autowire mode can be changed by setting the spring.test.constructor.autowire.mode JVM system property to all.<br>Alternatively, the default mode may be set via the SpringProperties mechanism.<br>As of Spring Framework 5.3, the default mode may also be configured as a JUnit Platform configuration parameter.</p></blockquote><p>JUnit Platform configuration parameter를 설정하는 방법은 <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-config-params">JUnit 공식문서</a>에 나와있고, junit-platform.properties 파일을 만들어서 클래스패스에 추가하면 적용이 된다.</p><blockquote><p>The JUnit Platform configuration file: a file named junit-platform.properties in the root of the class path that follows the syntax rules for a Java Properties file.</p></blockquote><p>spring.properties는 테스트 전용 설정파일이 아닌데 반해 junit-platform.properties 파일은 테스트 전용 설정파일이기 때문에 우리가 설정하려는 값은 테스트 전용 값이라서 junit-platform.properties에 있는 게 더 좋다고 볼 수 있다.</p><p><code>/src/test/resources에 junit-platform.properties 파일</code>을 만들어주자.<br>자바 표준 API인 Properties 문법을 따른다고 하니 아래와 같이 적어주면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.test.constructor.autowire.mode&#x3D;all</span><br></pre></td></tr></table></figure><p>위와 같이 전역에 공통적으로 autowireMode를 설정하고 나면 테스트 코드에서 @TestConstructor 어노테이션을 사용하지 않아도 @Autowired 어노테이션 없이 생성자를 통한 의존성 주입을 받을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeTest</span>(</span></span><br><span class="line">    private val a: SomeComponent</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function">fun <span class="title">contextLoad</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JUnt-4&quot;&gt;&lt;a href=&quot;#JUnt-4&quot; class=&quot;headerlink&quot; title=&quot;JUnt 4&quot;&gt;&lt;/a&gt;JUnt 4&lt;/h2&gt;&lt;p&gt;Field Injection 밖에 되지 않음.&lt;br&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes#junit-5&quot;&gt;Spring Boot 2.2.0&lt;/a&gt;부터 JUnit 5가 기본으로 탑재되기 시작했고,&lt;br&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.4-Release-Notes#junit-5s-vintage-engine-removed-from-spring-boot-starter-test&quot;&gt;Spring Boot 2.4.0&lt;/a&gt;부터는 아예 JUnit 4 의존성이 제거됐기 때문에 &lt;code&gt;JUnit 4의 사용은 하지 말아야한다.&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@RunWith(SpringRunner::class)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SpringBootTest&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a: SomeComponent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contextLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;JUnit-5&quot;&gt;&lt;a href=&quot;#JUnit-5&quot; class=&quot;headerlink&quot; title=&quot;JUnit 5&quot;&gt;&lt;/a&gt;JUnit 5&lt;/h2&gt;&lt;p&gt;JUnit 5의 &lt;a href=&quot;https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/ExtendWith.html&quot;&gt;@ExtendedWith&lt;/a&gt; 어노테이션을 이용하면 테스트 전/후로 다양한 일을 할 수 있다.&lt;br&gt;@ExtendedWith 어노테이션은 어노테이션에 명시한 &lt;a href=&quot;https://junit.org/junit5/docs/5.1.1/api/org/junit/jupiter/api/extension/Extension.html&quot;&gt;Extension&lt;/a&gt;들을 실행하는 역할 뿐이 하지 않는다.&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/categories/Spring-Boot/"/>
    
    
    <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
    <category term="Spring Boot" scheme="https://perfectacle.github.io/tags/Spring-Boot/"/>
    
    <category term="JUnit" scheme="https://perfectacle.github.io/tags/JUnit/"/>
    
  </entry>
  
  <entry>
    <title>spring.properties 파일을 읽어들이는 원리</title>
    <link href="https://perfectacle.github.io/2020/12/25/spring-properties-file/"/>
    <id>https://perfectacle.github.io/2020/12/25/spring-properties-file/</id>
    <published>2020-12-24T15:51:17.000Z</published>
    <updated>2020-12-24T17:41:02.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringProperties-클래스"><a href="#SpringProperties-클래스" class="headerlink" title="SpringProperties 클래스"></a><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/SpringProperties.java#L46">SpringProperties 클래스</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPERTIES_RESOURCE_LOCATION = <span class="string">&quot;spring.properties&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties localProperties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = SpringProperties.class.getClassLoader();</span><br><span class="line">            URL url = (cl != <span class="keyword">null</span> ? cl.getResource(PROPERTIES_RESOURCE_LOCATION) :</span><br><span class="line">                    ClassLoader.getSystemResource(PROPERTIES_RESOURCE_LOCATION));</span><br><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> (InputStream is = url.openStream()) &#123;</span><br><span class="line">                    localProperties.load(is);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Could not load &#x27;spring.properties&#x27; file from local classpath: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = localProperties.getProperty(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = System.getProperty(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Could not retrieve system property &#x27;&quot;</span> + key + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>PROPERTIES_RESOURCE_LOCATION(<code>spring.properties</code>) 파일을 읽어서 InputStream에 넣고</li><li>localProperties.load(is)를 통해 Properties에 위에서 읽어들인 InputStream을 load 하고</li><li>나중에 필요할 때 키 값을 통해 프로퍼티를 불러오고 있다. </li></ol><p>localProperties는 Properties라는 자바 표준 API를 사용하고 있기 때문에 저 spring.properties에는 어떻게 키와 프로퍼티를 구성하는지 알아보자.</p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html">Properties</a></h3><blockquote><p>The Properties class represents a persistent set of properties.<br>The Properties can be saved to a stream or loaded from a stream.<br>Each key and its corresponding value in the property list is a string.</p></blockquote><p>프로퍼티들을 모아놓은 타입이고, 키와 밸류의 쌍으로 이루어졌다고 보면 된다.<br>그리고 stream으로부터 load 될 수 있다고 하니 InputStream에서 로드되는 API부터 봐보자.</p><h4 id="load-InputStream-inStream"><a href="#load-InputStream-inStream" class="headerlink" title="load(InputStream inStream)"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.InputStream-">load(InputStream inStream)</a></h4><blockquote><p>public void load(InputStream inStream) throws IOException</p><p>Reads a property list (key and element pairs) from the input byte stream.<br>The input stream is in a simple line-oriented format as specified in load(Reader) and is assumed to use the ISO 8859-1 character encoding;<br>that is each byte is one Latin1 character. Characters not in Latin1, and certain special characters, are represented in keys and elements using Unicode escapes as defined in section 3.3 of The Java™ Language Specification.</p></blockquote><p>일단 <a href="https://ko.wikipedia.org/wiki/ISO/IEC_8859-1">ISO 8859-1</a>은 문자열 관련 인코딩 표준인데 영어/숫자나 기본적인 특수문자(공백, 느낌표 등등)들만 지원한다고 생각하면 편하다.<br>또한 line-oriented format이기 때문에 한 줄 마다 key and element pair가 구성이 된다.<br>한 줄이 어떤 식으로 구성되는지는 <a href="#load-Reader-reader">load(Reader reader</a>) 메서드를 참고하면 된다.</p><h4 id="load-Reader-reader"><a href="#load-Reader-reader" class="headerlink" title="load(Reader reader)"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-">load(Reader reader)</a></h4><blockquote><p>public void load(Reader reader) throws IOException<br>…<br>As an example, each of the following three lines specifies the key “Truth” and the associated element value “Beauty”:<br>Truth = Beauty<br> Truth:Beauty<br> Truth           :Beauty</p></blockquote><p><code>=</code>이나 <code>:</code>로 key/element를 구분짓고, 앞 뒤에 굳이 공백은 전부 생략해주는 것으로 보인다.<br>일반적으로 보던 application.properties와 큰 차이 없는 것으로 보이므로 원래 사용하던 데로 쓰면 될 거 같다.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SpringProperties-클래스&quot;&gt;&lt;a href=&quot;#SpringProperties-클래스&quot; class=&quot;headerlink&quot; title=&quot;SpringProperties 클래스&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/SpringProperties.java#L46&quot;&gt;SpringProperties 클래스&lt;/a&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Properties;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SpringProperties&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String PROPERTIES_RESOURCE_LOCATION = &lt;span class=&quot;string&quot;&gt;&amp;quot;spring.properties&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Properties localProperties = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Properties();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ClassLoader cl = SpringProperties.class.getClassLoader();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            URL url = (cl != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? cl.getResource(PROPERTIES_RESOURCE_LOCATION) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ClassLoader.getSystemResource(PROPERTIES_RESOURCE_LOCATION));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (url != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; (InputStream is = url.openStream()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    localProperties.load(is);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.err.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;Could not load &amp;#x27;spring.properties&amp;#x27; file from local classpath: &amp;quot;&lt;/span&gt; + ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String key)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String value = localProperties.getProperty(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                value = System.getProperty(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.err.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;Could not retrieve system property &amp;#x27;&amp;quot;&lt;/span&gt; + key + &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;#x27;: &amp;quot;&lt;/span&gt; + ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;PROPERTIES_RESOURCE_LOCATION(&lt;code&gt;spring.properties&lt;/code&gt;) 파일을 읽어서 InputStream에 넣고&lt;/li&gt;
&lt;li&gt;localProperties.load(is)를 통해 Properties에 위에서 읽어들인 InputStream을 load 하고&lt;/li&gt;
&lt;li&gt;나중에 필요할 때 키 값을 통해 프로퍼티를 불러오고 있다. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;localProperties는 Properties라는 자바 표준 API를 사용하고 있기 때문에 저 spring.properties에는 어떻게 키와 프로퍼티를 구성하는지 알아보자.&lt;/p&gt;
&lt;h3 id=&quot;Properties&quot;&gt;&lt;a href=&quot;#Properties&quot; class=&quot;headerlink&quot; title=&quot;Properties&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html&quot;&gt;Properties&lt;/a&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://perfectacle.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>(TDD) 클래스의 명시적인 타입 검사를 제거하는 방법</title>
    <link href="https://perfectacle.github.io/2020/06/11/how-to-remove-instanceof/"/>
    <id>https://perfectacle.github.io/2020/06/11/how-to-remove-instanceof/</id>
    <published>2020-06-11T08:30:48.000Z</published>
    <updated>2020-08-23T16:18:44.781Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=7443642">TDD By Example</a> 책을 보다가 감명 받은 부분을 정리해봤다.<br>기본적으로 아래 4가지 원칙을 따라 진행한다.</p><ol><li>Red - <strong>실패</strong>하는 <strong>작은</strong> 테스트를 작성(최초에는 컴파일 조차 되지 않음)</li><li>Green - <strong>빨리</strong> 테스트가 <strong>통과</strong>하게 끔 수정(이를 위해선 어떠한 <strong>죄악</strong>도 용서됨)</li><li>Refactoring - 모든 <strong>중복</strong>을 <strong>제거</strong>(2번에서 수행한 죄악들을 청산)</li></ol><p>해당 포스트는 프랑(CHF, 스위스 통화)을 달러($)로 변환하는 간단한 테스트를 작성하는 것부터 시작한다.</p><h2 id="프랑에서-달러로-변환하기"><a href="#프랑에서-달러로-변환하기" class="headerlink" title="프랑에서 달러로 변환하기"></a>프랑에서 달러로 변환하기</h2><p>아래와 같은 간단한 코드들을 이번 예제에서 사용해보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(</span><br><span class="line">    <span class="keyword">val</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> currency: String</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dollar</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Dollar(amount)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">franc</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Franc(amount)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Money</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (currency != other.currency) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;USD&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;CHF&quot;</span>)</span><br></pre></td></tr></table></figure><p>프랑(스위스 통화)과 달러의 환율은 2:1이라고 가정했을 때 프랑으로부터 달러를 얻는 테스트는 다음과 같이 작성할 수 있다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoneyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `10CHF = $5`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> tenFrancs = Money.franc(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">val</span> expected = Money.dollar(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span> = tenFrancs.ofDollars()</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴파일이 되도록 소스코드를 수정해보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(</span><br><span class="line">    <span class="keyword">val</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> currency: String</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ofDollars</span><span class="params">()</span></span>: Dollar &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선 컴파일은 가능해졌고 테스트를 돌리면 깨진다. (Red 단계)<br>이제 테스트를 성공시켜 보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ofDollars</span><span class="params">()</span></span>: Dollar &#123;</span><br><span class="line">    <span class="keyword">return</span> Dollar(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상수를 반환하게 하여 테스트를 통과하게 했지만 이번엔 달러에서 달러를 반환하는 테스트를 작성해서 일반화 시켜 나가보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `$10 = $10`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Given</span></span><br><span class="line">    <span class="keyword">val</span> tenBucks = Money.dollar(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> expected = Money.dollar(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">actual</span> = tenBucks.ofDollars()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then</span></span><br><span class="line">    <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트는 깨진다.<br>그럼 테스트를 통과할 수 있게 끔 ofDollars 메서드 구현을 상수에서 일반화시켜보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ofDollars</span><span class="params">()</span></span>: Dollar &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">is</span> Dollar -&gt; <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">is</span> Franc -&gt; Dollar(<span class="keyword">this</span>.amount / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;Unsupported Currency&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트는 전부 통과하지만, 통화가 늘어나면 저렇게 타입 검사하는 코드를 계속 추가해야하고, 실수로 타입 검사를 빼먹으면 예외를 만나게 될 것이다.<br>이런 고통으로부터 벗어나려면 어떻게 해야할까…?</p><h2 id="다형성을-이용하여-타입검사-제거하기"><a href="#다형성을-이용하여-타입검사-제거하기" class="headerlink" title="다형성을 이용하여 타입검사 제거하기"></a>다형성을 이용하여 타입검사 제거하기</h2><p><strong>명시적으로 타입검사를 제거</strong>하기 위해서는 **다형성(Polymorphism)**을 이용하면 된다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(</span><br><span class="line">    <span class="keyword">val</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> currency: String</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">ofDollars</span><span class="params">()</span></span>: Dollar</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;USD&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">ofDollars</span><span class="params">()</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;CHF&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">ofDollars</span><span class="params">()</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="keyword">this</span>.amount / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Money에서 ofDollars 메서드를 추상메서드로 바꿨을 때 나타나는 장점은 세 가지가 있다.</p><ol><li>유저가 미지원 통화 오류를 만날 일이 사라졌다.<br>이전에는 각 통화에 대한 분기를 추가하지 않는 실수를 할 수 있었고 그렇게 되면 예외를 만나게 됐는데 지금은 각 하위 클래스에서 구현을 하지 않으면 컴파일 조차 되지 않는다.<br>컴파일 자체가 되지 않기 때문에 실수한 상태로 배포가 불가능하고, 적어도 유저가 장애를 경험할 일은 없다.  </li><li>단일 책임 원칙을 준수하게 됐다. (해당 클래스가 변경돼야하는 사유는 해당 통화의 환율이 변경됐을 때 뿐이다.)<br>기존 Money 클래스에 구현돼있을 때는 ofDollars 메서드에서 Money가 Dollar인 경우, Franc인 경우, 그 외의 통화인 경우를 전부 커버하고 있었다.<br>그러다보니 Franc의 환율이 변경되도 Money를 수정해야하고, 그 외의 통화가 추가돼도 Money를 수정하다보니 Money의 소스가 비대해질 가능성이 있다보니 이해/수정하기도 힘들고, Franc의 환율을 수정했는데 다른 통화가 영향을 받을 수 있는 상황이었다.<br>하지만 지금은 Franc의 환율이 변경되면 Franc만 수정하면 되고, Franc만 수정했으므로 그 변경의 여파가 다른 통화로 번지지 않기 때문에 수정할 때 더 안심할 수 있다.</li><li><strong>타입검사가 제거됐다.</strong><br>외부에서는 Money란 사실만 알고 있고, 실제 구체 타입에 따라서 알아서 메서드를 실행한다.<br>자바/코틀린에서는 언어 수준에서 다형성을 지원하기 때문에 분기를 마구 태우던 부분을 제거할 수 있었고 코드가 좀 더 단순해졌다.  </li></ol><p>하지만 이로 인한 단점은 아래 두 가지가 있다.  </p><ol><li>Dollar 클래스에 별로 하는 일도 없는 껍데기 메서드가 추가됐다.<br>Dollar에서 구현한 ofDollars 메서드는 자기 자신(this)를 리턴한다.<br>외부에서 분기를 없애기 위해서 다형성을 사용하다 보니 별로 하는 일도 없어보이는 듯한 메서드가 추가됐다.<br>다형성을 위해서 이런 껍데기 같은 메서드들은 어쩔 수 없이 추가돼야하는 것 같다.</li><li>실제 코드를 파악하려면 Money 클래스와 각 하위 클래스들을 파악해야한다.<br>원래 분기를 태울 때는 Money 클래스만 봐도 돼서 코드가 한 눈에 들어왔다.<br>하지만 지금은 하위 클래스에서 그 책임을 분할해서 지고 있다보니 각 하위 클래스들을 전부 봐야 모든 소스를 이해하게 되는 것이다.<br>다형성을 너무 많이 활용하다보면 소스코드를 확인하기 위해서 엄청 많은 클래스들을 봐야할 수도 있다.<br>이건 얼마나 추상화할 것인지, 적절한 밸런스를 가져가야할 것 같다.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=7443642&quot;&gt;TDD By Example&lt;/a&gt; 책을 보다가 감명 받은 부분을 정리해봤다.&lt;br&gt;기본적으로 아래 4가지 원칙을 따라 진행한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Red - &lt;strong&gt;실패&lt;/strong&gt;하는 &lt;strong&gt;작은&lt;/strong&gt; 테스트를 작성(최초에는 컴파일 조차 되지 않음)&lt;/li&gt;
&lt;li&gt;Green - &lt;strong&gt;빨리&lt;/strong&gt; 테스트가 &lt;strong&gt;통과&lt;/strong&gt;하게 끔 수정(이를 위해선 어떠한 &lt;strong&gt;죄악&lt;/strong&gt;도 용서됨)&lt;/li&gt;
&lt;li&gt;Refactoring - 모든 &lt;strong&gt;중복&lt;/strong&gt;을 &lt;strong&gt;제거&lt;/strong&gt;(2번에서 수행한 죄악들을 청산)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;해당 포스트는 프랑(CHF, 스위스 통화)을 달러($)로 변환하는 간단한 테스트를 작성하는 것부터 시작한다.&lt;/p&gt;
&lt;h2 id=&quot;프랑에서-달러로-변환하기&quot;&gt;&lt;a href=&quot;#프랑에서-달러로-변환하기&quot; class=&quot;headerlink&quot; title=&quot;프랑에서 달러로 변환하기&quot;&gt;&lt;/a&gt;프랑에서 달러로 변환하기&lt;/h2&gt;&lt;p&gt;아래와 같은 간단한 코드들을 이번 예제에서 사용해보자.  &lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Study" scheme="https://perfectacle.github.io/categories/Note/Study/"/>
    
    
    <category term="TDD" scheme="https://perfectacle.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>(TDD) 하위 클래스를 제거하기 쉽게 만드는 방법</title>
    <link href="https://perfectacle.github.io/2020/06/11/how-to-make-subclasses-easy-to-remove/"/>
    <id>https://perfectacle.github.io/2020/06/11/how-to-make-subclasses-easy-to-remove/</id>
    <published>2020-06-11T07:03:32.000Z</published>
    <updated>2020-08-23T16:18:44.747Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=7443642">TDD By Example</a> 책을 보다가 감명 받은 부분을 정리해봤다.<br>기본적으로 아래 4가지 원칙을 따라 진행한다.</p><ol><li>Red - <strong>실패</strong>하는 <strong>작은</strong> 테스트를 작성(최초에는 컴파일 조차 되지 않음)</li><li>Green - <strong>빨리</strong> 테스트가 <strong>통과</strong>하게 끔 수정(이를 위해선 어떠한 <strong>죄악</strong>도 용서됨)</li><li>Refactoring - 모든 <strong>중복</strong>을 <strong>제거</strong>(2번에서 수행한 죄악들을 청산)</li></ol><p>책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.<br>해당 포스트는 <a href="/2020/06/09/change-inheritance-hierarchy-without-affecting-client">클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법</a>에서 제거하지 못한 중복인 plus 메서드를 제거하는 것으로 시작한다.<br>(기본적으로 코틀린, JUnit5, kotest를 사용했다)<br>기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 <a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a>를 보면 된다.</p><h2 id="각-하위-클래스에-있는-plus-메서드-제거하기"><a href="#각-하위-클래스에-있는-plus-메서드-제거하기" class="headerlink" title="각 하위 클래스에 있는 plus 메서드 제거하기"></a>각 하위 클래스에 있는 plus 메서드 제거하기</h2><p>기본적으로 소스 코드는 아래와 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(<span class="keyword">val</span> amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Money</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Franc(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>문제는 메서드에서는 구체 클래스인 Dollar나 Franc 밖에 반환하지 못하는데 공통된 구체 클래스를 반환하게 해야 중복(plus 메서드)을 제거할 수 있다.<br>그럼 공통된 부모 클래스인 Money 클래스를 구체 클래스로 바꿔보고 Money 클래스를 리턴하게 끔 수정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dollar</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Dollar(amount)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">franc</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Franc(amount)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (other !<span class="keyword">is</span> Money) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 plus 메서드를 각 하위 클래스에서 제거해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount)</span><br></pre></td></tr></table></figure><p>모든 테스트를 돌려보면 통과하고 이제 Dollar와 Franc 클래스는 딱히 하는 일이 없어보이므로 삭제해도 될 거 같다는 생각이 든다.<br>과연 그럴까…??</p><h2 id="통화-currency-추가하기"><a href="#통화-currency-추가하기" class="headerlink" title="통화(currency) 추가하기"></a>통화(currency) 추가하기</h2><p>Dollar와 Franc 클래스는 그 자체만으로 Currency(통화) 정보를 포함하는 클래스인데 Money 클래스는 그러지 못한다.<br>이게 정말 문제가 되는 건지 테스트를 통해 검증해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoneyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    fun `$5 != 5CHF`() &#123;</span><br><span class="line">        <span class="keyword">val</span> amount = <span class="number">5</span></span><br><span class="line">        <span class="keyword">val</span> dollars = Money.dollar(amount)</span><br><span class="line">        <span class="keyword">val</span> francs = Money.franc(amount)</span><br><span class="line">        dollars shouldNotBe francs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>흠… 테스트는 잘 통과한다.<br>하지만 위 팩토리 메서드들은 Dollar와 Franc과 같은 하위 클래스를 반환하므로 문제가 안 생긴 것일 수도 있으니 Money를 반환하는 plus 메서드에 대해서도 검증을 추가해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `$5 + $5 != 5CHF + 5CHF`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> amount = <span class="number">5</span></span><br><span class="line">    <span class="keyword">val</span> tenBucks = Money.dollar(amount) + Money.dollar(amount)</span><br><span class="line">    <span class="keyword">val</span> tenFrancs = Money.franc(amount) + Money.franc(amount)</span><br><span class="line">    tenBucks shouldNotBe tenFrancs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리가 예상했던 대로 위 테스트는 실패한다.<br>따라서 Money 클래스에 currency 필드를 추가해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> currency: String</span><br><span class="line">) &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Money</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (currency != other.currency) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.amount + money.amount, <span class="keyword">this</span>.currency)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>바뀐 생성자를 각 하위 클래스에 적용해주자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>우선 Red 단계를 보기 위해 재빠르게 구현만 해주자.<br>그리고 테스트를 돌려보면 여전히 <code>$5 + $5 != 5CHF + 5CHF</code>에서 실패한다.<br>그럼 Green을 보기 위해 알맞은 currency를 할당해주자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;USD&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount, <span class="string">&quot;CHF&quot;</span>)</span><br></pre></td></tr></table></figure><p>이제 MoneyTest는 Green을 볼 수 있지만 다른 Test를 돌려보면 테스트가 깨진다.<br>DollarTest와 FrancTest의 test addition 테스트가 아래와 같은 사유로 깨진다.<br><code>org.opentest4j.AssertionFailedError: expected:&lt;com.example.demo.Dollar@1b919693&gt; but was:&lt;com.example.demo.Money@7fb4f2a9&gt;</code><br><code>org.opentest4j.AssertionFailedError: expected:&lt;com.example.demo.Franc@12591ac8&gt; but was:&lt;com.example.demo.Money@5a7fe64f&gt;</code></p><p>문제는 factory method에서는 하위 클래스인 Dollar/Franc을 반환하고, plus 메서드에서는 부모 클래스인 Money를 반환하기 때문이다.<br>이제 테스트를 통과하게 끔 factory method에서도 Money를 반환하게 끔 수정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> currency: String</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dollar</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Money(amount, <span class="string">&quot;USD&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">franc</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Money(amount, <span class="string">&quot;CHF&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 모든 테스트가 통과하게 된다.<br>이제 Money가 가지고 있던 통화 문제도 해결했고, 하위 클래스인 Dollar와 Franc 클래스를 사용하는 곳은 완전히 사라졌다.<br>위 두 클래스를 제거하고 이제 Money 클래스를 상속받는 클래스가 사라졌으므로 클래스를 상속받지 못하게 open 키워드를 제거해서 final 클래스로 만들어버리자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> currency: String</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>만약 <a href="/2020/06/09/change-inheritance-hierarchy-without-affecting-client">클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법</a>에서처럼 하위 클래스에 직접적인 접근을 제거하지 않았으면 중복을 제거한 후에 하위 클래스를 제거할 때 애를 먹었을 것이다.<br>해당 클래스들을 사용하는 부분(테스트 코드)에서 Dollar/Franc 생성자로 생성하는 부분을 전부 찾아서 Money 생성자로 바꿨을 것이다.<br>하지만 <strong>하위 클래스에 직접적인 접근하는 부분을 전부 제거</strong>하고 <strong>Money 내부에서만 직접적인 접근</strong>을 하도록 두었기 때문에 <strong>Money 클래스만 수정</strong>함으로써 <strong>하위 클래스를 제거하기가 훨씬 수월</strong>했다.<br>그리고 문제점에 대해 인식을 하고 먼저 테스트로 작성해뒀기 때문에 어떤 부분을 구현해야할 지 좀 더 명확했다.<br>또한 자동화 된 테스트들을 작성해두다 보니 내가 수정한 부분이 어디까지 영향을 미쳤는지, 코드를 안전하게 수정한 건 지 확인할 수 있어서 안심하고 코드를 작성할 수 있었다.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=7443642&quot;&gt;TDD By Example&lt;/a&gt; 책을 보다가 감명 받은 부분을 정리해봤다.&lt;br&gt;기본적으로 아래 4가지 원칙을 따라 진행한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Red - &lt;strong&gt;실패&lt;/strong&gt;하는 &lt;strong&gt;작은&lt;/strong&gt; 테스트를 작성(최초에는 컴파일 조차 되지 않음)&lt;/li&gt;
&lt;li&gt;Green - &lt;strong&gt;빨리&lt;/strong&gt; 테스트가 &lt;strong&gt;통과&lt;/strong&gt;하게 끔 수정(이를 위해선 어떠한 &lt;strong&gt;죄악&lt;/strong&gt;도 용서됨)&lt;/li&gt;
&lt;li&gt;Refactoring - 모든 &lt;strong&gt;중복&lt;/strong&gt;을 &lt;strong&gt;제거&lt;/strong&gt;(2번에서 수행한 죄악들을 청산)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.&lt;br&gt;해당 포스트는 &lt;a href=&quot;/2020/06/09/change-inheritance-hierarchy-without-affecting-client&quot;&gt;클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법&lt;/a&gt;에서 제거하지 못한 중복인 plus 메서드를 제거하는 것으로 시작한다.&lt;br&gt;(기본적으로 코틀린, JUnit5, kotest를 사용했다)&lt;br&gt;기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 &lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B0&quot;&gt;마치며&lt;/a&gt;를 보면 된다.&lt;/p&gt;
&lt;h2 id=&quot;각-하위-클래스에-있는-plus-메서드-제거하기&quot;&gt;&lt;a href=&quot;#각-하위-클래스에-있는-plus-메서드-제거하기&quot; class=&quot;headerlink&quot; title=&quot;각 하위 클래스에 있는 plus 메서드 제거하기&quot;&gt;&lt;/a&gt;각 하위 클래스에 있는 plus 메서드 제거하기&lt;/h2&gt;&lt;p&gt;기본적으로 소스 코드는 아래와 같다.&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Study" scheme="https://perfectacle.github.io/categories/Note/Study/"/>
    
    
    <category term="TDD" scheme="https://perfectacle.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>(TDD) 클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법</title>
    <link href="https://perfectacle.github.io/2020/06/09/change-inheritance-hierarchy-without-affecting-client/"/>
    <id>https://perfectacle.github.io/2020/06/09/change-inheritance-hierarchy-without-affecting-client/</id>
    <published>2020-06-09T09:21:29.000Z</published>
    <updated>2020-08-23T16:18:44.721Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=7443642">TDD By Example</a> 책을 보다가 감명 받은 부분을 정리해봤다.<br>기본적으로 아래 4가지 원칙을 따라 진행한다.</p><ol><li>Red - <strong>실패</strong>하는 <strong>작은</strong> 테스트를 작성(최초에는 컴파일 조차 되지 않음)</li><li>Green - <strong>빨리</strong> 테스트가 <strong>통과</strong>하게 끔 수정(이를 위해선 어떠한 <strong>죄악</strong>도 용서됨)</li><li>Refactoring - 모든 <strong>중복</strong>을 <strong>제거</strong>(2번에서 수행한 죄악들을 청산)</li></ol><p>책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.<br>해당 포스트도 위 두가지 통화에 대해 덧셈 연산을 테스트 하는 작은 코드로 시작한다.<br>(기본적으로 코틀린, JUnit5, kotest를 사용했다)<br>기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 <a href="#%ED%95%98%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%A7%81%EC%A0%91%EC%A0%81%EC%9D%B8-%EC%B0%B8%EC%A1%B0-%EC%A4%84%EC%9D%B4%EA%B8%B0">하위 클래스의 직접적인 참조 줄이기</a>를 보면 된다.</p><h2 id="Dollar-클래스-구현하기"><a href="#Dollar-클래스-구현하기" class="headerlink" title="Dollar 클래스 구현하기"></a>Dollar 클래스 구현하기</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DollarTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `$5 + $2 = $7`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> five = Dollar(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">val</span> two = Dollar(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span> = five + two</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">val</span> expected = Dollar(<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 위 코드가 실패하게 끔 컴파일이 되도록 클래스를 만들어주자. (컴파일만 되게 끔 아주 빠르게 만들면 된다)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아주 빠르게 만들다보니 아래와 같은 죄악을 저질렀다.</p><ol><li>생성자의 매개변수인 amount를 멤버변수로 할당하지 않았다.  </li><li>plus 메서드 내부를 TODO로 비워뒀다.</li></ol><p>하지만 우리에겐 실패하는 테스트를 돌려보는 게 제일 중요기 때문에 위와 같은 죄악은 전혀 중요치 않다.</p><p>아무 생각없이 IDE의 도움을 받아서 우선 가장 빠르게 컴파일이 되도록 만든 후에 테스트를 돌려보면 당연히 테스트는 실패한다.<br><code>kotlin.NotImplementedError: An operation is not implemented: Not yet implemented</code></p><p>우선 첫 번째 단계인 Red를 만족하였다.<br>그럼 다음 단게인 Green 단계를 만족시키기 위해 테스트를 성공 시키는 강력범죄를 저지르러 가자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 돌려보면 테스트가 통과했다는 Green 표시를 보게 된다.<br>우리는 테스트를 가장 빠르게 통과시키기 위해 <strong>가짜로 구현하기</strong> 기법을 사용했다.<br>가짜로 구현하기는 우선 <strong>상수</strong>를 반환시켜서 테스트를 통과시키고 <strong>단계적</strong>으로 <strong>변수</strong>를 사용하도록 점진시켜나가는 과정이다.</p><p>우선 하나의 테스트만 가지고는 제대로 구현했는지 검증이 안 되므로 plus 메서드의 결과가 일치하지 않는 것에 대한 테스트도 작성해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `$5 + $2 != $10`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Given</span></span><br><span class="line">    <span class="keyword">val</span> five = Dollar(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">val</span> two = Dollar(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">actual</span> = five + two</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then</span></span><br><span class="line">    <span class="keyword">val</span> notExpected = Dollar(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">actual</span> shouldNotBe notExpected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dollar 클래스의 equals 메서드는 무조건 true를 반환하므로 테스트는 성공하지 못한다.<br>equality를 비교하려면 해당 클래스의 내부 상태를 검사하는 값 객체(Value Object) 패턴을 사용해야한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Dollar</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선 값 객체로 사용하기 위해 amount를 멤버 변수로 할당하고, IDE의 도움을 받아 equals 메서드를 제대로 구현했다.<br>테스트를 돌려보면 <code>$5 + $2 != $10</code>은 통과하는데 <code>$5 + $2 = $7</code>은 plus 메서드를 제대로 구현하지 않았기 때문에 실패한다.<br>이제 <code>$5 + $2 = $7</code> 메서드를 통과시키도록 plus 메서드의 구현부를 바꿔보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">    <span class="keyword">return</span> Dollar(<span class="number">7</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트가 통과되는 가장 빠른 길을 택하기 위해 상수를 사용하는 죄악을 저질렀다.<br>우선 테스트는 잘 통과된다.<br>하지만 하나의 테스트 셋만 가지고는 제대로 구현했는지 검증이 안 되므로 JUnit5의 Dynamic Test를 이용하여 검증해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestFactory</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test addition`<span class="params">()</span></span> = listOf(</span><br><span class="line">    Pair(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">    Pair(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">).map &#123; (augendAmount, addendAmount) -&gt;</span><br><span class="line">    dynamicTest(<span class="string">&quot;$<span class="subst">$&#123;augendAmount&#125;</span> + $<span class="subst">$&#123;addendAmount&#125;</span> = $<span class="subst">$&#123;augendAmount + addendAmount&#125;</span>&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> augend = Dollar(augendAmount)</span><br><span class="line">        <span class="keyword">val</span> addend = Dollar(addendAmount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span> = augend + addend</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">val</span> expected = Dollar(augendAmount + addendAmount)</span><br><span class="line">        <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$6 + 3 = $9 테스트에서 실패한다.<br><code>org.opentest4j.AssertionFailedError: expected:&lt;9&gt; but was:&lt;7&gt;</code></p><p>plus 메서드의 반환값을 Dollar(<code>7</code>)이라는 상수를 박았기 때문에 실패했다.<br>따라서 7이라는 상수를 변수로 변환시켜보면 아래와 같이 <strong>중복을 제거</strong>할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">    <span class="keyword">return</span> Dollar(<span class="keyword">this</span>.amount + dollar.amount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트를 돌려보면 모든 테스트가 통과한다.<br>그냥 상수에서 변수로 바꾼 것 뿐인데 어느 부분이 중복이었길래 중복이 제거됐다고 하는지 의아해 할 수 있다.<br>우리의 뇌가 너무 똑똑해서 머릿 속에서 연산이 순식간에 일어나서 중복이 아니라고 생각할 수 있는데 찬찬히 해체해보면 중복이 보인다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">    <span class="keyword">return</span> Dollar(<span class="number">7</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선 상수를 사용하던 코드로 돌아가서 Dollar(<code>7</code>) 부분을 좀 더 집중해서 보면 우리 머릿 속에서 엄청 빠른 연산이 일어나서 7이란 값이 나온 거지 사실은 연산을 거치기 전에는 아래와 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">    <span class="keyword">return</span> Dollar(<span class="number">5</span> + <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>바로 테스트의 <code>val expected = Dollar(augendAmount + addendAmount)</code> 부분(<strong>augendAmount + addendAmount</strong>)과 중복되는 걸 볼 수 있다.<br>따라서 우리는 Dollar 클래스의 <strong>amount</strong> 필드와 plus 메서드의 매개변수의 필드인 <strong>dollar.amount</strong>를 사용하여 중복을 제거했다.<br>하나의 특별한 사례(<code>$5 + $2 = $7</code>)에서만 동작하게 끔 상수(<code>7</code>)를 박았다가 다른 여러 사례(<code>$6 + $3 = $9</code> 등)에 대해서도 작동할 수 있도록 변수(<code>this.amount + dollar.amount</code>)를 사용하여 일반화 시킴으로써 중복을 제거한 것이다.<br>이렇게 성공하는 테스트를 먼저 작성해놓고 보면(일부는 실패했지만) 테스트의 수정없이(퍼블릭 API의 변경 없이) 소스코드의 수정이 매우 자유로워진다.<br>즉, 테스트만 깨지지 않으면 되기 때문에 리팩토링하기 매우 좋은 환경이 제공된다.</p><h2 id="Franc-클래스-구현하기"><a href="#Franc-클래스-구현하기" class="headerlink" title="Franc 클래스 구현하기"></a>Franc 클래스 구현하기</h2><p>Franc 클래스도 Dollar 클래스와 내용이 별반 다를 게 없으므로 우선 테스트를 복붙해주자. (어떻게 구현할지 명확해지면 좀 더 보폭을 넓혀도 된다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrancTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TestFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `test addition`<span class="params">()</span></span> = listOf(</span><br><span class="line">        Pair(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">        Pair(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    ).map &#123; (augendAmount, addendAmount) -&gt;</span><br><span class="line">        dynamicTest(<span class="string">&quot;<span class="subst">$&#123;augendAmount&#125;</span>CHF + <span class="subst">$&#123;addendAmount&#125;</span>CHF = <span class="subst">$&#123;augendAmount + addendAmount&#125;</span>CHF&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// Given</span></span><br><span class="line">            <span class="keyword">val</span> augend = Franc(augendAmount)</span><br><span class="line">            <span class="keyword">val</span> addend = Franc(addendAmount)</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// When</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">actual</span> = augend + addend</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Then</span></span><br><span class="line">            <span class="keyword">val</span> expected = Franc(augendAmount + addendAmount)</span><br><span class="line">            <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `5CHF + 2CHF != 10CHF`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> five = Franc(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">val</span> two = Franc(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span> = five + two</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">val</span> notExpected = Franc(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">actual</span> shouldNotBe notExpected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 컴파일이 되도록 하면 되는데 우리는 어떻게 구현해야할지 Dollar 클래스의 테스트를 작성하면서 명확해졌으므로 Dollar 클래스의 구현체도 복붙하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Franc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(franc: <span class="type">Franc</span>)</span></span>: Franc &#123;</span><br><span class="line">        <span class="keyword">return</span> Franc(<span class="keyword">this</span>.amount + franc.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴파일이 가능해짐과 동시에 모든 테스트가 성공한다.<br>모든 부분을 Dollar 테스트를 통해 검증했던 부분을 그대로 복붙한 것이므로 딱히 손 볼 곳이 없다.</p><h2 id="Dollar-Franc-중복-제거하기"><a href="#Dollar-Franc-중복-제거하기" class="headerlink" title="Dollar/Franc 중복 제거하기"></a>Dollar/Franc 중복 제거하기</h2><p>우선 두 클래스의 plus/equals 메서드를 보면 반환 타입만 다르거나 타입 캐스팅하는 부분만 다를 뿐, 로직은 동일하다.<br>이 로직의 중복을 제거하려면 어떻게 해야할까?<br>가장 빠르게 떠오른 방법은 두 클래스의 중복을 묶어줄(?) 상위 클래스가 있으면 될 거 같다.  </p><p>우선 DollarTest에서 Money 타입을 사용하도록 아래와 같이 수정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DollarTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TestFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `test addition`<span class="params">()</span></span> = listOf(</span><br><span class="line">        Pair(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">        Pair(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    ).map &#123; (augendAmount, addendAmount) -&gt;</span><br><span class="line">        dynamicTest(<span class="string">&quot;$<span class="subst">$&#123;augendAmount&#125;</span> + $<span class="subst">$&#123;addendAmount&#125;</span> = $<span class="subst">$&#123;augendAmount + addendAmount&#125;</span>&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// Given</span></span><br><span class="line">            <span class="keyword">val</span> augend: Money = Dollar(augendAmount)</span><br><span class="line">            <span class="keyword">val</span> addend: Money = Dollar(addendAmount)</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// When</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">actual</span>: Money = augend + addend</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Then</span></span><br><span class="line">            <span class="keyword">val</span> expected: Money = Dollar(augendAmount + addendAmount)</span><br><span class="line">            <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `$5 + $2 != $10`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> five: Money = Dollar(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">val</span> two: Money = Dollar(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span>: Money = five + two</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">val</span> notExpected: Money = Dollar(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">actual</span> shouldNotBe notExpected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.notion.so/perfectacle/f06f6cd942e54d5f86e657b1452eb243">상속은 죄악</a>이라고 하니까 우선 Money 인터페이스로 빼서 컴파일 되게 구현해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> amount: <span class="built_in">Long</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 다음엔 Dollar 클래스가 Money 인터페이스를 구현하게 끔 수정해보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>): Money &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Dollar</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선 테스트가 통과하긴 하는데… 이렇게 해선 plus/equals 메서드를 Dollar 클래스에서 제거할 수 없다. (Franc 클래스에서도 마찬가지일 것이다.)<br>인터페이스의 plus/equals 메서드를 디폴트 메서드로 빼면 되긴 하는데 개인적으로 인터페이스의 취지에 적합하지 않다고 판단하여 적당히 타협하여 인터페이스를 추상 클래스로 변경해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Money</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dollar 클래스를 Money 인터페이스 구현에서 추상 클래스 상속으로 변경해주자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount)</span><br></pre></td></tr></table></figure><p>오! 모든 테스트가 통과하고 드디어 Dollar 클래스에서 plus/equals 메서드를 제거했고, Dollar 클래스만 봤을 때 딱히 하는 일이 없어 보인다.<br>뭔가 냄새…가 나지만 아직은 좀 참고, Franc 메서드의 plus/equals도 제거해보자.<br>우선은 FrancTest에서 Franc 대신에 Money를 사용하게 끔 수정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrancTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TestFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `test addition`<span class="params">()</span></span> = listOf(</span><br><span class="line">        Pair(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">        Pair(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    ).map &#123; (augendAmount, addendAmount) -&gt;</span><br><span class="line">        dynamicTest(<span class="string">&quot;<span class="subst">$&#123;augendAmount&#125;</span>CHF + <span class="subst">$&#123;addendAmount&#125;</span>CHF = <span class="subst">$&#123;augendAmount + addendAmount&#125;</span>CHF&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// Given</span></span><br><span class="line">            <span class="keyword">val</span> augend: Money = Franc(augendAmount)</span><br><span class="line">            <span class="keyword">val</span> addend: Money = Franc(addendAmount)</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// When</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">actual</span>: Money = augend + addend</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Then</span></span><br><span class="line">            <span class="keyword">val</span> expected: Money = Franc(augendAmount + addendAmount)</span><br><span class="line">            <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `5CHF + 2CHF != 10CHF`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> five: Money = Franc(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">val</span> two: Money = Franc(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span>: Money = five + two</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">val</span> notExpected: Money = Franc(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">actual</span> shouldNotBe notExpected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Franc 클래스가 Money 추상 클래스를 상속하도록 수정하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount)</span><br></pre></td></tr></table></figure><p>오! 드디어 Franc에서도 plus/equals 메서드를 제거했다.<br>하지만 테스트를 돌려보면 test addition 테스트가 깨진다.<br><code>org.opentest4j.AssertionFailedError: expected:&lt;com.example.demo.Franc@3e08ff24&gt; but was:&lt;com.example.demo.Dollar@70ed52de&gt;</code></p><p>Money 클래스의 plus 메서드가 Dollar 구체 클래스를 반환하기 때문에 발생하는 문제다.<br>일단 테스트가 깨졌기 때문에 한 발짝 물러서서 Dollar, Franc, Money 클래스와 테스트 코드를 전부 롤백하고 다시 보폭을 줄여보자.  </p><h2 id="하위-클래스의-직접적인-참조-줄이기"><a href="#하위-클래스의-직접적인-참조-줄이기" class="headerlink" title="하위 클래스의 직접적인 참조 줄이기"></a>하위 클래스의 직접적인 참조 줄이기</h2><p>책 88P에는 아래와 같이 나와있다.</p><blockquote><p><strong>하위 클래스</strong>에 대한 <strong>직접적인 참조</strong>가 적어진다면 하위 클래스를 제거하기 위해 한 발짝 더 다가섰다고 할 수 있겠다.</p></blockquote><p>DollarTest 클래스에서 Money의 하위 클래스인 Dollar 클래스에 직접적으로 접근하는 부분은 <strong>생성자</strong>를 통해 객체를 생성하는 부분과 <strong>plus 메서드의 반환타입</strong>이다.<br>생성자는 팩토리 메서드를 통해 직접 참조를 제거하면 되고, plus 메서드의 반환타입은 Money를 반환하게 끔 수정하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DollarTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TestFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `test addition`<span class="params">()</span></span> = listOf(</span><br><span class="line">        Pair(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">        Pair(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    ).map &#123; (augendAmount, addendAmount) -&gt;</span><br><span class="line">        dynamicTest(<span class="string">&quot;$<span class="subst">$&#123;augendAmount&#125;</span> + $<span class="subst">$&#123;addendAmount&#125;</span> = $<span class="subst">$&#123;augendAmount + addendAmount&#125;</span>&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// Given</span></span><br><span class="line">            <span class="keyword">val</span> augend: Money = Money.dollar(augendAmount)</span><br><span class="line">            <span class="keyword">val</span> addend: Money = Money.dollar(addendAmount)</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// When</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">actual</span>: Money = augend + addend</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Then</span></span><br><span class="line">            <span class="keyword">val</span> expected: Money = Money.dollar(augendAmount + addendAmount)</span><br><span class="line">            <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `$5 + $2 != $10`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> five: Money = Money.dollar(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">val</span> two: Money = Money.dollar(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span>: Money = five + two</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">val</span> notExpected: Money = Money.dollar(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">actual</span> shouldNotBe notExpected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 컴파일이 되도록 수정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dollar</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Dollar(amount)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 팩토리 메서드가 부모 클래스 타입을 리턴하도록 변경하였으므로 부모 클래스 API에 plus 메서드가 추가돼야한다.</span></span><br><span class="line">    <span class="comment">// Money 클래스에서 plus 메서드를 구현하면 Dollar/Franc 구체 클래스 중 하나를 선택해야하는데</span></span><br><span class="line">    <span class="comment">// 그러면 Dollar나 Franc의 equals 메서드에 대한 테스트가 깨져버리므로 우선 자식 클래스에게 위임해두자. </span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Money에 Dollar 객체를 생성하는 static factory method를 추가했고 plus 추상 메서드도 추가했다.<br>다시 Dollar에서 Money를 상속 받게 끔 하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>): Money() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 돌리면 성공한다.  </p><p>이번에는 FrancTest에서 Franc(Money의 하위클래스)에 대한 참조를 없애보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrancTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TestFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `test addition`<span class="params">()</span></span> = listOf(</span><br><span class="line">        Pair(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">        Pair(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    ).map &#123; (augendAmount, addendAmount) -&gt;</span><br><span class="line">        dynamicTest(<span class="string">&quot;<span class="subst">$&#123;augendAmount&#125;</span>CHF + <span class="subst">$&#123;addendAmount&#125;</span>CHF = <span class="subst">$&#123;augendAmount + addendAmount&#125;</span>CHF&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// Given</span></span><br><span class="line">            <span class="keyword">val</span> augend: Money = Money.franc(augendAmount)</span><br><span class="line">            <span class="keyword">val</span> addend: Money = Money.franc(addendAmount)</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// When</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">actual</span>: Money = augend + addend</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Then</span></span><br><span class="line">            <span class="keyword">val</span> expected: Money = Money.franc(augendAmount + addendAmount)</span><br><span class="line">            <span class="keyword">actual</span> shouldBe expected</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `5CHF + 2CHF != 10CHF`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">val</span> five: Money = Money.franc(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">val</span> two: Money = Money.franc(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">actual</span>: Money = five + two</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        <span class="keyword">val</span> notExpected: Money = Money.franc(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">actual</span> shouldNotBe notExpected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 컴파일이 되도록 수정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dollar</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Dollar(amount)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">franc</span><span class="params">(amount: <span class="type">Long</span>)</span></span>: Money = Franc(amount)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 팩토리 메서드가 부모 클래스 타입을 리턴하도록 변경하였으므로 부모 클래스 API에 plus 메서드가 추가돼야한다.</span></span><br><span class="line">    <span class="comment">// Money 클래스에서 plus 메서드를 구현하면 Dollar/Franc 구체 클래스 중 하나를 선택해야하는데</span></span><br><span class="line">    <span class="comment">// 그러면 Dollar나 Franc의 equals 메서드에 대한 테스트가 깨져버리므로 우선 자식 클래스에게 위임해두자.</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Money에 Franc 객체를 생성하는 static factory method를 추가했고 다시 Franc에서 Money를 상속 받게 끔 하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> amount: <span class="built_in">Long</span>): Money() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Franc(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 모든 테스트가 통과한다.<br>외부에서 바라봤을 때는 객체의 생성이 <strong>직접적인 생성자를 통한 생성</strong>에서 <strong>외부 클래스의 static factory method를 통한 생성</strong>으로 바뀌었고, plus 메서드의 <strong>반환 타입이 부모 클래스</strong>로 바뀌었을 뿐이다.<br>이것이 무엇을 의미하는지는 책 90P에 나온다.</p><blockquote><p>어떤 클라이언트(현재 우리 예제에서는 테스트) 코드도 Dollar(또는 Franc)라는 이름의 하위 클래스가 있다는 사실을 알지 못한다.<br><strong>하위 클래스의 존재</strong>를 **테스트에서 분리(decoupling)**함으로써 <strong>어떤 모델 코드에도 영향</strong>을 주지 않고 <strong>상속 구조를 마음대로 변경</strong>할 수 있게 됐다.</p></blockquote><p>외부에서는 Money 클래스 밖에 모르므로 상속 구조가 마음껏 바뀌어도 끽해봐야 Money 타입이기 때문에 클라이언트 측에는 전혀 영향을 미치지 않는 것이다.<br>하위 클래스의 직접 참조를 제거한 것만으로 하위 클래스 제거에 큰 한 걸음을 나간 것이나 마찬가지다.<br>여기서 멈추지 말고 각 하위 클래스에 있는 equals 메서드를 부모 클래스로 올려서 하위 클래스에서 제거해보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(<span class="keyword">val</span> amount: <span class="built_in">Long</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        other <span class="keyword">as</span> Money</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount != other.amount) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 각 하위 클래스에서 컴파일이 되도록 수정하고, equals 메서드도 제거해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span>(amount: <span class="built_in">Long</span>): Money(amount) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Dollar(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Franc</span></span>(amount: <span class="built_in">Long</span>): Money(amount) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">return</span> Franc(<span class="keyword">this</span>.amount + money.amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다시 모든 테스트를 돌려보면 전부 통과한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p><strong>하위 클래스에 대한 직접적인 참조를 제거</strong>하면 <strong>외부(클라이언트)에 영향 없이 상속 구조를 마음껏 수정</strong>할 수 있다는 사실에 큰 감명을 받았다.<br>plus 메서드까지 제거하는 방법을 보기 위해서는 <a href="/2020/06/11/how-to-make-subclasses-easy-to-remove/">하위 클래스를 제거하기 쉽게 만드는 방법</a>을 보자.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=7443642&quot;&gt;TDD By Example&lt;/a&gt; 책을 보다가 감명 받은 부분을 정리해봤다.&lt;br&gt;기본적으로 아래 4가지 원칙을 따라 진행한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Red - &lt;strong&gt;실패&lt;/strong&gt;하는 &lt;strong&gt;작은&lt;/strong&gt; 테스트를 작성(최초에는 컴파일 조차 되지 않음)&lt;/li&gt;
&lt;li&gt;Green - &lt;strong&gt;빨리&lt;/strong&gt; 테스트가 &lt;strong&gt;통과&lt;/strong&gt;하게 끔 수정(이를 위해선 어떠한 &lt;strong&gt;죄악&lt;/strong&gt;도 용서됨)&lt;/li&gt;
&lt;li&gt;Refactoring - 모든 &lt;strong&gt;중복&lt;/strong&gt;을 &lt;strong&gt;제거&lt;/strong&gt;(2번에서 수행한 죄악들을 청산)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.&lt;br&gt;해당 포스트도 위 두가지 통화에 대해 덧셈 연산을 테스트 하는 작은 코드로 시작한다.&lt;br&gt;(기본적으로 코틀린, JUnit5, kotest를 사용했다)&lt;br&gt;기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 &lt;a href=&quot;#%ED%95%98%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%A7%81%EC%A0%91%EC%A0%81%EC%9D%B8-%EC%B0%B8%EC%A1%B0-%EC%A4%84%EC%9D%B4%EA%B8%B0&quot;&gt;하위 클래스의 직접적인 참조 줄이기&lt;/a&gt;를 보면 된다.&lt;/p&gt;
&lt;h2 id=&quot;Dollar-클래스-구현하기&quot;&gt;&lt;a href=&quot;#Dollar-클래스-구현하기&quot; class=&quot;headerlink&quot; title=&quot;Dollar 클래스 구현하기&quot;&gt;&lt;/a&gt;Dollar 클래스 구현하기&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DollarTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; `$5 + $2 = $7`&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Given&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; five = Dollar(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; two = Dollar(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// When&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;actual&lt;/span&gt; = five + two&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; expected = Dollar(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;actual&lt;/span&gt; shouldBe expected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Study" scheme="https://perfectacle.github.io/categories/Note/Study/"/>
    
    
    <category term="TDD" scheme="https://perfectacle.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>(Hexo) NexT 테마에서 &#39;더 읽어보기&#39;를 설정하는 방법</title>
    <link href="https://perfectacle.github.io/2020/05/31/how-to-set-read-more-in-next-theme/"/>
    <id>https://perfectacle.github.io/2020/05/31/how-to-set-read-more-in-next-theme/</id>
    <published>2020-05-31T03:15:21.000Z</published>
    <updated>2020-08-23T16:18:44.782Z</updated>
    
    <content type="html"><![CDATA[<p><code>themes/next/_config.yml</code>을 보면 아래와 같이 기본적으로 ‘더 읽어보기’가 세팅돼있다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt (Not recommend).</span></span><br><span class="line"><span class="comment"># Use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button would be displayed in excerpt section.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>하지만 NexT Theme 7.6.0 이상의 버전에서는 위와 같이 설정이 돼있어도 ‘더 읽어보기’가 나오지 않는다.<br>이럴 때는 <a href="https://github.com/chekun/hexo-excerpt">hexo-excerpt</a> 플러그인을 설치해주면 해결된다. <span class="emoji" alias="tada" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">&#x1f389;</span><br><a href="https://github.com/theme-next/hexo-theme-next/issues/1245#issuecomment-558486354">https://github.com/theme-next/hexo-theme-next/issues/1245#issuecomment-558486354</a></p><blockquote><p>If you are using NexT 7.6.0 and later, please install the plugin: <a href="https://github.com/chekun/hexo-excerpt">https://github.com/chekun/hexo-excerpt</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;themes/next/_config.yml&lt;/code&gt;을 보면 아래와 같이 기본적으로 ‘더 읽어보기’가 세팅돼있다.&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
    <category term="잡동사니" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"/>
    
    
    <category term="Hexo" scheme="https://perfectacle.github.io/tags/Hexo/"/>
    
    <category term="Theme" scheme="https://perfectacle.github.io/tags/Theme/"/>
    
    <category term="NexT" scheme="https://perfectacle.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>공인인증서</title>
    <link href="https://perfectacle.github.io/2020/01/24/korean-certification/"/>
    <id>https://perfectacle.github.io/2020/01/24/korean-certification/</id>
    <published>2020-01-24T06:52:03.000Z</published>
    <updated>2020-08-23T16:35:51.853Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/korean-certification/thumb.png" alt="npki라는 디렉리토리 안에 보관돼있는 공인인증서의 공개키(*.der)와 비밀키(*.key)"></p><h2 id="인증서는-왜-쓸까"><a href="#인증서는-왜-쓸까" class="headerlink" title="인증서는 왜 쓸까"></a>인증서는 왜 쓸까</h2><p>A가 데이터를 보냈는데 이게 진짜 A가 보낸 건지 아닌지를 검증할 수가 없다.<br>인증서는 A라는 사람이라는 것을 <strong>보증해주는 문서</strong>라고 보면 된다.<br>따라서 A한테 메세지가 올 때 A의 인증서가 오지 않는다면 A라고 취급을 하지 않으면 된다.<br>하지만 개나소나 인증서를 발급할 수 있으면 A 행세를 아무나 낼테니까 **인증된 기관(CA, Certificate Authority)**으로부터 적절한 절차를 거쳐 인증서를 발급받을 수 있다.</p><p><img src="/images/korean-certification/google-certificate.png" alt="구글에서 사용 중인 인증서"><br>우리가 알고 있는 TLS 인증서(https 도메인마다 발라져있는) 같은 경우에도 이런 절차를 거쳐 발급된다.<br>그리고 이런 인증서들은 **X.509(공개키 인증서 포맷의 표준)**라는 표준을 준수한다.</p><h2 id="공인인증서는-왜-나왔을까"><a href="#공인인증서는-왜-나왔을까" class="headerlink" title="공인인증서는 왜 나왔을까"></a>공인인증서는 왜 나왔을까</h2><p>인터넷 뱅킹이나 온라인 쇼핑몰 등등을 이용하기 위해서는 보안이 취약해서는 안되며 이를 위해서 인증서 사용은 필수이다.</p><p><a href="https://news.joins.com/article/521864">https://news.joins.com/article/521864</a><br>하지만 과거에는 미국의 수출 금지법에 의해 미국을 제외한 나라에서는 브라우저에서 56bit 길이 이하의 약한 암호화 방식 밖에 사용할 수 없었다.</p><p>따라서 국내에서 직접 암호화 알고리즘인 SEED(128bit 길이, 2009년부터는 256bit 길이도 제공)를 개발하고,<br>해당 알고리즘을 사용하는 <strong>공인인증서</strong>도 만들게 되었다. 하지만 국제 표준 암호 알고리즘도 아니고 국내에서만 인증된 CA에서 발급한 인증서이다보니 웹 브라우저에서 사용할 수 없었다.<br>따라서 당시 국내 점유율이 압도적인 IE에서 사용이 가능한 ActiveX라는 기술을 사용하여 공인인증서를 사용할 수 있게 만들었다.</p><p>과거에는 어쩔 수 없는 선택일 수 밖에 없었을 것 같은데 브라우저에서 해당 제약이 사라진 요즘같은 시대에<br>비표준 기술을 위해 ActiveX나 설치형 프로그램을 잔뜩 깔아야하는 건 아마 여러 이해관계가 얽혀있기 때문이 아닐까 싶다.<br>(그 때문에 사용자만 엄청 고생하는 ㅠㅠ…)</p><h2 id="공인인증서-구조"><a href="#공인인증서-구조" class="headerlink" title="공인인증서 구조"></a>공인인증서 구조</h2><p><img src="/images/korean-certification/certifiacate-and-key.png" alt="공인인증서와 개인키 파일"><br>MacOS는 /Users/사용자이름/Library/Preferences/NPKI,<br>Windows 10는 C:\Users\사용자이름\AppData\LocalLow\NPKI에 위치하고 있다.</p><p>공인인증서(*.der, *.cer 등등)와 개인키(*.key)파일로 이루어져있다.<br>아니면 공인인증서와 개인키 파일이 합쳐진 형태(*.p12, *.pfx 등등)로 이루어진 경우도 있다.<br>공인인증서와 개인키 파일이 합쳐진 형태는 PKCS#12(<strong>P</strong>ublic <strong>K</strong>ey <strong>C</strong>ryptography <strong>S</strong>tandards, 공개키 암호화 표준의 12번째 표준)을 준수하고 있다.<br>PKCS#12는 다수의 <code>X.509 인증서 + 개인키</code> 묶음을 하나의 파일로 저장하기 위한 표준이다.</p><h2 id="공인인증서"><a href="#공인인증서" class="headerlink" title="공인인증서"></a>공인인증서</h2><p>*.cer(Canonical Encoding Rules) 또는 *.der(Distinguished Encoding Representation)과 같은 확장자를 가지며 바이너리 형태로 인코딩 돼있다.</p><p><img src="/images/korean-certification/certificate.png" alt="MacOS의 Keychain Access에서 본 공인인증서 정보"><br>공인인증서는 <strong>X.509 V3</strong>을 따른다.<br>또한 공인인증서 소유자의 <strong>공개키</strong> + CA(Certificate Authority, 발행기관) 정보 및 <strong>전자서명</strong> + 사용목적 + 유효기간 등등이 저장돼있다.</p><p>위 인증서는 은행에서 사용 중인 공인인증서인데 은행에 대한 정보는 1도 없다.<br>아마 은행은 CA가 아니기 때문에 CA에게 대신 발급 요청(CSR, Certificate Signing Request)을 하고 발급받은 인증서를 개인에게 전달해주는 시스템 같다.<br>아마 보안모듈은 공인인증서를 전달받으면 해당 CA로부터 발급된 인증서가 맞는지 검증까지 해주는 것 같다.<br>(TLS 인증서였다면 이런 행위는 브라우저가 알아서 해주겠지만…)<br>CA(인증서 발급 기관, Certificate Authority)에게 인증서 발급을 요청할 때 요청자의 공개키를 함께 보낸다.<br>그러면 CA는 서명(CA의 개인키로 암호화)한 인증서를 발급해준다.<br>그리고 인증서 안에는 <strong>인증서 발급 요청자의 공개키</strong>가 포함돼있고, 어떤 용도의 인증서인지,<br>어느 기관(CA, Certificate Authority)에서 발급한 건지 등등의 정보가 포함돼있다.</p><p><img src="/images/korean-certification/not-trusted-certificate.png" alt="MacOS의 Keychain Access에서 공인인증서는 신뢰할 수 없다고 나온다."><br>또한 공인인증서는 국내에서만 사용하는 인증서이기 때문에 OS 레벨에서는 해당 인증서가 신뢰된 CA로부터 발급받은 인증서인지 알 수가 없다.<br>(그냥 은행이나 공공기관 등등을 믿고 쓰는 수 밖에…)</p><h2 id="비밀키-key"><a href="#비밀키-key" class="headerlink" title="비밀키 (*.key)"></a>비밀키 (*.key)</h2><p><img src="/images/korean-certification/key-format-desc.png"><br><a href="https://www.rootca.or.kr/kor/accredited/accredited06_01.jsp">전자서명인증관리센터</a>에 보면 PKCS#5와 PKCS#8 형식이라고 나와있다.</p><blockquote><p>In cryptography, PKCS #8 is a standard syntax for storing private key information.<br>  The PKCS #8 private key may be encrypted with a passphrase using the PKCS #5 standards,<br>  which supports multiple ciphers.</p></blockquote><p>PKCS#8(Private-Key Information Syntax Standard)이 뭔지 찾아보니 <a href="https://en.wikipedia.org/wiki/PKCS_8">위키피디아</a>에서는 개인키 저장을 위한 문법 표준이라고 하고 있다.<br>웬만한 개인키는 다 이 형식을 따르는 것 같다.<br>여기서 말하는 passphrase는 사용자가 공인인증서를 만들 때 입력한 비밀번호를 의미한다.</p><p>이번엔 PKCS#5(Password-Based Cryptography Standard)가 뭔지 찾아보니 패스워드를 깨먹기 어렵게 하기 위한 표준 같아 보였다.<br>그 안에는 Key Derivation Functions라는 게 있는데 패스워드 + salt + 이터레이션 카운트(해당 함수를 몇 번 이터레이션 돌릴지) 등등을 인자로 받아서 추가 연산을 진행하는 함수인데,<br>패스워드를 빠르게 계산하기 어렵게 해서 해커가 공격을 빠르게 하지 못하게 막기 위해 사용하는 함수 같다.<br>이런 Key Derivation Function을 커스텀하게 구현해도 되지만 좀 더 검증되고 표준에 등재된<br>PBKDF1과 PBKDF2가 있는데 공인인증서는 두 가지 방식을 모두 지원한다.</p><p>그리고 공인인증서의 개인키는 SEED 알고리즘으로 암호화해서 저장돼있다고 하니 개인키를 얻어오려면 복호화를 해야한다.</p><h2 id="ASN-1-Abstract-Syntax-Notation-One"><a href="#ASN-1-Abstract-Syntax-Notation-One" class="headerlink" title="ASN.1(Abstract Syntax Notation One)"></a>ASN.1(Abstract Syntax Notation One)</h2><p>X.509 인증서의 데이터 구조는 ASN.1 표기법에 의해 표기된다.<br>따라서 디코딩해보면 더 많은 정보를 얻어낼 수 있는데 온라인에서 디코딩을 할 수 있다.  </p><p><img src="/images/korean-certification/asn1-certificate.png" alt="공인인증서를 ASN.1 표기법으로 표기"><br><a href="https://lapo.it/asn1js">https://lapo.it/asn1js</a>에 들어가서 공인인증서나 개인키 파일을 Base64로 인코딩한 텍스트를 입력한 후에 decode 버튼을 누르면 더 자세한 정보를 볼 수 있다.  </p><p><img src="/images/korean-certification/asn1-key.png" alt="개인키를 ASN.1 표기법으로 표기"><br>개인키 파일을 디코딩해보면 어떤 암호화 알고리즘을 사용했는지, 어떤 KDF(Key Derivation Function)를 사용했는지 나온다.<br>object identifer를 <a href="http://oid-info.com/get/1.2.410.200004.1.4">http://oid-info.com/get/1.2.410.200004.1.4</a>에서 검색하면 더 자세한 정보가 나온다.</p><p><img src="/images/korean-certification/seed-iv.png" alt="개인키를 ASN.1 표기법으로 표기"><br>또한 <a href="http://www.rootca.or.kr/kcac/down/TechSpec/2.3-KCAC.TS.ENC.pdf">SEED 알고리즘 규격 문서</a>를 보면 OID에 따라서 초기 벡터 값을 어떻게 세팅해야하는지 나온다.</p><h2 id="ActiveX로-깔은-모듈-delfino-Xecure-등등-에서는-무슨-일을-할까…"><a href="#ActiveX로-깔은-모듈-delfino-Xecure-등등-에서는-무슨-일을-할까…" class="headerlink" title="ActiveX로 깔은 모듈(delfino, Xecure 등등)에서는 무슨 일을 할까…?"></a>ActiveX로 깔은 모듈(delfino, Xecure 등등)에서는 무슨 일을 할까…?</h2><p><img src="/images/korean-certification/activex-commuicate-local.png" alt="Ajax나 WebSocket을 통해서 주기적으로 로컬과 통신한다."><br>그 안에서 공인인증서도 가져오고, 개인키 파일을 복호화 해서 개인키를 획득하기도 하고…<br>여러가지 행위들을 한다.</p><p><img src="/images/korean-certification/kb-login.png" alt="PKCS7이란 파라미터에 Base64 인코딩 된 스트링을 보내고 있다."><br>PKCS #7(Cryptographic Message Syntax)이 뭔지 찾아보니 전자서명에 대한 표준 같아 보였다.<br>실제로 어떤 카드사의 경우에는 PKCS7 방식으로 전자서명 하는 모듈을 쓰는 곳도 있다.</p><p>근데 PKCS7에 보낸 데이터를 보니 Base64 인코딩 된 스트링이고 이 데이터는 전자서명한 데이터는 아니고,<br>ASN.1 Decoder로 보니 내 공인인증서였다.<br>내 공인인증서를 보냄으로써 내가 맞는지 검증하는 것 같다.<br>하지만 공개키 인증서는 기본적으로 여기저기 공유가 돼도 문제 없도록 만들었다.<br>따라서 저 공인인증서를 내가 전달한 건지, 남이 전달한 건지 서버는 알 길이 없다.</p><p><img src="/images/korean-certification/kb-login-vid-random.png" alt="VID_RANDOM 파라미터에 Base64 인코딩 된 스트링을 보내고 있다."><br><a href="http://www.rootca.or.kr/kcac/down/TechSpec/1.5-KCAC.TS.SIVID.pdf">식별번호를 이용한 본인확인 기술규격</a>을 보면 다음과 같은 부분이 나와있다.<br><code>VID = h(h(IDN, R)</code></p><ul><li>VID: 가상식별번호</li><li>h( ) : 해쉬 함수</li><li>IDN : 식별번호</li><li>식별번호 : 전자서명법 시행규칙 제13조의2에 의한 주민등록번호, 사업자등록번호 및 고유번호</li><li>R: 비트열 난수<br><code>본 규격에서는 적어도 160비트 이상의 안전한 임의의 난수를 생성하여 사용해야한다. 난수는 가상 식별번호를 생성하는데 사용되며 가상 식별번호와 함께 공인인증기관에 전달되어 공인인증기관이 식별번호를 검증하는데 사용된다.</code><br>국민은행 측에 보낸 VID_RANDOM 값을 Base64 디코딩해보면 20바이트(160비트)의 데이터가 나온다.<br><img src="/images/korean-certification/vid-random.png" alt="R 값은 개인을 식별하기 위한 아주 중요한 정보이다."></li></ul><p>따라서 보안 모듈에서는 다음과 같은 행동이 일어났다.</p><ol><li>공인인증서 목록을 불러온다.</li><li>비밀번호를 입력받아서 개인키를 복호화한다.</li><li>복호화한 개인키에서 R값을 가져온다.</li><li>js에서 보안모듈(127.0.0.1)과 통신을 해서 R값과 공인인증서 값을 받아와서 국민은행 사이트에게 ajax로 요청을 보낸다.</li><li>해당 유저의 공인인증서와 R값이 맞다면 로그인을 성공시킨다.</li></ol><p>모듈마다 어떻게 인증 절차를 거치는지 다 다르다.<br>어떤 모듈은 PKCS7 방식으로 전자서명한 데이터를 보내는 모듈도 있고, 어떤 모듈은 추출한 R 값을 한 번 더 암호화 해서 보내는 곳도 있고,<br>어떤 곳은 Base64 인코딩이 아닌 Hex 인코딩을 사용하는 곳도 있다.<br>하지만 같은 모듈을 사용하는 은행/카드사가 있다면 비슷한 방식을 통해 로그인 과정이 이뤄진다.<br>(하나를 뚫으면 여러 벤더사를 함께 뚫을 수 있게 된다.)</p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://www.letmecompile.com/certificate-file-format-extensions-comparison/https://www.letmecompile.com/certificate-file-format-extensions-comparison/">https://www.letmecompile.com/certificate-file-format-extensions-comparison/</a></li><li><a href="https://indienote.tistory.com/272">https://indienote.tistory.com/272</a></li><li><a href="https://indienote.tistory.com/273">https://indienote.tistory.com/273</a></li><li><a href="https://www.slideshare.net/ied206/4th-inc0gnito">https://www.slideshare.net/ied206/4th-inc0gnito</a></li><li><a href="https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0">https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0</a></li><li><a href="https://news.joins.com/article/521864">https://news.joins.com/article/521864</a></li><li><a href="https://www.rootca.or.kr/kcac/down/TechSpec/2.3-KCAC.TS.ENC.pdf">SEED 암호 알고리즘 규격</a> </li><li><a href="https://www.rootca.or.kr/kcac/down/TechSpec/1.1-KCAC.TS.CERTPROF.pdf">전자서명 인증서 프로파일 규격</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/korean-certification/thumb.png&quot; alt=&quot;npki라는 디렉리토리 안에 보관돼있는 공인인증서의 공개키(*.der)와 비밀키(*.key)&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;인증서는-왜-쓸까&quot;&gt;&lt;a href=&quot;#인증서는-왜-쓸까&quot; class=&quot;headerlink&quot; title=&quot;인증서는 왜 쓸까&quot;&gt;&lt;/a&gt;인증서는 왜 쓸까&lt;/h2&gt;&lt;p&gt;A가 데이터를 보냈는데 이게 진짜 A가 보낸 건지 아닌지를 검증할 수가 없다.&lt;br&gt;인증서는 A라는 사람이라는 것을 &lt;strong&gt;보증해주는 문서&lt;/strong&gt;라고 보면 된다.&lt;br&gt;따라서 A한테 메세지가 올 때 A의 인증서가 오지 않는다면 A라고 취급을 하지 않으면 된다.&lt;br&gt;하지만 개나소나 인증서를 발급할 수 있으면 A 행세를 아무나 낼테니까 **인증된 기관(CA, Certificate Authority)**으로부터 적절한 절차를 거쳐 인증서를 발급받을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/korean-certification/google-certificate.png&quot; alt=&quot;구글에서 사용 중인 인증서&quot;&gt;&lt;br&gt;우리가 알고 있는 TLS 인증서(https 도메인마다 발라져있는) 같은 경우에도 이런 절차를 거쳐 발급된다.&lt;br&gt;그리고 이런 인증서들은 **X.509(공개키 인증서 포맷의 표준)**라는 표준을 준수한다.&lt;/p&gt;
&lt;h2 id=&quot;공인인증서는-왜-나왔을까&quot;&gt;&lt;a href=&quot;#공인인증서는-왜-나왔을까&quot; class=&quot;headerlink&quot; title=&quot;공인인증서는 왜 나왔을까&quot;&gt;&lt;/a&gt;공인인증서는 왜 나왔을까&lt;/h2&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
    <category term="보안" scheme="https://perfectacle.github.io/tags/%EB%B3%B4%EC%95%88/"/>
    
    <category term="공인인증서" scheme="https://perfectacle.github.io/tags/%EA%B3%B5%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%84%9C/"/>
    
  </entry>
  
  <entry>
    <title>AES 256 CBC + PBKDF2</title>
    <link href="https://perfectacle.github.io/2019/11/24/aes/"/>
    <id>https://perfectacle.github.io/2019/11/24/aes/</id>
    <published>2019-11-24T00:59:51.000Z</published>
    <updated>2020-08-23T16:18:44.683Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/aes/thumb.png">  </p><p>막연하게 양방향 암호화 하면 당연스레 AES를 떠올리고, 제대로 모른 채로 사용했다.<br>이제부터라도 조금은 알고 써야겠다는 생각이 들어서 살짝 정리해봤다.</p><h2 id="양방향-단방향-암호화"><a href="#양방향-단방향-암호화" class="headerlink" title="양방향/단방향 암호화"></a>양방향/단방향 암호화</h2><p>양방향 암호화는 암호화 및 복호화가 가능하다는 소리다.<br>휴대폰 번호 등등 민감한 개인정보는 암호화 해서 저장해야하는데 고객 정보를 식별하기 위해선 복호화도 가능해야한다.<br>혹시나 키와 DB가 털린다면 복호화가 가능하므로 적어도 개인정보는 마스킹 한 후에 암호화해서 저장해야한다.<br>양방향 암호화 알고리즘에는 DES(보안에 취약), <strong>AES</strong>, SEED(국내에서 개발, 공인인증서에 사용됨) 등등이 있다.</p><p>단방향 암호화는 암호화만 가능하고 복호화는 불가능하다는 소리다.<br>비밀번호와 같이 암호화 한 값들끼리 단순히 비교만 하면 되고, 복호화 할 필요가 없는 정보들은 단방향 암호화 해야한다.<br>혹시나 키와 DB가 털려도 복호화가 불가능하기 때문에 암호화된 값만 알 수 있지 원본 비밀번호는 알 수 없기 때문에 양방향 암호화 보다는 좀 더 안전하다.<br>이런 특성 때문에 비밀번호 찾기 대신에 비밀번호 재설정 기능 밖에 지원 할 수 없다. (비밀번호 찾기를 지원해주는 사이트는 보안이 매우 안 좋은 사이트이다.)<br>단방향 암호화 알고리즘에는 해시 알고리즘이 사용되며 SHA256, SHA512, MD5(무작위 대입 공격에 약함) 등등이 있다.</p><h2 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES (Advanced Encryption Standard)"></a>AES (Advanced Encryption Standard)</h2><p>DES 암호화 방식에 결함이 발견되어 그 이후에 미국에서 열린 암호화 공모전에서 채택된 알고리즘이다.<br>대칭키 방식이라 암호화 및 복호화에 사용되는 키 값이 동일하다.<br>서버에서 사용되는 AES의 키는 대부분 파일로 저장돼있다기 보다는 키 값에 사용될 값을 어디 비밀스러운 공간에 저장해뒀다가 불러오는 예제가 대다수이다.<br>소스코드나 config 파일에 문자열을 하드코딩 해뒀다가 사용하는 곳도 있지만 깃헙 등등이 털리면 답이 없기 때문에 정말 비밀스런 공간에 저장했다가 불러와야한다.<br>(정말 비밀스러운 공간에 잘 저장해뒀다가 불러오는 방법은 자세히는 모르겠다.)</p><h3 id="AES128-vs-AES192-vs-AES256"><a href="#AES128-vs-AES192-vs-AES256" class="headerlink" title="AES128 vs AES192 vs AES256"></a>AES128 vs AES192 vs AES256</h3><p>키 값의 길이에 따라 AES128(128 bit == 16 byte), AES192(192 bit == 24 byte), **AES256(256 bit == 32 byte)**으로 나뉜다.<br>키 값이 길면 길수록 무작위 대입 공격에 유리하다는 장점이 있다.<br>예를 들면 AES128은 2¹²⁸번 시도해서 공격에 성공한다면 AES256은 2²⁵⁶번 시도해야 성공할 수 있다.</p><p>하지만 이것 외에 또 다른 차이점이 있는데, 암호화에는 Round라는 게 존재한다.<br>예를 들면 1Round에는 bit-rotation을 진행하고, 2Round에는 1Round에서 나온 걸 XOR 연산하고, 뭐 이런 식으로 각 Round 별로 암호화에 필요한 연산을 진행하게 된다.<br>AES128은 10Round, AES192는 12Round, AES256은 14Round에 걸쳐 암호화를 진행한다.  </p><p>따라서 AES256은 키 값이 길어서 무작위 대입에도 유리하고, 암호화에 진행되는 Round도 많다보니 다른 방식에 비해 더 우수한 알고리즘이다.<br>물론 컴퓨팅 파워를 더 쓰긴 하겠지만, 요즘 서버 스펙에는 큰 무리는 되지 않는다.<br>오히려 불필요하게 빠르면 무작위 대입 공격에 더 불리해질 뿐이다. (유저 입장에서는 ms 단위의 차이는 체감도 하지 못할 수준일 것이다.)</p><h3 id="Block-Cipher"><a href="#Block-Cipher" class="headerlink" title="Block Cipher"></a>Block Cipher</h3><p>AES는 128 bit(16 byte)라는 고정된 블럭 단위로 암호화를 수행한다.<br>이는 키 값의 길이와는 전혀 무관하다.<br>하지만 AES는 128 bit까지만 암호화 할 수 있으므로 128 bit가 넘어가는 데이터를 암호화하기 위해 <strong>Block Cipher Mode</strong>(EBC, <strong>CBC</strong> 등등)를 선택해야한다.<br>즉 256 bit의 평문을 암호화 할 때 두 개의 128 bit로 쪼개서 각각 암호화를 수행하게 된다.  </p><p>또한 128 bit의 블럭으로 쪼개기 때문에 128 bit 보다 작은 블럭이 나올 수 있는데 이런 블럭은 뒤에 값을 붙여주는데 이 값을 <strong>padding</strong>이라고 부른다.<br>이따 나올 예제에서 사용하는 패딩의 종류를 보면 PKCS#5 padding을 사용하고 있다.<br>하지만 PKCS#5 padding은 8 byte 블럭에 대한 패딩인데 왜 PKCS#5 padding을 사용하는지 의문을 가지게 된다.<br><a href="https://stackoverflow.com/questions/20770072/aes-cbc-pkcs5padding-vs-aes-cbc-pkcs7padding-with-256-key-size-performance-java#comment31139784_20770158">스택오버플로우의 한 댓글</a>을 살펴보면<br>레거시의 잔재인 것 같고, 내부적으로는 PKCS#7 padding으로 변환되는 것 같다.<br>PKCS#7 padding은 1~255 byte의 block에 대한 패딩을 만들어내는 방식이다.<br>소스 코드에서 PKCS#5 padding을 사용하는 것처럼 보이는 게 싫다면 <a href="https://www.bouncycastle.org/">Bouncy Castle</a>을 사용해야한다.<br>Bouncy Castle 없이 PKCS#7 padding을 사용하려고 하면 java.security.NoSuchAlgorithmException 예외를 만나게 될 것이다.</p><h4 id="EBC-Electronic-Codebook"><a href="#EBC-Electronic-Codebook" class="headerlink" title="EBC (Electronic Codebook)"></a>EBC (Electronic Codebook)</h4><p>짧게 말하면 <strong>실무에서는 절대 사용하면 안 되는</strong> Mode이다.</p><p><img src="/images/aes/ecb-enc.png"><br><img src="/images/aes/ecb-dec.png"><br>이미지 출처: <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB)">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB)</a></p><p>EBC는 각 블럭을 독립적으로 암/복호화한다.<br>독립적으로 암호화하기 때문에 병렬로 암/복호화 할 수 있기 때문에 속도 측면에서 장점을 가진다.<br>또한 키값만 설정하면 되기 때문에 사용하기 쉽다는 장점도 가지고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">&quot;a&quot;</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256ECB &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        SecretKeySpec(KEY.toByteArray(), <span class="string">&quot;AES&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while generating key: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 각각 알고리즘/Block Cipher Mode/Padding 메카니즘이다.</span></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.ENCRYPT_MODE, secretKeySpec)</span><br><span class="line">        cipher.doFinal(plainText.toByteArray())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while encrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 각각 알고리즘/Block Cipher Mode/Padding 메카니즘이다.</span></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKC55PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.DECRYPT_MODE, secretKeySpec)</span><br><span class="line">        String(cipher.doFinal(cipherText))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while decrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PLAIN_TEXT = <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256ECBTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testEncrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 0 ~ 127 bit까지는 한 블럭 안에 담긴다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        assertThat(encrypted?.size).isEqualTo(BLOCK_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDecrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> decrypted = AES256ECB.decrypt(encrypted)</span><br><span class="line"></span><br><span class="line">        assertThat(PLAIN_TEXT).isEqualTo(decrypted)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 각 블럭이 독립적으로 암호화 되기 때문에 더 빨리 공격당하기 쉽고(병렬로 암/복호화 시도), 아래와 같은 결함을 가진다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PLAIN_TEXT = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DUPLICATED_COUNT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256ECBTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `반복된 문자열을 암호화 하면 반복된 암호문 블럭이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 좀 더 깔끔한 예제를 만들기 위해 패딩 값이 없게 끔 각 블럭을 꽉꽉 채워 암호화 시도한다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(PLAIN_TEXT.repeat(BLOCK_SIZE * DUPLICATED_COUNT))</span><br><span class="line">        <span class="keyword">val</span> encryptedBlocks = mutableListOf(</span><br><span class="line">                encrypted?.copyOfRange(BLOCK_SIZE, BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until DUPLICATED_COUNT) &#123;</span><br><span class="line">            <span class="keyword">val</span> firstBlock = encryptedBlocks.first()</span><br><span class="line">            <span class="keyword">val</span> currentBlock = encrypted?.copyOfRange(i * BLOCK_SIZE, i * BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (firstBlock.contentEquals(currentBlock)) <span class="keyword">continue</span></span><br><span class="line">            encryptedBlocks.add(currentBlock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 암호문에 들어간 반복된 문자열들을 추론 가능해짐.</span></span><br><span class="line">        assertThat(encryptedBlocks.size).isEqualTo(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `똑같은 평문을 암호화 하면 똑같은 암호문이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256ECB.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> encrypted2 = AES256ECB.encrypt(PLAIN_TEXT)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 딕셔너리를 만들어두면 어느 정도 암호문의 평문 데이터 추론이 가능해진다.</span></span><br><span class="line">        assertThat(encrypted).isEqualTo(encrypted2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 보안적 결함 때문에 1 ~ 127 bit의 데이터를 암호화 할 때만 사용해야한다고 하던데,<br>그런 거 따질 시간에 그냥 안전한 CBC 모드를 무조건 쓰는 걸 권장한다.  </p><h4 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC (Cipher Block Chaining)"></a>CBC (Cipher Block Chaining)</h4><p>예제를 찾다보면 가장 많이 보이는 Mode인 것 같다.</p><p><img src="/images/aes/cbc-enc.png"><br><img src="/images/aes/cbc-dec.png"><br>이미지 출처: <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)</a></p><p><a href="https://en.wikipedia.org/wiki/Initialization_vector">IV(Initialization vector)</a>라는 처음보는 값이 사용된다.<br>vector는 힘과 방향을 가진다 라고 학교에서 배웠었는데 여기서 어떤 의미로 vector가 쓰인 건지는 잘 모르겠다…</p><p>첫 블럭의 암호문 결과가 다음 블럭에도 쓰이기 때문에 암호화 할 때 병렬로 처리하지 못한다.<br>하지만 복호화 할 때는 복호화 한 블럭이 그 다음 블럭에 사용되는 게 아니기 때문에 병렬로 처리할 수 있다.<br>이런 부분에 있어서 무작위 대입 공격에 EBC 보다는 더 유리하지 않을까 싶다.</p><p>간단하게 예제를 만들어보자.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">&quot;a&quot;</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="comment">// 16 바이트가 아닌 경우에는 java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 16 bytes long 오류가 나온다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> IV = <span class="string">&quot;a&quot;</span>.repeat(BLOCK_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256CBC &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(IV.toByteArray())</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        SecretKeySpec(KEY.toByteArray(), <span class="string">&quot;AES&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while generating key: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        cipher.doFinal(plainText.toByteArray())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while encrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        String(cipher.doFinal(cipherText))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while decrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PLAIN_TEXT = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DUPLICATED_COUNT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256CBCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testEncrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 0 ~ 127 bit까지는 한 블럭 안에 담긴다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        assertThat(encrypted?.size).isEqualTo(BLOCK_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDecrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> decrypted = AES256CBC.decrypt(encrypted)</span><br><span class="line"></span><br><span class="line">        assertThat(PLAIN_TEXT).isEqualTo(decrypted)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `반복된 문자열을 암호화 해도 각 블럭은 다른 암호문 형태로 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 좀 더 깔끔한 예제를 만들기 위해 패딩 값이 없게 끔 각 블럭을 꽉꽉 채워 암호화 시도한다.</span></span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT.repeat(BLOCK_SIZE * DUPLICATED_COUNT))</span><br><span class="line">        <span class="keyword">val</span> encryptedBlocks = mutableListOf(</span><br><span class="line">                encrypted?.copyOfRange(<span class="number">0</span>, BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until DUPLICATED_COUNT) &#123;</span><br><span class="line">            <span class="keyword">val</span> firstBlock = encryptedBlocks.first()</span><br><span class="line">            <span class="keyword">val</span> currentBlock = encrypted?.copyOfRange(i * BLOCK_SIZE, i * BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (firstBlock.contentEquals(currentBlock)) <span class="keyword">continue</span></span><br><span class="line">            encryptedBlocks.add(currentBlock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 암호문에 들어간 반복된 문자열들이 추론 불가능하다.</span></span><br><span class="line">        assertThat(encryptedBlocks.size).isEqualTo(DUPLICATED_COUNT)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 아래 결함은 여전히 가지고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DUPLICATED_COUNT = <span class="number">5</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PLAIN_TEXT = <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256CBCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `똑같은 평문을 암호화 하면 똑같은 암호문이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> encrypted2 = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 딕셔너리를 만들어두면 어느 정도 암호문의 평문 데이터 추론이 가능해진다.</span></span><br><span class="line">        assertThat(encrypted).isEqualTo(encrypted2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>똑같은 평문을 암호화 하면 똑같은 암호문이 나온다</code>는 문제는 IV값이 매번 고정이기 때문에 발생하는 문제이다.<br>IV 값을 암호화 할 때마다 랜덤하게 생성해주면 된다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">&quot;a&quot;</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256CBC &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        SecretKeySpec(KEY.toByteArray(), <span class="string">&quot;AES&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while generating key: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Generate Random IV</span></span><br><span class="line">        <span class="keyword">val</span> iv = ByteArray(BLOCK_SIZE)</span><br><span class="line">        SecureRandom.getInstanceStrong().nextBytes(iv)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipher.doFinal(plainText.toByteArray())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Combine Random IV and Encrypted Data</span></span><br><span class="line">        iv + encrypted</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while encrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Extract IV and Encrypted Data.</span></span><br><span class="line">        <span class="keyword">val</span> iv = cipherText?.copyOfRange(<span class="number">0</span>, BLOCK_SIZE)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipherText?.copyOfRange(BLOCK_SIZE, cipherText.size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        String(cipher.doFinal(encrypted))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while decrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>암호화 할 때 매번 랜덤한 IV 값을 생성하고,<br>복호화 할 때는 랜덤한 IV 값을 알 수 없기 때문에 암호문 첫 16바이트는 랜덤하게 생성한 IV 값을 붙여서 리턴해야한다.  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `똑같은 평문을 암호화 하면 다른 암호문이 나온다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">    <span class="keyword">val</span> encrypted2 = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">    assertThat(encrypted).isNotEqualTo(encrypted2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> decrypted = AES256CBC.decrypt(encrypted)</span><br><span class="line">    assertThat(decrypted).isEqualTo(PLAIN_TEXT)</span><br><span class="line">    <span class="keyword">val</span> decrypted2 = AES256CBC.decrypt(encrypted2)</span><br><span class="line">    assertThat(decrypted2).isEqualTo(PLAIN_TEXT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>문자열의 길이에 따라서 암호문의 길이가 달라지기 때문에 평문의 길이가 유추 가능하다</code>라는 것도 문제라고 생각했는데<br><a href="https://stackoverflow.com/questions/7303103/java-aes-encryption-with-salt">Java AES Encryption with salt</a>을 보면<br>비밀번호와 달리 조금은 덜 민감한 정보를 암호화하는 것이기 때문인지 크게 중요치 않다고 여기는 것 같다.<br>애초에 AES의 목적이 고정된 길이를 리턴하는 해시 함수가 아니기 때문에도 그런 것 같다.  </p><h4 id="PBKDF2-Password-Based-Key-Derivation-Function"><a href="#PBKDF2-Password-Based-Key-Derivation-Function" class="headerlink" title="PBKDF2 (Password-Based Key Derivation Function)"></a>PBKDF2 (Password-Based Key Derivation Function)</h4><p>마지막으로 그러면 안 되겠지만 만약에 키 값이 털렸다고 치자.<br>하지만 키 값을 그대로 사용한 게 아니라 키 값을 다시 암호화 해서 사용했다면 어느 정도 안심할 수 있다.<br>이 때 사용할 키 값은 복호화 할 때도 사용할 키 값이기 때문에 항상 고정된 값을 리턴하는 암호화 알고리즘이어야 한다.  </p><p>이를 해소하기 위한 방법이 <strong>Key Derivation Function</strong>이다.<br>Key Derivation Function은 키 값도 늘려버리고, 암호화 횟수도 여러 번 돌려서 암호화를 수행하는데 시간이 오래 걸린다.<br>(하지만 AES는 키값이 128, 192, 256bit로 고정적이라서 키 값을 늘려버리진 않는다.)<br>그렇다고 해서 암호화 하는데 몇 초씩이나 걸리는 건 아니지만 해커가 일 초에 수십억 번 공격할 수 있는 걸 수천 번 정도 수준으로 줄여준다.<br>수천 번이라고 하니까 그래도 엄청 많아 보이지만 수십억 번에 비하면 새발의 피다.<br>또한 해시돼서 나오는 값이라 복호화도 불가능하다.  </p><p>그럼 예제를 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 길이는 256 bit(32 byte)이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KEY_LENGTH = <span class="number">32</span></span><br><span class="line"><span class="comment">// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY = <span class="string">&quot;a&quot;</span>.repeat(KEY_LENGTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PBKDF2에 적용할 값들이다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SALT = <span class="string">&quot;&#123;,*jbU787l@BcG:L]Oos/?s7EwMo:i/%No2z)sP@ut@=cydO9&amp;@Xa137-ZHkke&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ITERATION_COUNT = <span class="number">1024</span></span><br><span class="line"><span class="comment">// 키 값이 256 bit이기 때문에 해시 돌린 digest 길이도 256 bit여야 한다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DIGEST_BIT_LENGTH = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AES256CBC &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> secretKeySpec = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> factory = SecretKeyFactory.getInstance(<span class="string">&quot;PBKDF2WithHmacSHA256&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> spec = PBEKeySpec(KEY.toCharArray(), SALT.toByteArray(), ITERATION_COUNT, DIGEST_BIT_LENGTH)</span><br><span class="line">        SecretKeySpec(factory.generateSecret(spec).encoded, <span class="string">&quot;AES&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while generating key: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">encrypt</span><span class="params">(plainText: <span class="type">String</span>)</span></span>: ByteArray? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Generate Random IV</span></span><br><span class="line">        <span class="keyword">val</span> iv = ByteArray(BLOCK_SIZE)</span><br><span class="line">        <span class="keyword">val</span> secureRandom = SecureRandom.getInstanceStrong()</span><br><span class="line">        secureRandom.nextBytes(iv)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipher.doFinal(plainText.toByteArray())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Combine Random IV and Encrypted Data</span></span><br><span class="line">        iv + encrypted</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while encrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrypt</span><span class="params">(cipherText: <span class="type">ByteArray</span>?)</span></span>: String? = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Extract IV and Encrypted Data.</span></span><br><span class="line">        <span class="keyword">val</span> iv = cipherText?.copyOfRange(<span class="number">0</span>, BLOCK_SIZE)</span><br><span class="line">        <span class="keyword">val</span> ivParameterSpec = IvParameterSpec(iv)</span><br><span class="line">        <span class="keyword">val</span> encrypted = cipherText?.copyOfRange(BLOCK_SIZE, cipherText.size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>)</span><br><span class="line">        cipher.<span class="keyword">init</span>(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec)</span><br><span class="line">        String(cipher.doFinal(encrypted))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Error while decrypting: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AES256CBCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testEncrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        assertThat(encrypted).isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDecrypt</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> encrypted = AES256CBC.encrypt(PLAIN_TEXT)</span><br><span class="line">        <span class="keyword">val</span> decrypted = AES256CBC.decrypt(encrypted)</span><br><span class="line"></span><br><span class="line">        assertThat(PLAIN_TEXT).isEqualTo(decrypted)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)">Block cipher mode of operation</a>  </li><li><a href="https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9">Security Best Practices: Symmetric Encryption with AES in Java and Android</a>  </li><li><a href="https://whatis.techtarget.com/definition/initialization-vector-IV">initialization vector (IV)</a></li><li><a href="https://crypto.stackexchange.com/questions/20/what-are-the-practical-differences-between-256-bit-192-bit-and-128-bit-aes-enc">What are the practical differences between 256-bit, 192-bit, and 128-bit AES encryption?</a>  </li><li><a href="https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding">What is the difference between PKCS#5 padding and PKCS#7 padding</a>  </li><li><a href="https://howtodoinjava.com/security/java-aes-encryption-example/">Java AES Encryption Decryption Example</a>  </li><li><a href="https://www.javacodegeeks.com/2018/03/aes-encryption-and-decryption-in-javacbc-mode.html">AES Encryption and Decryption in Java(CBC Mode)</a>    </li><li><a href="https://gist.github.com/itarato/abef95871756970a9dad">Java AES CBC encryption example</a>  </li><li><a href="https://stackoverflow.com/questions/7303103/java-aes-encryption-with-salt">Java AES Encryption with salt</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/aes/thumb.png&quot;&gt;  &lt;/p&gt;
&lt;p&gt;막연하게 양방향 암호화 하면 당연스레 AES를 떠올리고, 제대로 모른 채로 사용했다.&lt;br&gt;이제부터라도 조금은 알고 써야겠다는 생각이 들어서 살짝 정리해봤다.&lt;/p&gt;
&lt;h2 id=&quot;양방향-단방향-암호화&quot;&gt;&lt;a href=&quot;#양방향-단방향-암호화&quot; class=&quot;headerlink&quot; title=&quot;양방향/단방향 암호화&quot;&gt;&lt;/a&gt;양방향/단방향 암호화&lt;/h2&gt;&lt;p&gt;양방향 암호화는 암호화 및 복호화가 가능하다는 소리다.&lt;br&gt;휴대폰 번호 등등 민감한 개인정보는 암호화 해서 저장해야하는데 고객 정보를 식별하기 위해선 복호화도 가능해야한다.&lt;br&gt;혹시나 키와 DB가 털린다면 복호화가 가능하므로 적어도 개인정보는 마스킹 한 후에 암호화해서 저장해야한다.&lt;br&gt;양방향 암호화 알고리즘에는 DES(보안에 취약), &lt;strong&gt;AES&lt;/strong&gt;, SEED(국내에서 개발, 공인인증서에 사용됨) 등등이 있다.&lt;/p&gt;
&lt;p&gt;단방향 암호화는 암호화만 가능하고 복호화는 불가능하다는 소리다.&lt;br&gt;비밀번호와 같이 암호화 한 값들끼리 단순히 비교만 하면 되고, 복호화 할 필요가 없는 정보들은 단방향 암호화 해야한다.&lt;br&gt;혹시나 키와 DB가 털려도 복호화가 불가능하기 때문에 암호화된 값만 알 수 있지 원본 비밀번호는 알 수 없기 때문에 양방향 암호화 보다는 좀 더 안전하다.&lt;br&gt;이런 특성 때문에 비밀번호 찾기 대신에 비밀번호 재설정 기능 밖에 지원 할 수 없다. (비밀번호 찾기를 지원해주는 사이트는 보안이 매우 안 좋은 사이트이다.)&lt;br&gt;단방향 암호화 알고리즘에는 해시 알고리즘이 사용되며 SHA256, SHA512, MD5(무작위 대입 공격에 약함) 등등이 있다.&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Dev" scheme="https://perfectacle.github.io/categories/Note/Dev/"/>
    
    
    <category term="암호화" scheme="https://perfectacle.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94/"/>
    
    <category term="AES" scheme="https://perfectacle.github.io/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>(Kotlin) Request에서 Nullable? Non-Null?</title>
    <link href="https://perfectacle.github.io/2019/09/18/kotlin-request-nullable-non-null/"/>
    <id>https://perfectacle.github.io/2019/09/18/kotlin-request-nullable-non-null/</id>
    <published>2019-09-17T16:23:39.000Z</published>
    <updated>2020-08-23T16:18:44.849Z</updated>
    
    <content type="html"><![CDATA[<p>코틀린의 장점을 하나 꼽자면 Non-null 타입을 지원한다는 것이다.<br>모든 곳에 null을 없앨 수 있는데(100% 순수 코틀린 코드로만 짠다면)<br>통제할 수 없는 부분은 클라이언트로부터 받는 Request이다.  </p><p>그래서 Request에는 어떤 타입을 써야할지 삽질을 해봤다.  </p><h2 id="기본값을-사용하자"><a href="#기본값을-사용하자" class="headerlink" title="기본값을 사용하자."></a>기본값을 사용하자.</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="keyword">val</span> name: String? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> dto: <span class="type">DTO</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같을 때 request body의 name에 아무런 내용도 입력하지 않으면 name에 기본값 <code>null</code>이 잘 세팅된다.<br>기본값이 전부 존재하면 default constructor가 생성돼서 객체를 손쉽게 생성할 수 있다보니 테스트 할 때 용이하다.  </p><h2 id="무조건-nullable-타입을-사용하자"><a href="#무조건-nullable-타입을-사용하자" class="headerlink" title="무조건 nullable 타입을 사용하자."></a>무조건 nullable 타입을 사용하자.</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="keyword">val</span> name: String = <span class="string">&quot;123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> dto: <span class="type">DTO</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같을 때 클라이언트에서 의도적으로 <code>&#123;&quot;name&quot;: null&#125;</code>을 보내는 순간<br><code>failed for JSON property name due to missing (therefore NULL) value for creator parameter name which is a non-nullable type</code><br>라는 오류와 함께 400 에러를 뱉는다. (<strong>타입에 관련된 에러임</strong>)<br>따라서 nullable 타입을 사용하자.</p><h2 id="Header와-Parameter의-default-value는-어노테이션에-있는-설정을-쓴다"><a href="#Header와-Parameter의-default-value는-어노테이션에-있는-설정을-쓴다" class="headerlink" title="Header와 Parameter의 default value는 어노테이션에 있는 설정을 쓴다."></a>Header와 Parameter의 default value는 어노테이션에 있는 설정을 쓴다.</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestHeader(required = false, defaultValue = <span class="meta-string">&quot;11&quot;</span>)</span> test: <span class="type">Int</span>?)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 때 헤더에 아무런 값도 보내지 않으면 11이 세팅된다.<br>하지만 아래와 같이 변수에 기본값을 세팅했다면 null이 세팅된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="meta">@RequestHeader(required = false)</span> test: <span class="type">Int</span>? = <span class="number">11</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;코틀린의 장점을 하나 꼽자면 Non-null 타입을 지원한다는 것이다.&lt;br&gt;모든 곳에 null을 없앨 수 있는데(100% 순수 코틀린 코드로만 짠다면)&lt;br&gt;통제할 수 없는 부분은 클라이언트로부터 받는 Request이다.  &lt;/p&gt;
&lt;p&gt;그래서 Request에는 어떤 타입을 써야할지 삽질을 해봤다.  &lt;/p&gt;
&lt;h2 id=&quot;기본값을-사용하자&quot;&gt;&lt;a href=&quot;#기본값을-사용하자&quot; class=&quot;headerlink&quot; title=&quot;기본값을 사용하자.&quot;&gt;&lt;/a&gt;기본값을 사용하자.&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DTO&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name: String? = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@RestController&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Controller&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@PostMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;meta&quot;&gt;@RequestBody&lt;/span&gt; dto: &lt;span class=&quot;type&quot;&gt;DTO&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;위와 같을 때 request body의 name에 아무런 내용도 입력하지 않으면 name에 기본값 &lt;code&gt;null&lt;/code&gt;이 잘 세팅된다.&lt;br&gt;기본값이 전부 존재하면 default constructor가 생성돼서 객체를 손쉽게 생성할 수 있다보니 테스트 할 때 용이하다.  &lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Kotlin" scheme="https://perfectacle.github.io/categories/Note/Kotlin/"/>
    
    
    <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
    <category term="Kotlin" scheme="https://perfectacle.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>(Kotlin) De/Serialize DTO 뽀개서 뿌셔버리기</title>
    <link href="https://perfectacle.github.io/2019/09/16/kotlin-de-serialize-dto/"/>
    <id>https://perfectacle.github.io/2019/09/16/kotlin-de-serialize-dto/</id>
    <published>2019-09-15T15:30:06.000Z</published>
    <updated>2020-08-23T16:18:44.848Z</updated>
    
    <content type="html"><![CDATA[<p>연차 대비 너무너무 느린 개발 속도를 향상시키기 위해 나만의 Cheetsheet를 하나씩 만들어야겠다.<br>처음 접하는 코틀린 환경에서 자바에서는 좀 할만했던 DTO의 (De)Serialize 관련해서 적어보았다.<br>모든 설명은 <strong>JSON으로 request와 response를 주고받는 HTTP API 기반</strong>으로 진행하기 때문에 엄밀히 따지면 부정확한 내용들이 많다.</p><h2 id="용어-설명"><a href="#용어-설명" class="headerlink" title="용어 설명"></a>용어 설명</h2><p>간단하게 용어들을 집고 넘어가자.</p><h3 id="DTO-Data-Transfer-Object"><a href="#DTO-Data-Transfer-Object" class="headerlink" title="DTO(Data Transfer Object)"></a>DTO(Data Transfer Object)</h3><p>데이터를 전송하는데 사용하는 객체  </p><p>쉽게 말해서 HTTP API에서 사용하는 JSON 타입 등등의 <strong>Request Body</strong>와 <strong>Response Body</strong>를 떠올리면 된다.<br>자바스크립트에서는 JSON이 자바스크립트의 Object 리터럴과 매우 유사해서 파싱하는데 크게 무리가 없지만,<br>JVM 진영에서는 꽤나 큰 이슈이다. (잘 몰라서 삽질을 하는 계기가 된다.)  </p><h3 id="Deserialize"><a href="#Deserialize" class="headerlink" title="Deserialize"></a>Deserialize</h3><p>쉽게 말하면 JSON 형태의 Request Body를 코틀린 등등의 Object로 파싱하는 작업을 의미한다.<br><strong>Setter에 해당 로직이 들어간다.</strong></p><p>Request Body는 클라이언트가 서버로 던지는 내용이다.<br>따라서 서버의 권한 밖이기 때문에 Kotlin이 non-null type을 지원한들 아래와 같은 문제를 마주치게 된다.</p><ol><li>non-null tpye이고, default value가 없는데 client에서 필드를 넘겨주지 않으면 (<code>&#123;&#125;</code>)</li><li>non-null tpye이고, default value가 있는데 client에서 null을 넘기면 (<code>&#123;&quot;field&quot;: null&#125;</code>)</li></ol><p>위와 같은 경우에 아래 오류와 마주치게 된다. (컴파일 타임에 클라이언트가 어떻게 던질지 모르므로 <strong>런타임 에러</strong>로 발생한다.)<br><code>JSON property name due to missing (therefore NULL) value for creator parameter name which is a non-nullable type</code></p><p><strong>따라서 클라이언트가 우리 말을 잘 듣는다는 보장이 없으므로 Request Body DTO의 필드들은 nullable type으로 지정해주자!</strong></p><h3 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize"></a>Serialize</h3><p>쉽게 말하면 코틀린 등등의 Object를 JSON 형태의 Response Body로 파싱하는 작업을 의미한다.<br><strong>Getter에 해당 로직이 들어간다.</strong></p><h2 id="기본적인-형태"><a href="#기본적인-형태" class="headerlink" title="기본적인 형태"></a>기본적인 형태</h2><p>가장 기본적인 형태들의 DTO를 파싱해보자.  </p><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-똑같은-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-똑같은-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 똑같은 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 똑같은 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;name: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;name: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="keyword">val</span> name: String?)</span><br></pre></td></tr></table></figure><h4 id="코틀린의-필드명과는-다른-경우"><a href="#코틀린의-필드명과는-다른-경우" class="headerlink" title="코틀린의 필드명과는 다른 경우"></a>코틀린의 필드명과는 다른 경우</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;n: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;n: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="meta">@JsonProperty(<span class="meta-string">&quot;n&quot;</span>)</span> <span class="keyword">val</span> name: String?)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-다른-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-필드명이-다른-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 다른 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 다른 경우</h3><p>dto field name: name<br>request body’s key: n<br>response body’s key: name</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;n: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;name: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(name: String?) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">        <span class="meta">@JsonProperty(access = JsonProperty.Access.READ_ONLY)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">&quot;n&quot;</span>, access = JsonProperty.Access.WRITE_ONLY)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dto field name: name<br>request body’s key: name<br>response body’s key: n</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;name: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;n: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(name: String?) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">&quot;n&quot;</span>, access = JsonProperty.Access.READ_ONLY)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dto field name: name<br>request body’s key: names<br>response body’s key: n</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;name: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;n: &quot;name&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(name: String?) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name</span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">&quot;n&quot;</span>, access = JsonProperty.Access.READ_ONLY)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonProperty(value = <span class="meta-string">&quot;names&quot;</span>, access = JsonProperty.Access.WRITE_ONLY)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LocalDateTime-3형제-다루기"><a href="#LocalDateTime-3형제-다루기" class="headerlink" title="LocalDateTime 3형제 다루기"></a>LocalDateTime 3형제 다루기</h2><p>보기 좋은 포맷으로 serialize하려면 <code>jackson-modules-java8</code>을 디펜던시에 추가해줘야한다.   </p><p>LocalDate, LocalTime, LocalDateTime 3형제를 다뤄보자.<br>모든 클라이언트가 ISO 8601을 따라서 Request Body를 만들어서 주면 좋겠지만 그렇지 않은 경우가 많기 때문에 직접 파싱해야할 경우가 있다.  </p><h3 id="기본-파싱-규칙-ISO-8601"><a href="#기본-파싱-규칙-ISO-8601" class="headerlink" title="기본 파싱 규칙 (ISO 8601)"></a>기본 파싱 규칙 (ISO 8601)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;date&quot;: &quot;2019-08-08&quot;, &quot;time&quot;: &quot;19:21:33&quot;, &quot;dateTime&quot;: &quot;2019-08-08T19:21:33&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;date&quot;: &quot;2019-08-08&quot;, &quot;time&quot;: &quot;19:21:33&quot;, &quot;dateTime&quot;: &quot;2019-08-08T19:21:33&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="keyword">val</span> date: LocalDate?,</span><br><span class="line">    <span class="keyword">val</span> time: LocalTime?,</span><br><span class="line">    <span class="keyword">val</span> dateTime: LocalDateTime?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;date&quot;: &quot;2019/08/08&quot;, &quot;time&quot;: &quot;19시 21분 33초&quot;, &quot;dateTime&quot;: &quot;2019/08/08 19시 21분 33초&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;date&quot;: &quot;2019/08/08&quot;, &quot;time&quot;: &quot;19시 21분 33초&quot;, &quot;dateTime&quot;: &quot;2019/08/08 19시 21분 33초&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd&quot;</span>)</span> <span class="keyword">val</span> date: LocalDate?,</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;HH시 mm분 ss초&quot;</span>)</span> <span class="keyword">val</span> time: LocalTime?,</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd HH시 mm분 ss초&quot;</span>)</span> <span class="keyword">val</span> dateTime: LocalDateTime?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;date&quot;: &quot;2019/08/08&quot;, &quot;time&quot;: &quot;19시 21분 33초&quot;, &quot;dateTime&quot;: &quot;2019/08/08 19시 21분 33초&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;date&quot;: &quot;2019-08-08&quot;, &quot;time&quot;: &quot;19:21:33&quot;, &quot;dateTime&quot;: &quot;2019-08-08T19:21:33&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    date: LocalDate?,</span><br><span class="line">    time: LocalTime?,</span><br><span class="line">    dateTime: LocalDateTime?</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> date = date</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy-MM-dd&quot;</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd&quot;</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> time = time</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;HH:mm:ss&quot;</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;HH시 mm분 ss초&quot;</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> dateTime = dateTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss&quot;</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd HH시 mm분 ss초&quot;</span>)</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="세계-시간-다루기"><a href="#세계-시간-다루기" class="headerlink" title="세계 시간 다루기"></a>세계 시간 다루기</h2><p>보기 좋은 포맷으로 serialize하려면 <code>jackson-modules-java8</code>을 디펜던시에 추가해줘야한다.  </p><p>Local 시리즈는 타임존이 없다.<br>저 시간/날짜가 영국 기준인지, 한국 기준인지 모른다.<br><strong>생일</strong>과 같이 타임존에 관계를 받지 않는 시간/날짜에 사용해야한다.  </p><p><strong>스포츠 중계</strong>와 같이 전세계에서 동시에 진행되는 경우에는 타임존이 필수다.<br>그럼 타임존을 가지고 있는 OffsetDateTime, ZonedDateTime, Instant를 다뤄보자.  </p><p>OffsetDateTime은 Timezone만 가지고 있는 반면, ZonedDateTime은 Timezone + Zone의 특성(Summer Time 여부 등등)도 가지고 있다.<br>Instant는 Unix Timestamp를 다룰 때 용이하다.</p><p>application.yaml에 아래 설정을 넣지 않으면 Deserialize해서 다루는 DTO 객체와 Response Body에 Timezone이 UTC로 고정된다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">deserialization:</span></span><br><span class="line">      <span class="attr">adjust_dates_to_context_time_zone:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="기본-파싱-규칙-ISO-8601-1"><a href="#기본-파싱-규칙-ISO-8601-1" class="headerlink" title="기본 파싱 규칙 (ISO 8601)"></a>기본 파싱 규칙 (ISO 8601)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;offsetDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019-08-08T19:21:33+09:00[Asia/Seoul]&quot;, &quot;unixTime&quot;: 1568558972&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;offsetDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;unixTime&quot;: &quot;2019-09-15T14:49:32Z&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="keyword">val</span> offsetDateTime: OffsetDateTime?,</span><br><span class="line">    <span class="keyword">val</span> zonedDateTime: ZonedDateTime?,</span><br><span class="line">    <span class="keyword">val</span> unixTime: Instant?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우-1"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-동일한-파싱-규칙을-사용하는-경우-1" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;offsetDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00 [Asia/Seoul]&quot;, &quot;unixTime&quot;: 1568558972&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;offsetDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00 [KST]&quot;, &quot;unixTime&quot;: &quot;2019-09-15T14:49:32Z&quot;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd HH시 mm분 ss초 XXX&quot;</span>)</span> <span class="keyword">val</span> offsetDateTime: OffsetDateTime?,</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd HH시 mm분 ss초 XXX &#x27;[&#x27;z&#x27;]&#x27;&quot;</span>)</span> <span class="keyword">val</span> zonedDateTime: ZonedDateTime?,</span><br><span class="line">    <span class="keyword">val</span> unixTime: Instant?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우-1"><a href="#Request-Body를-Deserialize-할-때와-Response-Body를-Serialize-할-때-다른-파싱-규칙을-사용하는-경우-1" class="headerlink" title="Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우"></a>Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deserialize from (request body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;offsetDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00 [Asia/Seoul]&quot;, &quot;unixTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * serialize to (response body)</span></span><br><span class="line"><span class="comment"> * &#123;&quot;offsetDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019-08-08T19:21:33+09:00[KST]&quot;, &quot;unixTime&quot;: 1565259693&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZonedDateTimeDTO3</span></span>(</span><br><span class="line">    offsetDateTime: OffsetDateTime?,</span><br><span class="line">    zonedDateTime: ZonedDateTime?,</span><br><span class="line">    unixTime: Instant?</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> offsetDateTime = offsetDateTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ssXXX&quot;</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd HH시 mm분 ss초 XXX&quot;</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> zonedDateTime = zonedDateTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ssXXX&#x27;[&#x27;z&#x27;]&#x27;&quot;</span>)</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd HH시 mm분 ss초 XXX &#x27;[&#x27;z&#x27;]&#x27;&quot;</span>)</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> unixTime = unixTime</span><br><span class="line">        <span class="meta">@JsonFormat(pattern = <span class="meta-string">&quot;yyyy/MM/dd HH시 mm분 ss초 XXX&quot;</span>)</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUnixTime</span><span class="params">()</span></span> = unixTime?.epochSecond</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;연차 대비 너무너무 느린 개발 속도를 향상시키기 위해 나만의 Cheetsheet를 하나씩 만들어야겠다.&lt;br&gt;처음 접하는 코틀린 환경에서 자바에서는 좀 할만했던 DTO의 (De)Serialize 관련해서 적어보았다.&lt;br&gt;모든 설명은 &lt;strong&gt;JSON으로 request와 response를 주고받는 HTTP API 기반&lt;/strong&gt;으로 진행하기 때문에 엄밀히 따지면 부정확한 내용들이 많다.&lt;/p&gt;
&lt;h2 id=&quot;용어-설명&quot;&gt;&lt;a href=&quot;#용어-설명&quot; class=&quot;headerlink&quot; title=&quot;용어 설명&quot;&gt;&lt;/a&gt;용어 설명&lt;/h2&gt;&lt;p&gt;간단하게 용어들을 집고 넘어가자.&lt;/p&gt;
&lt;h3 id=&quot;DTO-Data-Transfer-Object&quot;&gt;&lt;a href=&quot;#DTO-Data-Transfer-Object&quot; class=&quot;headerlink&quot; title=&quot;DTO(Data Transfer Object)&quot;&gt;&lt;/a&gt;DTO(Data Transfer Object)&lt;/h3&gt;&lt;p&gt;데이터를 전송하는데 사용하는 객체  &lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
    <category term="Kotlin" scheme="https://perfectacle.github.io/categories/Note/Kotlin/"/>
    
    
    <category term="Spring" scheme="https://perfectacle.github.io/tags/Spring/"/>
    
    <category term="Kotlin" scheme="https://perfectacle.github.io/tags/Kotlin/"/>
    
  </entry>
  
</feed>
